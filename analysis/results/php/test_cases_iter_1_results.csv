Test Case Weakness,Test Case File,Test Case Code,Test Case Line,LLM Hit CWE,LLM Hit Code,LLM Code,LLM Complete Response
CWE-79,src/CWE_79__GET__func_mysql_real_escape_string__Use_untrusted_data_script-doublequoted_String.php,"<!-- 
Unsafe sample
input : reads the field UserData from the variable $_GET
SANITIZE : use of mysql_real_escape string
File : use of untrusted data in a double quoted string in a script
-->

<!--Copyright 2015 Bertrand STIVALET 

Permission is hereby granted, without written agreement or royalty fee, to

use, copy, modify, and distribute this software and its documentation for

any purpose, provided that the above copyright notice and the following

three paragraphs appear in all copies of this software.


IN NO EVENT SHALL AUTHORS BE LIABLE TO ANY PARTY FOR DIRECT,

INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES ARISING OUT OF THE 

USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF AUTHORS HAVE

BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.


AUTHORS SPECIFICALLY DISCLAIM ANY WARRANTIES INCLUDING, BUT NOT

LIMITED TO THE IMPLIED WARRANTIES OF MERCHANTABILITY, FITNESS FOR A

PARTICULAR PURPOSE, AND NON-INFRINGEMENT.


THE SOFTWARE IS PROVIDED ON AN ""AS-IS"" BASIS AND AUTHORS HAVE NO

OBLIGATION TO PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR

MODIFICATIONS.-->


<!DOCTYPE html>
<html>
<head>
<script>
<?php
$tainted = $_GET['UserData'];

$tainted = mysql_real_escape_string($tainted);


echo ""alert(\"""". $tainted .""\"")"" ;
?>
</script>
</head>
<body>
<h1>Hello World!</h1>
</body>
</html>","echo ""alert(\"""". $tainted .""\"")"" ;",True,True,"echo ""alert(\"""". $tainted .""\"")"" ;","```xml
<Issues>
  <Issue>
    <Type>Security</Type>
    <Weakness>CWE-79</Weakness>
    <Description>Improper Neutralization of Input During Web Page Generation ('Cross-site Scripting')</Description>
    <Severity>Medium</Severity>
    <File>File 1</File>
    <Code>echo ""alert(\"""". $tainted .""\"")"" ;</Code>
    <Justification>Even with mysql_real_escape_string, the output is vulnerable to XSS because the data is inserted directly into Javascript code. mysql_real_escape_string is designed to prevent SQL injection, not XSS. A malicious user could inject javascript code.</Justification>
  </Issue>
</Issues>
```"
CWE-89,src/CWE_89__popen__func_mysql_real_escape_string__multiple_select-interpretation.php,"<?php







$handle = popen('/bin/cat /tmp/tainted.txt', 'r');
$tainted = fread($handle, 4096);
pclose($handle);

$tainted = mysql_real_escape_string($tainted);

$query = ""SELECT * FROM COURSE c WHERE c.id IN (SELECT idcourse FROM REGISTRATION WHERE idstudent= $tainted )"";


$conn = mysql_connect('localhost', 'mysql_user', 'mysql_password'); 
mysql_select_db('dbname') ;
echo ""query : "". $query .""<br /><br />"" ;

$res = mysql_query($query); 

while($data =mysql_fetch_array($res)){
print_r($data) ;
echo ""<br />"" ;
} 
mysql_close($conn);

?>","$conn = mysql_connect('localhost', 'mysql_user', 'mysql_password'); ",True,False,"$query = ""SELECT * FROM COURSE c WHERE c.id IN (SELECT idcourse FROM REGISTRATION WHERE idstudent= $tainted )"";","```xml
<Issues>
  <Issue>
    <Type>Security</Type>
    <Weakness>CWE-89</Weakness>
    <Description>Improper Neutralization of Special Elements used in an SQL Command ('SQL Injection')</Description>
    <Severity>Critical</Severity>
    <File>File 1</File>
    <Code>$query = ""SELECT * FROM COURSE c WHERE c.id IN (SELECT idcourse FROM REGISTRATION WHERE idstudent= $tainted )"";</Code>
    <Justification>The code is vulnerable to SQL injection. Although mysql_real_escape_string is used, it is deprecated and unsafe, and does not prevent all types of SQL injection attacks. The $tainted variable, derived from an external source, is directly embedded into the SQL query without proper sanitization using a secure method like prepared statements with parameterized queries.</Justification>
  </Issue>
  <Issue>
    <Type>Security</Type>
    <Weakness>CWE-477</Weakness>
    <Description>Use of Obsolete Function</Description>
    <Severity>Medium</Severity>
    <File>File 1</File>
    <Code>$tainted = mysql_real_escape_string($tainted);</Code>
    <Justification>The function mysql_real_escape_string is deprecated and should not be used. It is part of the old mysql extension, which is no longer maintained and has been removed in newer versions of PHP. This function has known vulnerabilities and does not offer sufficient protection against SQL injection.</Justification>
  </Issue>
  <Issue>
    <Type>Security</Type>
    <Weakness>CWE-798</Weakness>
    <Description>Use of Hard-coded Credentials</Description>
    <Severity>Critical</Severity>
    <File>File 1</File>
    <Code>$conn = mysql_connect('localhost', 'mysql_user', 'mysql_password');</Code>
    <Justification>The code uses hard-coded credentials ('mysql_user', 'mysql_password') for connecting to the database. This is a security risk, as these credentials could be exposed, allowing unauthorized access to the database.</Justification>
  </Issue>
  <Issue>
    <Type>Reliability</Type>
    <Weakness>CWE-252</Weakness>
    <Description>Unchecked Return Value</Description>
    <Severity>Medium</Severity>
    <File>File 1</File>
    <Code>$conn = mysql_connect('localhost', 'mysql_user', 'mysql_password');
mysql_select_db('dbname') ;
$res = mysql_query($query);</Code>
    <Justification>The code does not check the return values of mysql_connect, mysql_select_db, and mysql_query. If any of these functions fail, the script will continue to execute, potentially leading to unexpected behavior or security vulnerabilities. For example, if mysql_connect fails, $conn will be false, and subsequent calls using $conn will result in errors. Similarly, if mysql_query fails, $res will be false, and mysql_fetch_array will cause an error.</Justification>
  </Issue>
  <Issue>
    <Type>Security</Type>
    <Weakness>CWE-424</Weakness>
    <Description>Improper Protection of Alternate Path</Description>
    <Severity>Medium</Severity>
    <File>File 1</File>
    <Code>$handle = popen('/bin/cat /tmp/tainted.txt', 'r');
$tainted = fread($handle, 4096);
pclose($handle);</Code>
    <Justification>The code uses popen to execute a command. If the path to /tmp/tainted.txt is under attacker control, they could influence the data being read. Additionally, if an attacker can modify the /tmp/tainted.txt file, they can inject malicious code into the SQL query.</Justification>
  </Issue>
</Issues>
```"
CWE-79,src/CWE_79__exec__func_mysql_real_escape_string__Use_untrusted_data-div.php,"<!-- 
Unsafe sample
input : use exec to execute the script /tmp/tainted.php and store the output in $tainted
SANITIZE : use of mysql_real_escape string
File : use of untrusted data in a div tag
-->

<!--Copyright 2015 Bertrand STIVALET 

Permission is hereby granted, without written agreement or royalty fee, to

use, copy, modify, and distribute this software and its documentation for

any purpose, provided that the above copyright notice and the following

three paragraphs appear in all copies of this software.


IN NO EVENT SHALL AUTHORS BE LIABLE TO ANY PARTY FOR DIRECT,

INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES ARISING OUT OF THE 

USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF AUTHORS HAVE

BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.


AUTHORS SPECIFICALLY DISCLAIM ANY WARRANTIES INCLUDING, BUT NOT

LIMITED TO THE IMPLIED WARRANTIES OF MERCHANTABILITY, FITNESS FOR A

PARTICULAR PURPOSE, AND NON-INFRINGEMENT.


THE SOFTWARE IS PROVIDED ON AN ""AS-IS"" BASIS AND AUTHORS HAVE NO

OBLIGATION TO PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR

MODIFICATIONS.-->


<!DOCTYPE html>
<html>
<head/>
<body>
<div>
<?php
$script = ""/tmp/tainted.php"";
exec($script, $result, $return);

$tainted = $result[0];

$tainted = mysql_real_escape_string($tainted);


echo $tainted ;
?>
</div>
<h1>Hello World!</h1>
</body>
</html>",echo $tainted ;,False,False,,"```xml
<Issues>
  <Issue>
    <Type>Security</Type>
    <Weakness>CWE-77</Weakness>
    <Description>Improper Neutralization of Special Elements used in a Command ('Command Injection')</Description>
    <Severity>High</Severity>
    <File>File 1</File>
    <Code>exec($script, $result, $return);</Code>
    <Justification>The code executes a script whose content is not validated. If the script contains malicious code, it will be executed. This is command injection.</Justification>
  </Issue>
  <Issue>
    <Type>Security</Type>
    <Weakness>CWE-477</Weakness>
    <Description>Use of Obsolete Function</Description>
    <Severity>Low</Severity>
    <File>File 1</File>
    <Code>$tainted = mysql_real_escape_string($tainted);</Code>
    <Justification>The function mysql_real_escape_string() is deprecated. It is recommended to use prepared statements or other escaping mechanisms.</Justification>
  </Issue>
</Issues>
```"
CWE-90,src/CWE_90__proc_open__func_preg_match-no_filtering__userByCN-concatenation_simple_quote.php,"<?php







$descriptorspec = array(
  0 => array(""pipe"", ""r""),
  1 => array(""pipe"", ""w""),
  2 => array(""file"", ""/tmp/error-output.txt"", ""a"")
  );
$cwd = '/tmp';
$process = proc_open('more /tmp/tainted.txt', $descriptorspec, $pipes, $cwd, NULL);
if (is_resource($process)) {
  fclose($pipes[0]);
  $tainted = stream_get_contents($pipes[1]);
  fclose($pipes[1]);
  $return_value = proc_close($process);
}

$re = ""/^.*$/"";
if(preg_match($re, $tainted) == 1){
  $tainted = $tainted;
}
else{
  $tainted = """";
}

$query = ""(&(objectCategory=person)(objectClass=user)(cn='"". $tainted . ""'))"";


$ds=ldap_connect(""localhost""); 
$r=ldap_bind($ds);
$sr=ldap_search($ds,""o=My Company, c=US"", $query);  
ldap_close($ds);

?>","$ds=ldap_connect(""localhost"");",False,False,,"```xml
<Issues>
  <Issue>
    <Type>Security</Type>
    <Weakness>CWE-77</Weakness>
    <Description>Improper Neutralization of Special Elements used in a Command ('Command Injection')</Description>
    <Severity>Medium</Severity>
    <File>File 1</File>
    <Code>$process = proc_open('more /tmp/tainted.txt', $descriptorspec, $pipes, $cwd, NULL);</Code>
    <Justification>The code uses proc_open to execute a command 'more /tmp/tainted.txt'. Although the command itself is static, if the contents of '/tmp/tainted.txt' are attacker-controlled, it could lead to command injection if the contents contain shell metacharacters.</Justification>
  </Issue>
  <Issue>
    <Type>Security</Type>
    <Weakness>CWE-89</Weakness>
    <Description>Improper Neutralization of Special Elements used in an SQL Command ('SQL Injection')</Description>
    <Severity>High</Severity>
    <File>File 1</File>
    <Code>$query = ""(&(objectCategory=person)(objectClass=user)(cn='"". $tainted . ""'))"";</Code>
    <Justification>The code constructs an LDAP query by directly embedding the $tainted variable, which originates (indirectly) from a file, into the query string. If the contents of the file are attacker-controlled, this can lead to LDAP injection.</Justification>
  </Issue>
  <Issue>
    <Type>Reliability</Type>
    <Weakness>CWE-252</Weakness>
    <Description>Unchecked Return Value</Description>
    <Severity>Low</Severity>
    <File>File 1</File>
    <Code>$r=ldap_bind($ds);</Code>
    <Justification>The return value of ldap_bind is not checked. If the bind operation fails, subsequent LDAP operations might fail or return unexpected results.</Justification>
  </Issue>
  <Issue>
    <Type>Reliability</Type>
    <Weakness>CWE-252</Weakness>
    <Description>Unchecked Return Value</Description>
    <Severity>Low</Severity>
    <File>File 1</File>
    <Code>$sr=ldap_search($ds,""o=My Company, c=US"", $query);</Code>
    <Justification>The return value of ldap_search is not checked. If the search operation fails, the application might not handle the error correctly.</Justification>
  </Issue>
  <Issue>
    <Type>Reliability</Type>
    <Weakness>CWE-703</Weakness>
    <Description>Improper Check or Handling of Exceptional Conditions</Description>
    <Severity>Medium</Severity>
    <File>File 1</File>
    <Code>if (is_resource($process)) {
  fclose($pipes[0]);
  $tainted = stream_get_contents($pipes[1]);
  fclose($pipes[1]);
  $return_value = proc_close($process);
}</Code>
    <Justification>The code checks if $process is a resource, but does not handle the case where proc_open fails and $process is not a resource. This could lead to errors when trying to close the pipes and process.</Justification>
  </Issue>
  <Issue>
    <Type>Security</Type>
    <Weakness>CWE-22</Weakness>
    <Description>Improper Limitation of a Pathname to a Restricted Directory ('Path Traversal')</Description>
    <Severity>Medium</Severity>
    <File>File 1</File>
    <Code>2 => array(""file"", ""/tmp/error-output.txt"", ""a"")</Code>
    <Justification>The code writes error output to `/tmp/error-output.txt`. While this specific case is unlikely to be directly exploitable, writing to arbitrary files in `/tmp` can be problematic if an attacker can influence the filename or contents.  It could be used as part of a larger exploit chain. It is better to restrict the path or use a more secure location.</Justification>
  </Issue>
</Issues>
```"
CWE-91,src/CWE_91__exec__no_sanitizing__username_at-interpretation_simple_quote.php,"<?php







$script = ""/tmp/tainted.php"";
exec($script, $result, $return);

$tainted = $result[0];



$query = ""


$xml = simplexml_load_file(""users.xml"");
echo ""query : "". $query .""<br /><br />"" ;

$res=$xml->xpath($query);
print_r($res);
echo ""<br />"" ;

?>","$xml = simplexml_load_file(""users.xml"");",False,False,,"```xml
<Issues>
  <Issue>
    <Type>Security</Type>
    <Weakness>CWE-78</Weakness>
    <Description>Improper Neutralization of Special Elements used in a Command ('Command Injection')</Description>
    <Severity>High</Severity>
    <File>File 1</File>
    <Code>$script = ""/tmp/tainted.php"";
exec($script, $result, $return);

$tainted = $result[0];</Code>
    <Justification>The code executes an external script without sanitizing the input, which could lead to command injection if the script's contents are malicious or controlled by an attacker. The output of the script is then used in an xpath query which could be dangerous.</Justification>
  </Issue>
  <Issue>
    <Type>Security</Type>
    <Weakness>CWE-643</Weakness>
    <Description>Improper Neutralization of Data within XPath Expressions ('XPath Injection')</Description>
    <Severity>High</Severity>
    <File>File 1</File>
    <Code>$xml = simplexml_load_file(""users.xml"");
echo ""query : "". $query .""<br /><br />"" ;

$res=$xml->xpath($query);</Code>
    <Justification>The code uses a variable $query in an xpath query, which is populated with the output of the exec call. If the contents of /tmp/tainted.php are controlled by a malicious user, they could inject malicious xpath and compromise the data in the users.xml file.</Justification>
  </Issue>
</Issues>
```"
CWE-79,src/CWE_79__fopen__func_FILTER-CLEANING-special_chars_filter__Use_untrusted_data_propertyValue_CSS-double_Quoted_Property_Value.php,"<!-- 
Unsafe sample
input : use fopen to read /tmp/tainted.txt and put the first line in $tainted
Uses a special_chars_filter via filter_var function
File : use of untrusted data in a double quoted property value (CSS)
-->

<!--Copyright 2015 Bertrand STIVALET 

Permission is hereby granted, without written agreement or royalty fee, to

use, copy, modify, and distribute this software and its documentation for

any purpose, provided that the above copyright notice and the following

three paragraphs appear in all copies of this software.


IN NO EVENT SHALL AUTHORS BE LIABLE TO ANY PARTY FOR DIRECT,

INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES ARISING OUT OF THE 

USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF AUTHORS HAVE

BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.


AUTHORS SPECIFICALLY DISCLAIM ANY WARRANTIES INCLUDING, BUT NOT

LIMITED TO THE IMPLIED WARRANTIES OF MERCHANTABILITY, FITNESS FOR A

PARTICULAR PURPOSE, AND NON-INFRINGEMENT.


THE SOFTWARE IS PROVIDED ON AN ""AS-IS"" BASIS AND AUTHORS HAVE NO

OBLIGATION TO PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR

MODIFICATIONS.-->


<!DOCTYPE html>
<html>
<head>
<style>
<?php
$handle = @fopen(""/tmp/tainted.txt"", ""r"");

if ($handle) {
  if(($tainted = fgets($handle, 4096)) == false) {
    $tainted = """";
  }
  fclose($handle);
} else {
  $tainted = """";
}

$sanitized = filter_var($tainted, FILTER_SANITIZE_SPECIAL_CHARS);
  $tainted = $sanitized ;
      


echo ""body { color :\"""". $tainted .""\"" ; }"" ;
?>
</style> 
</head>
<body>
<h1>Hello World!</h1>
</body>
</html>","echo ""body { color :\"""". $tainted .""\"" ; }"" ;",True,True,"echo ""body { color :\"""". $tainted .""\"" ; }"" ;","```xml
<Issues>
  <Issue>
    <Type>Security</Type>
    <Weakness>CWE-79</Weakness>
    <Description>Improper Neutralization of Input During Web Page Generation ('Cross-site Scripting')</Description>
    <Severity>Medium</Severity>
    <File>File 1</File>
    <Code>echo ""body { color :\"""". $tainted .""\"" ; }"" ;</Code>
    <Justification>The code echoes user-controlled input ($tainted) directly into the CSS style attribute. While FILTER_SANITIZE_SPECIAL_CHARS is used, it may not be sufficient to prevent XSS in all contexts, especially within CSS. An attacker might be able to inject malicious CSS code.</Justification>
  </Issue>
  <Issue>
    <Type>Reliability</Type>
    <Weakness>CWE-252</Weakness>
    <Description>Unchecked Return Value</Description>
    <Severity>Low</Severity>
    <File>File 1</File>
    <Code>  if(($tainted = fgets($handle, 4096)) == false) {
    $tainted = """";
  }</Code>
    <Justification>The code checks if fgets returns false, but does not handle potential errors during file reading, which can lead to unexpected behavior if the file cannot be read correctly.</Justification>
  </Issue>
  <Issue>
    <Type>Security</Type>
    <Weakness>CWE-477</Weakness>
    <Description>Use of Obsolete Function</Description>
    <Severity>Low</Severity>
    <File>File 1</File>
    <Code>$sanitized = filter_var($tainted, FILTER_SANITIZE_SPECIAL_CHARS);</Code>
    <Justification>While not strictly obsolete, relying solely on FILTER_SANITIZE_SPECIAL_CHARS can be insufficient for robust XSS prevention in all contexts. More modern and context-aware sanitization techniques might be preferred for enhanced security.</Justification>
  </Issue>
  <Issue>
    <Type>Security</Type>
    <Weakness>CWE-22</Weakness>
    <Description>Improper Limitation of a Pathname to a Restricted Directory ('Path Traversal')</Description>
    <Severity>Medium</Severity>
    <File>File 1</File>
    <Code>$handle = @fopen(""/tmp/tainted.txt"", ""r"");</Code>
    <Justification>The code directly opens a file from a hardcoded path (""/tmp/tainted.txt""). While this specific path might not immediately represent a path traversal vulnerability, the reliance on a fixed, external file introduces a potential risk. If the application's security context permits, an attacker who can control the contents of ""/tmp/tainted.txt"" could influence the application's behavior, potentially leading to vulnerabilities.</Justification>
  </Issue>
  <Issue>
    <Type>Reliability</Type>
    <Weakness>CWE-391</Weakness>
    <Description>Unchecked Error Condition</Description>
    <Severity>Low</Severity>
    <File>File 1</File>
    <Code>if ($handle) {
  if(($tainted = fgets($handle, 4096)) == false) {
    $tainted = """";
  }
  fclose($handle);
} else {
  $tainted = """";
}</Code>
    <Justification>The code checks if fopen fails but assigns an empty string to $tainted. While this prevents a crash, it doesn't report or log the error, making debugging and monitoring more difficult. A more robust error handling mechanism would improve reliability.</Justification>
  </Issue>
</Issues>
```"
CWE-79,src/CWE_79__object-indexArray__func_FILTER-CLEANING-special_chars_filter__Use_untrusted_data_attribute-unquoted_Attr.php,"<!-- 
Unsafe sample
input : get the field userData from the variable $_GET via an object, which store it in a array
Uses a special_chars_filter via filter_var function
File : use of untrusted data in a unquoted attribute
-->

<!--Copyright 2015 Bertrand STIVALET 

Permission is hereby granted, without written agreement or royalty fee, to

use, copy, modify, and distribute this software and its documentation for

any purpose, provided that the above copyright notice and the following

three paragraphs appear in all copies of this software.


IN NO EVENT SHALL AUTHORS BE LIABLE TO ANY PARTY FOR DIRECT,

INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES ARISING OUT OF THE 

USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF AUTHORS HAVE

BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.


AUTHORS SPECIFICALLY DISCLAIM ANY WARRANTIES INCLUDING, BUT NOT

LIMITED TO THE IMPLIED WARRANTIES OF MERCHANTABILITY, FITNESS FOR A

PARTICULAR PURPOSE, AND NON-INFRINGEMENT.


THE SOFTWARE IS PROVIDED ON AN ""AS-IS"" BASIS AND AUTHORS HAVE NO

OBLIGATION TO PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR

MODIFICATIONS.-->


<!DOCTYPE html>
<html>
<head/>
<body>
<?php
class Input{
  private $input;

  public function getInput(){
    return $this->input['realOne'];
  }

  public  function __construct(){
    $this->input = array();
    $this->input['test']= 'safe' ;
    $this->input['realOne']= $_GET['UserData'] ;
    $this->input['trap']= 'safe' ;
  }
}
$temp = new Input();
$tainted =  $temp->getInput();

$sanitized = filter_var($tainted, FILTER_SANITIZE_SPECIAL_CHARS);
  $tainted = $sanitized ;
      


echo ""<div id="". $tainted ."">content</div>"" ;
?>
<h1>Hello World!</h1>
</body>
</html>","echo ""<div id="". $tainted ."">content</div>"" ;",True,True,"$tainted = filter_var($tainted, FILTER_SANITIZE_SPECIAL_CHARS);
  $tainted = $sanitized ;
      


echo ""<div id="". $tainted ."">content</div>"" ;","```xml
<Issues>
  <Issue>
    <Type>Security</Type>
    <Weakness>CWE-79</Weakness>
    <Description>Improper Neutralization of Input During Web Page Generation ('Cross-site Scripting')</Description>
    <Severity>Medium</Severity>
    <File>File 1</File>
    <Code>$tainted = filter_var($tainted, FILTER_SANITIZE_SPECIAL_CHARS);
  $tainted = $sanitized ;
      


echo ""&lt;div id="". $tainted ."">content&lt;/div>"" ;</Code>
    <Justification>The code takes user input from $_GET['UserData'], sanitizes it using FILTER_SANITIZE_SPECIAL_CHARS, and then uses it to construct an HTML attribute value within a div tag. Although special characters are sanitized, the output is not quoted, which can lead to XSS vulnerabilities if the sanitized string contains characters that break the HTML structure. For example, if $tainted contains a string like ""value onload=alert('XSS')"", the resulting HTML will be &lt;div id=value onload=alert('XSS')&gt;content&lt;/div&gt;, which executes the JavaScript alert('XSS').</Justification>
  </Issue>
</Issues>
```"
CWE-91,src/CWE_91__array-GET__func_FILTER-CLEANING-email_filter__username-sprintf_%s_simple_quote.php,"<?php







$array = array();
$array[] = 'safe' ;
$array[] = $_GET['userData'] ;
$array[] = 'safe' ;
$tainted = $array[1] ;

$sanitized = filter_var($tainted, FILTER_SANITIZE_EMAIL);
if (filter_var($sanitized, FILTER_VALIDATE_EMAIL))
  $tainted = $sanitized ;
else
  $tainted = """" ;

$query = sprintf(""user[username='%s']"", $tainted);


$xml = simplexml_load_file(""users.xml"");
echo ""query : "". $query .""<br /><br />"" ;

$res=$xml->xpath($query);
print_r($res);
echo ""<br />"" ;

?>","$xml = simplexml_load_file(""users.xml"");",False,False,,"```xml
<Issues>
  <Issue>
    <Type>Security</Type>
    <Weakness>CWE-643</Weakness>
    <Description>Improper Neutralization of Data within XPath Expressions ('XPath Injection')</Description>
    <Severity>High</Severity>
    <File>File 1</File>
    <Code>$query = sprintf(""user[username='%s']"", $tainted);</Code>
    <Justification>The code constructs an XPath query using user-controlled data ($tainted) without proper neutralization. Although the input is sanitized as an email, this does not prevent XPath injection as special characters relevant to XPath syntax can still be present. This allows an attacker to control the structure of the query.</Justification>
  </Issue>
</Issues>
```"
CWE-79,src/CWE_79__object-indexArray__func_FILTER-CLEANING-email_filter__Use_untrusted_data_script-quoted_Event_Handler.php,"<!-- 
Unsafe sample
input : get the field userData from the variable $_GET via an object, which store it in a array
Uses an email_filter via filter_var function
File : use of untrusted data in a quoted event handler in a script
-->

<!--Copyright 2015 Bertrand STIVALET 

Permission is hereby granted, without written agreement or royalty fee, to

use, copy, modify, and distribute this software and its documentation for

any purpose, provided that the above copyright notice and the following

three paragraphs appear in all copies of this software.


IN NO EVENT SHALL AUTHORS BE LIABLE TO ANY PARTY FOR DIRECT,

INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES ARISING OUT OF THE 

USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF AUTHORS HAVE

BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.


AUTHORS SPECIFICALLY DISCLAIM ANY WARRANTIES INCLUDING, BUT NOT

LIMITED TO THE IMPLIED WARRANTIES OF MERCHANTABILITY, FITNESS FOR A

PARTICULAR PURPOSE, AND NON-INFRINGEMENT.


THE SOFTWARE IS PROVIDED ON AN ""AS-IS"" BASIS AND AUTHORS HAVE NO

OBLIGATION TO PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR

MODIFICATIONS.-->


<!DOCTYPE html>
<html>
<head/>
<body>
<?php
class Input{
  private $input;

  public function getInput(){
    return $this->input['realOne'];
  }

  public  function __construct(){
    $this->input = array();
    $this->input['test']= 'safe' ;
    $this->input['realOne']= $_GET['UserData'] ;
    $this->input['trap']= 'safe' ;
  }
}
$temp = new Input();
$tainted =  $temp->getInput();

$sanitized = filter_var($tainted, FILTER_SANITIZE_EMAIL);
if (filter_var($sanitized, FILTER_VALIDATE_EMAIL))
  $tainted = $sanitized ;
else
  $tainted = """" ;


echo ""<div onmouseover=\""x='"". $tainted .""'\>"";
?>
<h1>Hello World!</h1>
</div>
</body>
</html>","echo ""<div onmouseover=\""x='"". $tainted .""'\>"";",True,True,"echo ""<div onmouseover=\""x='"". $tainted .""'\>"";","```xml
<Issues>
  <Issue>
    <Type>Security</Type>
    <Weakness>CWE-79</Weakness>
    <Description>Improper Neutralization of Input During Web Page Generation ('Cross-site Scripting')</Description>
    <Severity>Medium</Severity>
    <File>File 1</File>
    <Code>echo ""&lt;div onmouseover=\""x='"". $tainted .""'\>"";</Code>
    <Justification>The code uses unsanitized input `$tainted` within an HTML event handler (`onmouseover`). Although the input is sanitized using `filter_var` with `FILTER_SANITIZE_EMAIL`, this is insufficient to prevent XSS attacks because the sanitized email is placed within single quotes in the JavaScript code. An attacker could inject arbitrary JavaScript code by providing an email address containing a single quote, which would break out of the string literal and allow the attacker to execute arbitrary JavaScript code. For example, an input like `' onclick=alert(1) //` would cause an alert box to appear when the mouse is moved over the div.</Justification>
  </Issue>
</Issues>
```"
CWE-90,src/CWE_90__object-indexArray__no_sanitizing__userByCN-concatenation_simple_quote.php,"<?php







class Input{
  private $input;

  public function getInput(){
    return $this->input['realOne'];
  }

  public  function __construct(){
    $this->input = array();
    $this->input['test']= 'safe' ;
    $this->input['realOne']= $_GET['UserData'] ;
    $this->input['trap']= 'safe' ;
  }
}
$temp = new Input();
$tainted =  $temp->getInput();



$query = ""(&(objectCategory=person)(objectClass=user)(cn='"". $tainted . ""'))"";


$ds=ldap_connect(""localhost""); 
$r=ldap_bind($ds);
$sr=ldap_search($ds,""o=My Company, c=US"", $query);  
ldap_close($ds);

?>","$ds=ldap_connect(""localhost"");",True,False,"$query = ""(&(objectCategory=person)(objectClass=user)(cn='"". $tainted . ""'))"";","```xml
<Issues>
  <Issue>
    <Type>Security</Type>
    <Weakness>CWE-90</Weakness>
    <Description>Improper Neutralization of Special Elements used in an LDAP Query ('LDAP Injection')</Description>
    <Severity>High</Severity>
    <File>File 1</File>
    <Code>$query = ""(&(objectCategory=person)(objectClass=user)(cn='"". $tainted . ""'))"";</Code>
    <Justification>The code constructs an LDAP query by directly concatenating user-controlled input ($tainted) without proper sanitization. This can lead to LDAP injection vulnerabilities, where an attacker can manipulate the query to bypass authentication or retrieve unauthorized information.</Justification>
  </Issue>
  <Issue>
    <Type>Reliability</Type>
    <Weakness>CWE-252</Weakness>
    <Description>Unchecked Return Value</Description>
    <Severity>Medium</Severity>
    <File>File 1</File>
    <Code>$r=ldap_bind($ds);
$sr=ldap_search($ds,""o=My Company, c=US"", $query);</Code>
    <Justification>The code does not check the return values of ldap_bind() and ldap_search(). If these functions fail, they will return FALSE, and the script will continue to execute, potentially leading to unexpected behavior or security vulnerabilities.</Justification>
  </Issue>
</Issues>
```"
CWE-90,src/CWE_90__exec__func_preg_match-no_filtering__name-sprintf_%s_simple_quote.php,"<?php







$script = ""/tmp/tainted.php"";
exec($script, $result, $return);

$tainted = $result[0];

$re = ""/^.*$/"";
if(preg_match($re, $tainted) == 1){
  $tainted = $tainted;
}
else{
  $tainted = """";
}

$query = sprintf(""name='%s'"", $tainted);


$ds=ldap_connect(""localhost""); 
$r=ldap_bind($ds);
$sr=ldap_search($ds,""o=My Company, c=US"", $query);  
ldap_close($ds);

?>","$ds=ldap_connect(""localhost"");",True,True,"$query = sprintf(""name='%s'"", $tainted);


$ds=ldap_connect(""localhost""); 
$r=ldap_bind($ds);
$sr=ldap_search($ds,""o=My Company, c=US"", $query);  
ldap_close($ds);","```xml
<Issues>
  <Issue>
    <Type>Security</Type>
    <Weakness>CWE-78</Weakness>
    <Description>Improper Neutralization of Special Elements used in a Command ('Command Injection')</Description>
    <Severity>High</Severity>
    <File>File 1</File>
    <Code>$script = ""/tmp/tainted.php"";
exec($script, $result, $return);

$tainted = $result[0];</Code>
    <Justification>The code executes an external script without proper sanitization. If the script's content is controlled by an attacker, they can inject arbitrary commands. The output of the script then becomes tainted data.</Justification>
  </Issue>
  <Issue>
    <Type>Security</Type>
    <Weakness>CWE-90</Weakness>
    <Description>Improper Neutralization of Special Elements used in an LDAP Query ('LDAP Injection')</Description>
    <Severity>High</Severity>
    <File>File 1</File>
    <Code>$query = sprintf(""name='%s'"", $tainted);


$ds=ldap_connect(""localhost""); 
$r=ldap_bind($ds);
$sr=ldap_search($ds,""o=My Company, c=US"", $query);  
ldap_close($ds);</Code>
    <Justification>The code constructs an LDAP query using sprintf with unsanitized input ($tainted). This can lead to LDAP injection vulnerabilities if $tainted contains malicious characters, allowing attackers to bypass authentication or access unauthorized data.</Justification>
  </Issue>
</Issues>
```"
CWE-79,src/CWE_79__backticks__func_FILTER-CLEANING-full_special_chars_filter__Use_untrusted_data_propertyValue_CSS-quoted_Property_Value.php,"<!-- 
Unsafe sample
input : backticks interpretation, reading the file /tmp/tainted.txt
Uses a full_special_chars_filter via filter_var function
File : unsafe, use of untrusted data in a quoted property value (CSS)
-->

<!--Copyright 2015 Bertrand STIVALET 

Permission is hereby granted, without written agreement or royalty fee, to

use, copy, modify, and distribute this software and its documentation for

any purpose, provided that the above copyright notice and the following

three paragraphs appear in all copies of this software.


IN NO EVENT SHALL AUTHORS BE LIABLE TO ANY PARTY FOR DIRECT,

INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES ARISING OUT OF THE 

USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF AUTHORS HAVE

BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.


AUTHORS SPECIFICALLY DISCLAIM ANY WARRANTIES INCLUDING, BUT NOT

LIMITED TO THE IMPLIED WARRANTIES OF MERCHANTABILITY, FITNESS FOR A

PARTICULAR PURPOSE, AND NON-INFRINGEMENT.


THE SOFTWARE IS PROVIDED ON AN ""AS-IS"" BASIS AND AUTHORS HAVE NO

OBLIGATION TO PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR

MODIFICATIONS.-->


<!DOCTYPE html>
<html>
<head>
<style>
<?php
$tainted = `cat /tmp/tainted.txt`;

$sanitized = filter_var($tainted, FILTER_SANITIZE_FULL_SPECIAL_CHARS);
  $tainted = $sanitized ;
     


echo ""body { color :\'"". $tainted .""\' ; }"" ;
?>
</style> 
</head>
<body>
<h1>Hello World!</h1>
</body>
</html>","echo ""body { color :\'"". $tainted .""\' ; }"" ;",True,True,"echo ""body { color :\'"". $tainted .""\' ; }"" ;","```xml
<Issues>
  <Issue>
    <Type>Security</Type>
    <Weakness>CWE-77</Weakness>
    <Description>Improper Neutralization of Special Elements used in a Command ('Command Injection')</Description>
    <Severity>High</Severity>
    <File>File 1</File>
    <Code>$tainted = `cat /tmp/tainted.txt`;</Code>
    <Justification>The code uses backticks to execute a shell command (`cat /tmp/tainted.txt`). This is equivalent to `shell_exec()` and allows command injection if the filename `/tmp/tainted.txt` is attacker-controlled or if the file's contents are attacker-controlled, potentially leading to arbitrary command execution on the server.</Justification>
  </Issue>
  <Issue>
    <Type>Security</Type>
    <Weakness>CWE-79</Weakness>
    <Description>Improper Neutralization of Input During Web Page Generation ('Cross-site Scripting')</Description>
    <Severity>Medium</Severity>
    <File>File 1</File>
    <Code>echo ""body { color :\'"". $tainted .""\' ; }"" ;</Code>
    <Justification>The code outputs the `$tainted` variable directly into the CSS style without proper context-aware escaping. Although `filter_var` with `FILTER_SANITIZE_FULL_SPECIAL_CHARS` is used, it's intended for HTML context, not CSS. An attacker could inject malicious CSS code (e.g., using `\`, `""` or other CSS-significant characters) that bypasses the filter and leads to XSS or other client-side attacks.</Justification>
  </Issue>
</Issues>
```"
CWE-90,src/CWE_90__backticks__func_htmlspecialchars__userByMail-sprintf_%s_simple_quote.php,"<?php







$tainted = `cat /tmp/tainted.txt`;

$tainted = htmlspecialchars($tainted, ENT_QUOTES);

$query = sprintf(""(&(objectCategory=person)(objectClass=user)(mail='%s'))"", $tainted);


$ds=ldap_connect(""localhost""); 
$r=ldap_bind($ds);
$sr=ldap_search($ds,""o=My Company, c=US"", $query);  
ldap_close($ds);

?>","$ds=ldap_connect(""localhost"");",True,False,"$query = sprintf(""(&(objectCategory=person)(objectClass=user)(mail='%s'))"", $tainted);","```xml
<Issues>
  <Issue>
    <Type>Security</Type>
    <Weakness>CWE-90</Weakness>
    <Description>Improper Neutralization of Special Elements used in an LDAP Query ('LDAP Injection')</Description>
    <Severity>High</Severity>
    <File>File 1</File>
    <Code>$query = sprintf(""(&(objectCategory=person)(objectClass=user)(mail='%s'))"", $tainted);</Code>
    <Justification>The code constructs an LDAP query using untrusted input $tainted without proper sanitization, making it vulnerable to LDAP injection attacks. An attacker could manipulate the query to bypass authentication or retrieve sensitive information.</Justification>
  </Issue>
  <Issue>
    <Type>Security</Type>
    <Weakness>CWE-77</Weakness>
    <Description>Improper Neutralization of Special Elements used in a Command ('Command Injection')</Description>
    <Severity>High</Severity>
    <File>File 1</File>
    <Code>$tainted = `cat /tmp/tainted.txt`;</Code>
    <Justification>The code uses backticks to execute a system command (`cat /tmp/tainted.txt`) based on external input. This is vulnerable to command injection because an attacker could modify the contents of `/tmp/tainted.txt` to execute arbitrary commands on the server.</Justification>
  </Issue>
  <Issue>
    <Type>Security</Type>
    <Weakness>CWE-252</Weakness>
    <Description>Unchecked Return Value</Description>
    <Severity>Medium</Severity>
    <File>File 1</File>
    <Code>$r=ldap_bind($ds);
$sr=ldap_search($ds,""o=My Company, c=US"", $query);</Code>
    <Justification>The code does not check the return values of `ldap_bind` and `ldap_search`. If these functions fail, the script may continue to execute with invalid resources, potentially leading to unexpected behavior or security vulnerabilities.</Justification>
  </Issue>
</Issues>
```"
CWE-91,src/CWE_91__SESSION__no_sanitizing__data-interpretation_simple_quote.php,"<?php







$tainted = $_SESSION['UserData'];



$query = ""' $tainted '"";


$xml = simplexml_load_file(""users.xml"");
echo ""query : "". $query .""<br /><br />"" ;

$res=$xml->xpath($query);
print_r($res);
echo ""<br />"" ;

?>","$xml = simplexml_load_file(""users.xml"");",True,True,"$tainted = $_SESSION['UserData'];

$query = ""' $tainted '"";


$xml = simplexml_load_file(""users.xml"");
echo ""query : "". $query .""<br /><br />"" ;

$res=$xml->xpath($query);","```xml
<Issues>
  <Issue>
    <Type>Security</Type>
    <Weakness>CWE-91</Weakness>
    <Description>XML Injection (aka Blind XPath Injection)</Description>
    <Severity>High</Severity>
    <File>File 1</File>
    <Code>$tainted = $_SESSION['UserData'];

$query = ""' $tainted '"";


$xml = simplexml_load_file(""users.xml"");
echo ""query : "". $query .""&lt;br /&gt;&lt;br /&gt;"" ;

$res=$xml->xpath($query);</Code>
    <Justification>The code constructs an XPath query using unsanitized user input from $_SESSION['UserData']. This allows an attacker to inject malicious XPath expressions, potentially extracting sensitive information or manipulating the XML data.</Justification>
  </Issue>
  <Issue>
    <Type>Reliability</Type>
    <Weakness>CWE-252</Weakness>
    <Description>Unchecked Return Value</Description>
    <Severity>Medium</Severity>
    <File>File 1</File>
    <Code>$xml = simplexml_load_file(""users.xml"");</Code>
    <Justification>The code does not check the return value of simplexml_load_file(). If the file cannot be loaded (e.g., due to a missing file or invalid XML), the function will return FALSE, which could lead to errors later in the script when $xml is used.</Justification>
  </Issue>
  <Issue>
    <Type>Reliability</Type>
    <Weakness>CWE-703</Weakness>
    <Description>Improper Check or Handling of Exceptional Conditions</Description>
    <Severity>Medium</Severity>
    <File>File 1</File>
    <Code>$xml = simplexml_load_file(""users.xml"");
echo ""query : "". $query .""&lt;br /&gt;&lt;br /&gt;"" ;

$res=$xml->xpath($query);
print_r($res);
echo ""&lt;br /&gt;"" ;</Code>
    <Justification>The code does not handle the potential exception if the xpath query fails. If the query is invalid or returns an error, xpath can trigger an error which is not handled here.</Justification>
  </Issue>
</Issues>
```"
CWE-79,src/CWE_79__object-Array__func_FILTER-CLEANING-email_filter__Unsafe_use_untrusted_data-tag_Name.php,"<!-- 
Unsafe sample
input : get the field userData from the variable $_GET via an object, which store it in a array
Uses an email_filter via filter_var function
File : unsafe, use of untrusted data in an tag name
-->

<!--Copyright 2015 Bertrand STIVALET 

Permission is hereby granted, without written agreement or royalty fee, to

use, copy, modify, and distribute this software and its documentation for

any purpose, provided that the above copyright notice and the following

three paragraphs appear in all copies of this software.


IN NO EVENT SHALL AUTHORS BE LIABLE TO ANY PARTY FOR DIRECT,

INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES ARISING OUT OF THE 

USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF AUTHORS HAVE

BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.


AUTHORS SPECIFICALLY DISCLAIM ANY WARRANTIES INCLUDING, BUT NOT

LIMITED TO THE IMPLIED WARRANTIES OF MERCHANTABILITY, FITNESS FOR A

PARTICULAR PURPOSE, AND NON-INFRINGEMENT.


THE SOFTWARE IS PROVIDED ON AN ""AS-IS"" BASIS AND AUTHORS HAVE NO

OBLIGATION TO PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR

MODIFICATIONS.-->


<!DOCTYPE html>
<html>
<head/>
<body>
<?php
class Input{
  private $input;

  public function getInput(){
    return $this->input[1];
  }

  public  function __construct(){
    $this->input = array();
    $this->input[0]= 'safe' ;
    $this->input[1]= $_GET['UserData'] ;
    $this->input[2]= 'safe' ;
  }
}
$temp = new Input();
$tainted =  $temp->getInput();

$sanitized = filter_var($tainted, FILTER_SANITIZE_EMAIL);
if (filter_var($sanitized, FILTER_VALIDATE_EMAIL))
  $tainted = $sanitized ;
else
  $tainted = """" ;


echo ""<"".  $tainted ."" href= \""/bob\"" />"" ;
?>
<h1>Hello World!</h1>
</body>
</html>","echo ""<"".  $tainted ."" href= \""/bob\"" />"" ;",True,True,"echo ""<"".  $tainted ."" href= \""/bob\"" />"" ;","```xml
<Issues>
  <Issue>
    <Type>Security</Type>
    <Weakness>CWE-79</Weakness>
    <Description>Improper Neutralization of Input During Web Page Generation ('Cross-site Scripting')</Description>
    <Severity>High</Severity>
    <File>File 1</File>
    <Code>echo ""&lt;"".  $tainted ."" href= \""/bob\"" />"" ;</Code>
    <Justification>The code uses unsanitized user input `$tainted` to construct an HTML tag name. Even with email sanitization, the input can still contain characters that can break the HTML structure or introduce XSS vulnerabilities. For example, a tag name like `img src=x onerror=alert(1)` would still be possible, leading to arbitrary JavaScript execution.</Justification>
  </Issue>
</Issues>
```"
CWE-90,src/CWE_90__backticks__func_addslashes__userByCN-concatenation_simple_quote.php,"<?php







$tainted = `cat /tmp/tainted.txt`;

$tainted = addslashes($tainted);

$query = ""(&(objectCategory=person)(objectClass=user)(cn='"". $tainted . ""'))"";


$ds=ldap_connect(""localhost""); 
$r=ldap_bind($ds);
$sr=ldap_search($ds,""o=My Company, c=US"", $query);  
ldap_close($ds);

?>","$ds=ldap_connect(""localhost"");",True,True,"$tainted = `cat /tmp/tainted.txt`;
$tainted = addslashes($tainted);

$query = ""(&(objectCategory=person)(objectClass=user)(cn='"". $tainted . ""'))"";","```xml
<Issues>
  <Issue>
    <Type>Security</Type>
    <Weakness>CWE-90</Weakness>
    <Description>Improper Neutralization of Special Elements used in an LDAP Query ('LDAP Injection')</Description>
    <Severity>High</Severity>
    <File>File 1</File>
    <Code>$tainted = `cat /tmp/tainted.txt`;
$tainted = addslashes($tainted);

$query = ""(&(objectCategory=person)(objectClass=user)(cn='"". $tainted . ""'))"";</Code>
    <Justification>The code constructs an LDAP query by concatenating user-controlled input ($tainted) directly into the query string. Although addslashes() is used, it's not sufficient to prevent LDAP injection. Attackers can still manipulate the query to bypass authentication or access unauthorized data.</Justification>
  </Issue>
  <Issue>
    <Type>Security</Type>
    <Weakness>CWE-78</Weakness>
    <Description>Improper Neutralization of Special Elements used in an OS Command ('OS Command Injection')</Description>
    <Severity>High</Severity>
    <File>File 1</File>
    <Code>$tainted = `cat /tmp/tainted.txt`;</Code>
    <Justification>The code uses backticks to execute an external command (`cat /tmp/tainted.txt`). This is vulnerable to OS command injection if the file `/tmp/tainted.txt` is controlled by a malicious actor. An attacker could insert arbitrary commands into the file, which would then be executed by the server.</Justification>
  </Issue>
  <Issue>
    <Type>Reliability</Type>
    <Weakness>CWE-252</Weakness>
    <Description>Unchecked Return Value</Description>
    <Severity>Medium</Severity>
    <File>File 1</File>
    <Code>$ds=ldap_connect(""localhost""); 
$r=ldap_bind($ds);
$sr=ldap_search($ds,""o=My Company, c=US"", $query);</Code>
    <Justification>The code does not check the return values of `ldap_connect()`, `ldap_bind()`, and `ldap_search()`. If any of these functions fail, the script will continue to execute, potentially leading to unexpected behavior or security vulnerabilities. For example, if `ldap_connect()` fails, `$ds` will be false, and subsequent calls to `ldap_bind()` and `ldap_search()` will result in errors.</Justification>
  </Issue>
  <Issue>
    <Type>Maintainability</Type>
    <Weakness>CWE-1051</Weakness>
    <Description>Initialization with Hard-Coded Network Resource Configuration Data</Description>
    <Severity>Low</Severity>
    <File>File 1</File>
    <Code>$ds=ldap_connect(""localhost"");</Code>
    <Justification>The code initializes the LDAP connection with a hard-coded server address (""localhost""). This makes the code less flexible and harder to maintain, as the address cannot be easily changed without modifying the source code.</Justification>
  </Issue>
</Issues>
```"
CWE-91,src/CWE_91__fopen__func_FILTER-CLEANING-full_special_chars_filter__username-interpretation_simple_quote.php,"<?php







$handle = @fopen(""/tmp/tainted.txt"", ""r"");

if ($handle) {
  if(($tainted = fgets($handle, 4096)) == false) {
    $tainted = """";
  }
  fclose($handle);
} else {
  $tainted = """";
}

$sanitized = filter_var($tainted, FILTER_SANITIZE_FULL_SPECIAL_CHARS);
  $tainted = $sanitized ;
     

$query = ""user[username=' $tainted ']"";


$xml = simplexml_load_file(""users.xml"");
echo ""query : "". $query .""<br /><br />"" ;

$res=$xml->xpath($query);
print_r($res);
echo ""<br />"" ;

?>","$xml = simplexml_load_file(""users.xml"");",False,False,,"```xml
<Issues>
  <Issue>
    <Type>Security</Type>
    <Weakness>CWE-643</Weakness>
    <Description>Improper Neutralization of Data within XPath Expressions ('XPath Injection')</Description>
    <Severity>High</Severity>
    <File>File 1</File>
    <Code>$query = ""user[username=' $tainted ']"";


$xml = simplexml_load_file(""users.xml"");
echo ""query : "". $query .""&lt;br /&gt;&lt;br /&gt;"" ;

$res=$xml->xpath($query);</Code>
    <Justification>The code constructs an XPath query using user-controlled input ($tainted) without proper neutralization. Even though the input is sanitized using FILTER_SANITIZE_FULL_SPECIAL_CHARS, it's not sufficient to prevent XPath injection. An attacker could manipulate the $tainted variable to inject malicious XPath code, potentially gaining unauthorized access to data or modifying the XML structure. The use of simplexml_load_file with an externally influenced XPath query exacerbates the risk.</Justification>
  </Issue>
</Issues>
```"
CWE-90,src/CWE_90__popen__no_sanitizing__name-sprintf_%s_simple_quote.php,"<?php







$handle = popen('/bin/cat /tmp/tainted.txt', 'r');
$tainted = fread($handle, 4096);
pclose($handle);



$query = sprintf(""name='%s'"", $tainted);


$ds=ldap_connect(""localhost""); 
$r=ldap_bind($ds);
$sr=ldap_search($ds,""o=My Company, c=US"", $query);  
ldap_close($ds);

?>","$ds=ldap_connect(""localhost"");",True,True,"$handle = popen('/bin/cat /tmp/tainted.txt', 'r');
$tainted = fread($handle, 4096);
pclose($handle);



$query = sprintf(""name='%s'"", $tainted);


$ds=ldap_connect(""localhost""); 
$r=ldap_bind($ds);
$sr=ldap_search($ds,""o=My Company, c=US"", $query);  
ldap_close($ds);","```xml
<Issues>
  <Issue>
    <Type>Security</Type>
    <Weakness>CWE-90</Weakness>
    <Description>Improper Neutralization of Special Elements used in an LDAP Query ('LDAP Injection')</Description>
    <Severity>High</Severity>
    <File>File 1</File>
    <Code>$handle = popen('/bin/cat /tmp/tainted.txt', 'r');
$tainted = fread($handle, 4096);
pclose($handle);



$query = sprintf(""name='%s'"", $tainted);


$ds=ldap_connect(""localhost""); 
$r=ldap_bind($ds);
$sr=ldap_search($ds,""o=My Company, c=US"", $query);  
ldap_close($ds);</Code>
    <Justification>The code reads data from a file and uses it directly in an LDAP query without proper sanitization. This makes the application vulnerable to LDAP injection attacks. An attacker could manipulate the contents of /tmp/tainted.txt to inject malicious LDAP code, potentially gaining unauthorized access or control over the LDAP server.</Justification>
  </Issue>
  <Issue>
    <Type>Reliability</Type>
    <Weakness>CWE-252</Weakness>
    <Description>Unchecked Return Value</Description>
    <Severity>Medium</Severity>
    <File>File 1</File>
    <Code>$ds=ldap_connect(""localhost""); 
$r=ldap_bind($ds);
$sr=ldap_search($ds,""o=My Company, c=US"", $query);  
ldap_close($ds);</Code>
    <Justification>The code does not check the return values of ldap_connect, ldap_bind, and ldap_search. If any of these functions fail, the subsequent code might operate on an invalid resource or produce unexpected results, leading to a denial of service or other unexpected behavior.</Justification>
  </Issue>
  <Issue>
    <Type>Security</Type>
    <Weakness>CWE-77</Weakness>
    <Description>Improper Neutralization of Special Elements used in a Command ('Command Injection')</Description>
    <Severity>High</Severity>
    <File>File 1</File>
    <Code>$handle = popen('/bin/cat /tmp/tainted.txt', 'r');
$tainted = fread($handle, 4096);
pclose($handle);</Code>
    <Justification>The code uses popen to execute a command. The command itself, `/bin/cat /tmp/tainted.txt`, is not directly influenced by user input in this snippet. However, the contents of `/tmp/tainted.txt` are used later in an LDAP query. If an attacker can control the content of `/tmp/tainted.txt`, they could inject OS commands into the LDAP query, which might be executed if the LDAP server is misconfigured or has vulnerabilities.</Justification>
  </Issue>
</Issues>
```"
CWE-79,src/CWE_79__backticks__whitelist_using_array__Unsafe_use_untrusted_data-attribute_Name.php,"<!-- 
Unsafe sample
input : backticks interpretation, reading the file /tmp/tainted.txt
SANITIZE : use in_array to check if $tainted is in the white list
File : unsafe, use of untrusted data in an attribute name
-->

<!--Copyright 2015 Bertrand STIVALET 

Permission is hereby granted, without written agreement or royalty fee, to

use, copy, modify, and distribute this software and its documentation for

any purpose, provided that the above copyright notice and the following

three paragraphs appear in all copies of this software.


IN NO EVENT SHALL AUTHORS BE LIABLE TO ANY PARTY FOR DIRECT,

INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES ARISING OUT OF THE 

USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF AUTHORS HAVE

BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.


AUTHORS SPECIFICALLY DISCLAIM ANY WARRANTIES INCLUDING, BUT NOT

LIMITED TO THE IMPLIED WARRANTIES OF MERCHANTABILITY, FITNESS FOR A

PARTICULAR PURPOSE, AND NON-INFRINGEMENT.


THE SOFTWARE IS PROVIDED ON AN ""AS-IS"" BASIS AND AUTHORS HAVE NO

OBLIGATION TO PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR

MODIFICATIONS.-->


<!DOCTYPE html>
<html>
<body>
<?php
$tainted = `cat /tmp/tainted.txt`;

$legal_table = array(""safe1"", ""safe2"");
if (in_array($tainted, $legal_table, true)) {
  $tainted = $tainted;
} else {
  $tainted = $legal_table[0];
}


echo ""<div "". $tainted .""= bob />"" ;
?>
<h1>Hello World!</h1>
</div>
</body>
</html>","echo ""<div "". $tainted .""= bob />"" ;",True,True,"echo ""<div "". $tainted .""= bob />"" ;","```xml
<Issues>
  <Issue>
    <Type>Security</Type>
    <Weakness>CWE-77</Weakness>
    <Description>Improper Neutralization of Special Elements used in a Command ('Command Injection')</Description>
    <Severity>High</Severity>
    <File>File 1</File>
    <Code>$tainted = `cat /tmp/tainted.txt`;</Code>
    <Justification>The code uses backticks to execute a system command based on a hardcoded path, which could lead to command injection if the system allows modification of /tmp/tainted.txt. Although the intention is to read a file, backticks execute the content as a system command.</Justification>
  </Issue>
  <Issue>
    <Type>Security</Type>
    <Weakness>CWE-79</Weakness>
    <Description>Improper Neutralization of Input During Web Page Generation ('Cross-site Scripting')</Description>
    <Severity>Medium</Severity>
    <File>File 1</File>
    <Code>echo ""&lt;div "". $tainted .""= bob />"" ;</Code>
    <Justification>The code uses unsanitized input $tainted in an HTML attribute name, which can lead to Cross-Site Scripting (XSS) if the value contains malicious code. Although the code attempts to sanitize the input with in_array, it only checks against a whitelist, and the whitelist itself might be bypassed or manipulated.</Justification>
  </Issue>
  <Issue>
    <Type>Reliability</Type>
    <Weakness>CWE-252</Weakness>
    <Description>Unchecked Return Value</Description>
    <Severity>Low</Severity>
    <File>File 1</File>
    <Code>$tainted = `cat /tmp/tainted.txt`;</Code>
    <Justification>The code does not check the return value of the backticks operator. If the command fails to execute (e.g., file not found, permission denied), $tainted will be null, which is then used in an HTML attribute, potentially leading to unexpected behavior.</Justification>
  </Issue>
</Issues>
```"
CWE-79,src/CWE_79__GET__func_mysql_real_escape_string__Use_untrusted_data_script-quoted_Event_Handler.php,"<!-- 
Unsafe sample
input : reads the field UserData from the variable $_GET
SANITIZE : use of mysql_real_escape string
File : use of untrusted data in a quoted event handler in a script
-->

<!--Copyright 2015 Bertrand STIVALET 

Permission is hereby granted, without written agreement or royalty fee, to

use, copy, modify, and distribute this software and its documentation for

any purpose, provided that the above copyright notice and the following

three paragraphs appear in all copies of this software.


IN NO EVENT SHALL AUTHORS BE LIABLE TO ANY PARTY FOR DIRECT,

INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES ARISING OUT OF THE 

USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF AUTHORS HAVE

BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.


AUTHORS SPECIFICALLY DISCLAIM ANY WARRANTIES INCLUDING, BUT NOT

LIMITED TO THE IMPLIED WARRANTIES OF MERCHANTABILITY, FITNESS FOR A

PARTICULAR PURPOSE, AND NON-INFRINGEMENT.


THE SOFTWARE IS PROVIDED ON AN ""AS-IS"" BASIS AND AUTHORS HAVE NO

OBLIGATION TO PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR

MODIFICATIONS.-->


<!DOCTYPE html>
<html>
<head/>
<body>
<?php
$tainted = $_GET['UserData'];

$tainted = mysql_real_escape_string($tainted);


echo ""<div onmouseover=\""x='"". $tainted .""'\>"";
?>
<h1>Hello World!</h1>
</div>
</body>
</html>","echo ""<div onmouseover=\""x='"". $tainted .""'\>"";",True,True,"echo ""<div onmouseover=\""x='"". $tainted .""'\>"";","```xml
<Issues>
  <Issue>
    <Type>Security</Type>
    <Weakness>CWE-79</Weakness>
    <Description>Improper Neutralization of Input During Web Page Generation ('Cross-site Scripting')</Description>
    <Severity>Medium</Severity>
    <File>File 1</File>
    <Code>echo ""&lt;div onmouseover=\""x='"". $tainted .""'\&gt;"";</Code>
    <Justification>The code uses user-controlled input to dynamically generate a web page, but it does not neutralize the data to prevent it from containing content that is executable by a web browser (JavaScript, HTML tags, etc.). Although mysql_real_escape_string is used, it is intended for SQL injection prevention and does not protect against XSS in this context (HTML attribute). An attacker can inject malicious JavaScript code via the UserData GET parameter, which will be executed when a user mouses over the div element.</Justification>
  </Issue>
</Issues>
```"
CWE-78,src/CWE_78__unserialize__func_preg_match-no_filtering__cat-concatenation_simple_quote.php,"<?php







$string = $_POST['UserData'] ;
$tainted = unserialize($string);
    

$re = ""/^.*$/"";
if(preg_match($re, $tainted) == 1){
  $tainted = $tainted;
}
else{
  $tainted = """";
}

$query = ""cat '"". $tainted . ""'"";


$ret = system($query);


?>",$ret = system($query);,False,False,,"```xml
<Issues>
  <Issue>
    <Type>Security</Type>
    <Weakness>CWE-77</Weakness>
    <Description>Improper Neutralization of Special Elements used in a Command ('Command Injection')</Description>
    <Severity>High</Severity>
    <File>File 1</File>
    <Code>$query = ""cat '"". $tainted . ""'"";


$ret = system($query);</Code>
    <Justification>The code constructs a shell command using user-provided data without proper sanitization. This allows an attacker to inject arbitrary commands into the system, leading to potential code execution.</Justification>
  </Issue>
  <Issue>
    <Type>Security</Type>
    <Weakness>CWE-502</Weakness>
    <Description>Deserialization of Untrusted Data</Description>
    <Severity>Critical</Severity>
    <File>File 1</File>
    <Code>$string = $_POST['UserData'] ;
$tainted = unserialize($string);</Code>
    <Justification>The code uses unserialize() on user-provided data without validation. This allows an attacker to inject arbitrary PHP objects, leading to potential remote code execution.</Justification>
  </Issue>
</Issues>
```"
CWE-90,src/CWE_90__POST__func_addslashes__userByCN-interpretation_simple_quote.php,"<?php







$tainted = $_POST['UserData'];

$tainted = addslashes($tainted);

$query = ""(&(objectCategory=person)(objectClass=user)(cn=' $tainted '))"";


$ds=ldap_connect(""localhost""); 
$r=ldap_bind($ds);
$sr=ldap_search($ds,""o=My Company, c=US"", $query);  
ldap_close($ds);

?>","$ds=ldap_connect(""localhost"");",True,True,"$tainted = $_POST['UserData'];

$tainted = addslashes($tainted);

$query = ""(&(objectCategory=person)(objectClass=user)(cn=' $tainted '))"";","```xml
<Issues>
  <Issue>
    <Type>Security</Type>
    <Weakness>CWE-90</Weakness>
    <Description>Improper Neutralization of Special Elements used in an LDAP Query ('LDAP Injection')</Description>
    <Severity>High</Severity>
    <File>File 1</File>
    <Code>$tainted = $_POST['UserData'];

$tainted = addslashes($tainted);

$query = ""(&(objectCategory=person)(objectClass=user)(cn=' $tainted '))"";</Code>
    <Justification>The code constructs an LDAP query using user-supplied data without proper sanitization, making it vulnerable to LDAP injection attacks. Although addslashes is used, it is not sufficient to prevent LDAP injection.</Justification>
  </Issue>
  <Issue>
    <Type>Reliability</Type>
    <Weakness>CWE-252</Weakness>
    <Description>Unchecked Return Value</Description>
    <Severity>Medium</Severity>
    <File>File 1</File>
    <Code>$ds=ldap_connect(""localhost""); 
$r=ldap_bind($ds);
$sr=ldap_search($ds,""o=My Company, c=US"", $query);  </Code>
    <Justification>The code does not check the return values of ldap_connect, ldap_bind, and ldap_search functions. If any of these functions fail, the subsequent code might operate on an invalid resource, leading to unexpected behavior or errors.</Justification>
  </Issue>
  <Issue>
    <Type>Security</Type>
    <Weakness>CWE-798</Weakness>
    <Description>Use of Hard-coded Credentials</Description>
    <Severity>Critical</Severity>
    <File>File 1</File>
    <Code>$ds=ldap_connect(""localhost""); 
$r=ldap_bind($ds);</Code>
    <Justification>The code snippet uses ldap_bind without specifying username and password, this will result in anonymous bind. In case the LDAP server does not allow anonymous bind, the code will fail. If the code is changed to use username and password, it could be considered as hardcoded credentials.</Justification>
  </Issue>
</Issues>
```"
CWE-78,src/CWE_78__POST__func_FILTER-CLEANING-special_chars_filter__ls-interpretation_simple_quote.php,"<?php







$tainted = $_POST['UserData'];

$sanitized = filter_var($tainted, FILTER_SANITIZE_SPECIAL_CHARS);
  $tainted = $sanitized ;
      

$query = ""ls ' $tainted '"";


$ret = system($query);


?>",$ret = system($query);,True,True,"$tainted = $_POST['UserData'];

$sanitized = filter_var($tainted, FILTER_SANITIZE_SPECIAL_CHARS);
  $tainted = $sanitized ;
      

$query = ""ls ' $tainted '"";


$ret = system($query);","```xml
<Issues>
  <Issue>
    <Type>Security</Type>
    <Weakness>CWE-78</Weakness>
    <Description>Improper Neutralization of Special Elements used in an OS Command ('OS Command Injection')</Description>
    <Severity>High</Severity>
    <File>File 1</File>
    <Code>$tainted = $_POST['UserData'];

$sanitized = filter_var($tainted, FILTER_SANITIZE_SPECIAL_CHARS);
  $tainted = $sanitized ;
      

$query = ""ls ' $tainted '"";


$ret = system($query);</Code>
    <Justification>The code is vulnerable to OS Command Injection. Even though the input is sanitized using FILTER_SANITIZE_SPECIAL_CHARS, it is not sufficient to prevent command injection in all cases. The sanitized input is directly embedded into a system command without proper escaping. An attacker could still inject malicious commands by using characters that are not filtered by the sanitization function, or by exploiting the way the shell interprets the input.</Justification>
  </Issue>
</Issues>
```"
CWE-91,src/CWE_91__object-Array__func_FILTER-CLEANING-full_special_chars_filter__username_text-concatenation_simple_quote.php,"<?php







class Input{
  private $input;

  public function getInput(){
    return $this->input[1];
  }

  public  function __construct(){
    $this->input = array();
    $this->input[0]= 'safe' ;
    $this->input[1]= $_GET['UserData'] ;
    $this->input[2]= 'safe' ;
  }
}
$temp = new Input();
$tainted =  $temp->getInput();

$sanitized = filter_var($tainted, FILTER_SANITIZE_FULL_SPECIAL_CHARS);
  $tainted = $sanitized ;
     

$query = ""


$xml = simplexml_load_file(""users.xml"");
echo ""query : "". $query .""<br /><br />"" ;

$res=$xml->xpath($query);
print_r($res);
echo ""<br />"" ;

?>","$xml = simplexml_load_file(""users.xml"");",False,False,,"```xml
<Issues>
  <Issue>
    <Type>Security</Type>
    <Weakness>CWE-643</Weakness>
    <Description>Improper Neutralization of Data within XPath Expressions ('XPath Injection')</Description>
    <Severity>High</Severity>
    <File>File 1</File>
    <Code>
$query = ""


$xml = simplexml_load_file(""users.xml"");
echo ""query : "". $query .""&lt;br /&gt;&lt;br /&gt;"" ;

$res=$xml->xpath($query);</Code>
    <Justification>The code constructs an XPath query using unsanitized user input ($query). This allows an attacker to inject malicious XPath expressions, potentially leading to information disclosure or denial of service.</Justification>
  </Issue>
  <Issue>
    <Type>Security</Type>
    <Weakness>CWE-79</Weakness>
    <Description>Improper Neutralization of Input During Web Page Generation ('Cross-site Scripting')</Description>
    <Severity>Medium</Severity>
    <File>File 1</File>
    <Code>  public function getInput(){
    return $this->input[1];
  }

  public  function __construct(){
    $this->input = array();
    $this->input[0]= 'safe' ;
    $this->input[1]= $_GET['UserData'] ;</Code>
    <Justification>The code retrieves user input from $_GET['UserData'] and stores it in the input array. While the code uses filter_var with FILTER_SANITIZE_FULL_SPECIAL_CHARS, the input is echoed later in the code. If the filter is not applied properly or if additional contexts require different escaping, the application may be vulnerable to XSS.</Justification>
  </Issue>
  <Issue>
    <Type>Security</Type>
    <Weakness>CWE-611</Weakness>
    <Description>Improper Restriction of XML External Entity Reference ('XXE')</Description>
    <Severity>Medium</Severity>
    <File>File 1</File>
    <Code>
$query = ""


$xml = simplexml_load_file(""users.xml"");
echo ""query : "". $query .""&lt;br /&gt;&lt;br /&gt;"" ;

$res=$xml->xpath($query);</Code>
    <Justification>The code uses simplexml_load_file() to parse the XML file. If the XML file contains external entity references, it could lead to an XXE vulnerability if external entities are not disabled. XXE can lead to information disclosure, denial of service, or server-side request forgery.</Justification>
  </Issue>
</Issues>
```"
CWE-90,src/CWE_90__object-Array__func_addslashes__userByCN-concatenation_simple_quote.php,"<?php







class Input{
  private $input;

  public function getInput(){
    return $this->input[1];
  }

  public  function __construct(){
    $this->input = array();
    $this->input[0]= 'safe' ;
    $this->input[1]= $_GET['UserData'] ;
    $this->input[2]= 'safe' ;
  }
}
$temp = new Input();
$tainted =  $temp->getInput();

$tainted = addslashes($tainted);

$query = ""(&(objectCategory=person)(objectClass=user)(cn='"". $tainted . ""'))"";


$ds=ldap_connect(""localhost""); 
$r=ldap_bind($ds);
$sr=ldap_search($ds,""o=My Company, c=US"", $query);  
ldap_close($ds);

?>","$ds=ldap_connect(""localhost"");",True,False,$this->input[1]= $_GET['UserData'] ;,"```xml
<Issues>
  <Issue>
    <Type>Security</Type>
    <Weakness>CWE-90</Weakness>
    <Description>Improper Neutralization of Special Elements used in an LDAP Query ('LDAP Injection')</Description>
    <Severity>High</Severity>
    <File>File 1</File>
    <Code>$this->input[1]= $_GET['UserData'] ;</Code>
    <Justification>The code retrieves user input from the $_GET['UserData'] parameter and uses it to construct an LDAP query without proper sanitization. This can lead to LDAP injection vulnerabilities.</Justification>
  </Issue>
  <Issue>
    <Type>Security</Type>
    <Weakness>CWE-90</Weakness>
    <Description>Improper Neutralization of Special Elements used in an LDAP Query ('LDAP Injection')</Description>
    <Severity>High</Severity>
    <File>File 1</File>
    <Code>$tainted = addslashes($tainted);

$query = ""(&(objectCategory=person)(objectClass=user)(cn='"". $tainted . ""'))"";


$ds=ldap_connect(""localhost"");</Code>
    <Justification>The code attempts to sanitize the user input with addslashes(), which is not sufficient to prevent LDAP injection. addslashes() only escapes single quotes, double quotes, backslashes and NULL characters, but LDAP injection requires escaping other characters as well.</Justification>
  </Issue>
  <Issue>
    <Type>Reliability</Type>
    <Weakness>CWE-252</Weakness>
    <Description>Unchecked Return Value</Description>
    <Severity>Medium</Severity>
    <File>File 1</File>
    <Code>$r=ldap_bind($ds);
$sr=ldap_search($ds,""o=My Company, c=US"", $query);  
ldap_close($ds);</Code>
    <Justification>The code does not check the return values of ldap_bind() and ldap_search(). If these functions fail, they will return FALSE, and the script will continue to execute, potentially leading to unexpected behavior or security vulnerabilities.</Justification>
  </Issue>
  <Issue>
    <Type>Security</Type>
    <Weakness>CWE-252</Weakness>
    <Description>Unchecked Return Value</Description>
    <Severity>Medium</Severity>
    <File>File 1</File>
    <Code>$r=ldap_bind($ds);
$sr=ldap_search($ds,""o=My Company, c=US"", $query);  
ldap_close($ds);</Code>
    <Justification>The code does not check the return values of ldap_bind() and ldap_search(). If these functions fail, they will return FALSE, and the script will continue to execute, potentially leading to unexpected behavior or security vulnerabilities.</Justification>
  </Issue>
</Issues>
```"
CWE-79,src/CWE_79__object-classicGet__func_rawurlencode__Unsafe_use_untrusted_data-tag_Name.php,"<!-- 
Unsafe sample
input : get the field userData from the variable $_GET via an object
SANITIZE : use of rawurlencode
File : unsafe, use of untrusted data in an tag name
-->

<!--Copyright 2015 Bertrand STIVALET 

Permission is hereby granted, without written agreement or royalty fee, to

use, copy, modify, and distribute this software and its documentation for

any purpose, provided that the above copyright notice and the following

three paragraphs appear in all copies of this software.


IN NO EVENT SHALL AUTHORS BE LIABLE TO ANY PARTY FOR DIRECT,

INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES ARISING OUT OF THE 

USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF AUTHORS HAVE

BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.


AUTHORS SPECIFICALLY DISCLAIM ANY WARRANTIES INCLUDING, BUT NOT

LIMITED TO THE IMPLIED WARRANTIES OF MERCHANTABILITY, FITNESS FOR A

PARTICULAR PURPOSE, AND NON-INFRINGEMENT.


THE SOFTWARE IS PROVIDED ON AN ""AS-IS"" BASIS AND AUTHORS HAVE NO

OBLIGATION TO PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR

MODIFICATIONS.-->


<!DOCTYPE html>
<html>
<head/>
<body>
<?php
class Input{
  private $input;

  public function getInput(){
    return $this->input;
  }

  public  function __construct(){
   $this->input = $_GET['UserData'] ;
  }
}
$temp = new Input();
$tainted =  $temp->getInput();

$tainted = rawurlencode($tainted);


echo ""<"".  $tainted ."" href= \""/bob\"" />"" ;
?>
<h1>Hello World!</h1>
</body>
</html>","echo ""<"".  $tainted ."" href= \""/bob\"" />"" ;",True,True,"echo ""<"".  $tainted ."" href= \""/bob\"" />"" ;","```xml
<Issues>
  <Issue>
    <Type>Security</Type>
    <Weakness>CWE-79</Weakness>
    <Description>Improper Neutralization of Input During Web Page Generation ('Cross-site Scripting')</Description>
    <Severity>Medium</Severity>
    <File>File 1</File>
    <Code>echo ""&lt;"".  $tainted ."" href= \""/bob\"" /&gt;"" ;</Code>
    <Justification>The code uses user-controlled input ($tainted) as a tag name in HTML output. While rawurlencode is used, it doesn't prevent all XSS attacks. A malicious user could still inject valid HTML tag names or attributes, leading to XSS.</Justification>
  </Issue>
</Issues>
```"
CWE-79,src/CWE_79__object-indexArray__func_preg_replace__Unsafe_use_untrusted_data-tag_Name.php,"<!-- 
Unsafe sample
input : get the field userData from the variable $_GET via an object, which store it in a array
SANITIZE : use of preg_replace
File : unsafe, use of untrusted data in an tag name
-->

<!--Copyright 2015 Bertrand STIVALET 

Permission is hereby granted, without written agreement or royalty fee, to

use, copy, modify, and distribute this software and its documentation for

any purpose, provided that the above copyright notice and the following

three paragraphs appear in all copies of this software.


IN NO EVENT SHALL AUTHORS BE LIABLE TO ANY PARTY FOR DIRECT,

INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES ARISING OUT OF THE 

USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF AUTHORS HAVE

BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.


AUTHORS SPECIFICALLY DISCLAIM ANY WARRANTIES INCLUDING, BUT NOT

LIMITED TO THE IMPLIED WARRANTIES OF MERCHANTABILITY, FITNESS FOR A

PARTICULAR PURPOSE, AND NON-INFRINGEMENT.


THE SOFTWARE IS PROVIDED ON AN ""AS-IS"" BASIS AND AUTHORS HAVE NO

OBLIGATION TO PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR

MODIFICATIONS.-->


<!DOCTYPE html>
<html>
<head/>
<body>
<?php
class Input{
  private $input;

  public function getInput(){
    return $this->input['realOne'];
  }

  public  function __construct(){
    $this->input = array();
    $this->input['test']= 'safe' ;
    $this->input['realOne']= $_GET['UserData'] ;
    $this->input['trap']= 'safe' ;
  }
}
$temp = new Input();
$tainted =  $temp->getInput();

$tainted = preg_replace('/\'/', '', $tainted);


echo ""<"".  $tainted ."" href= \""/bob\"" />"" ;
?>
<h1>Hello World!</h1>
</body>
</html>","echo ""<"".  $tainted ."" href= \""/bob\"" />"" ;",True,True,"$tainted =  $temp->getInput();

$tainted = preg_replace('/\'/', '', $tainted);


echo ""<"".  $tainted ."" href= \""/bob\"" />"" ;","```xml
<Issues>
  <Issue>
    <Type>Security</Type>
    <Weakness>CWE-79</Weakness>
    <Description>Improper Neutralization of Input During Web Page Generation ('Cross-site Scripting')</Description>
    <Severity>Medium</Severity>
    <File>File 1</File>
    <Code>$tainted =  $temp->getInput();

$tainted = preg_replace('/\'/', '', $tainted);


echo ""&lt;"".  $tainted ."" href= \""/bob\"" /&gt;"" ;</Code>
    <Justification>The code retrieves user input from $_GET['UserData'], stores it in an object, and then uses this input as an HTML tag name after attempting to sanitize it with preg_replace. While preg_replace removes single quotes, it does not neutralize other potentially malicious HTML or JavaScript code. If the user provides input like ""img src=x onerror=alert(1)"", the resulting HTML will execute the JavaScript, leading to a Cross-Site Scripting (XSS) vulnerability. The vulnerability exists because the sanitization is insufficient to neutralize all potentially harmful characters or sequences that could be used to inject malicious code into the HTML output.</Justification>
  </Issue>
</Issues>
```"
CWE-90,src/CWE_90__POST__func_htmlentities__name-sprintf_%s_simple_quote.php,"<?php







$tainted = $_POST['UserData'];

$tainted = htmlentities($tainted, ENT_QUOTES);

$query = sprintf(""name='%s'"", $tainted);


$ds=ldap_connect(""localhost""); 
$r=ldap_bind($ds);
$sr=ldap_search($ds,""o=My Company, c=US"", $query);  
ldap_close($ds);

?>","$ds=ldap_connect(""localhost"");",True,True,"$tainted = $_POST['UserData'];

$tainted = htmlentities($tainted, ENT_QUOTES);

$query = sprintf(""name='%s'"", $tainted);


$ds=ldap_connect(""localhost""); 
$r=ldap_bind($ds);
$sr=ldap_search($ds,""o=My Company, c=US"", $query);  
ldap_close($ds);","```xml
<Issues>
  <Issue>
    <Type>Security</Type>
    <Weakness>CWE-90</Weakness>
    <Description>Improper Neutralization of Special Elements used in an LDAP Query ('LDAP Injection')</Description>
    <Severity>High</Severity>
    <File>File 1</File>
    <Code>$tainted = $_POST['UserData'];

$tainted = htmlentities($tainted, ENT_QUOTES);

$query = sprintf(""name='%s'"", $tainted);


$ds=ldap_connect(""localhost""); 
$r=ldap_bind($ds);
$sr=ldap_search($ds,""o=My Company, c=US"", $query);  
ldap_close($ds);</Code>
    <Justification>The code takes user-controlled data from $_POST['UserData'] and incorporates it into an LDAP query without proper sanitization. While htmlentities is used, it's insufficient to prevent LDAP injection. An attacker could inject malicious LDAP syntax, potentially bypassing authentication or extracting sensitive information from the LDAP server. The sprintf function is used to build the query string, which means that the entire query is being constructed using tainted data.</Justification>
  </Issue>
</Issues>
```"
CWE-78,src/CWE_78__SESSION__func_FILTER-CLEANING-special_chars_filter__ls-concatenation_simple_quote.php,"<?php







$tainted = $_SESSION['UserData'];

$sanitized = filter_var($tainted, FILTER_SANITIZE_SPECIAL_CHARS);
  $tainted = $sanitized ;
      

$query = ""ls '"". $tainted . ""'"";


$ret = system($query);


?>",$ret = system($query);,True,True,"$tainted = $_SESSION['UserData'];

$sanitized = filter_var($tainted, FILTER_SANITIZE_SPECIAL_CHARS);
  $tainted = $sanitized ;
      

$query = ""ls '"". $tainted . ""'"";


$ret = system($query);","```xml
<Issues>
  <Issue>
    <Type>Security</Type>
    <Weakness>CWE-78</Weakness>
    <Description>Improper Neutralization of Special Elements used in a Command ('Command Injection')</Description>
    <Severity>High</Severity>
    <File>File 1</File>
    <Code>$tainted = $_SESSION['UserData'];

$sanitized = filter_var($tainted, FILTER_SANITIZE_SPECIAL_CHARS);
  $tainted = $sanitized ;
      

$query = ""ls '"". $tainted . ""'"";


$ret = system($query);</Code>
    <Justification>The code uses user-controlled data from $_SESSION['UserData'] to construct a command that is executed by the system() function. Even though filter_var with FILTER_SANITIZE_SPECIAL_CHARS is used, it might not be sufficient to prevent command injection, depending on the context and the allowed characters in the system command.  The single quotes around the tainted data in the query do not prevent command injection. If the sanitized input contains a single quote, it can break out of the quoted string and inject arbitrary commands.</Justification>
  </Issue>
</Issues>
```"
CWE-91,src/CWE_91__unserialize__func_FILTER-VALIDATION-email_filter__username_text-sprintf_%s_simple_quote.php,"<?php







$string = $_POST['UserData'] ;
$tainted = unserialize($string);
    

if (filter_var($sanitized, FILTER_VALIDATE_EMAIL))
  $tainted = $sanitized ;
else
  $tainted = """" ;

$query = sprintf(""


$xml = simplexml_load_file(""users.xml"");
echo ""query : "". $query .""<br /><br />"" ;

$res=$xml->xpath($query);
print_r($res);
echo ""<br />"" ;

?>","$xml = simplexml_load_file(""users.xml"");",False,False,,"```xml
<Issues>
  <Issue>
    <Type>Security</Type>
    <Weakness>CWE-502</Weakness>
    <Description>Deserialization of Untrusted Data</Description>
    <Severity>Critical</Severity>
    <File>File 1</File>
    <Code>$string = $_POST['UserData'] ;
$tainted = unserialize($string);</Code>
    <Justification>The code uses unserialize() on user-supplied data ($_POST['UserData']). This is extremely dangerous as it allows for arbitrary code execution if the serialized data is maliciously crafted.</Justification>
  </Issue>
  <Issue>
    <Type>Security</Type>
    <Weakness>CWE-643</Weakness>
    <Description>Improper Neutralization of Data within XPath Expressions ('XPath Injection')</Description>
    <Severity>High</Severity>
    <File>File 1</File>
    <Code>$query = sprintf(""</Code>
    <Justification>The code constructs an XPath query using sprintf(), but it's unclear what the format string is and what data is being inserted into it. If user-controlled data is being inserted without proper sanitization, it could lead to XPath injection.</Justification>
  </Issue>
  <Issue>
    <Type>Security</Type>
    <Weakness>CWE-22</Weakness>
    <Description>Improper Limitation of a Pathname to a Restricted Directory ('Path Traversal')</Description>
    <Severity>Medium</Severity>
    <File>File 1</File>
    <Code>$xml = simplexml_load_file(""users.xml"");</Code>
    <Justification>The code uses a hardcoded path ""users.xml"". If the application intends to load user-specified files, this becomes a path traversal vulnerability.</Justification>
  </Issue>
  <Issue>
    <Type>Reliability</Type>
    <Weakness>CWE-252</Weakness>
    <Description>Unchecked Return Value</Description>
    <Severity>Low</Severity>
    <File>File 1</File>
    <Code>$xml = simplexml_load_file(""users.xml"");</Code>
    <Justification>The code does not check the return value of simplexml_load_file(). If the file fails to load (e.g., due to permissions, file not found, or invalid XML), $xml will be false, and later operations on $xml will cause errors.</Justification>
  </Issue>
</Issues>
```"
CWE-90,src/CWE_90__system__func_preg_replace__not_name-concatenation_simple_quote.php,"<?php







$tainted = system('ls', $retval);

$tainted = preg_replace('/\'/', '', $tainted);

$query = ""!name='"". $tainted . ""'"";


$ds=ldap_connect(""localhost""); 
$r=ldap_bind($ds);
$sr=ldap_search($ds,""o=My Company, c=US"", $query);  
ldap_close($ds);

?>","$ds=ldap_connect(""localhost"");",True,True,"$tainted = system('ls', $retval);

$tainted = preg_replace('/\'/', '', $tainted);

$query = ""!name='"". $tainted . ""'"";


$ds=ldap_connect(""localhost""); 
$r=ldap_bind($ds);
$sr=ldap_search($ds,""o=My Company, c=US"", $query);  
ldap_close($ds);","```xml
<Issues>
  <Issue>
    <Type>Security</Type>
    <Weakness>CWE-77</Weakness>
    <Description>Improper Neutralization of Special Elements used in a Command ('Command Injection')</Description>
    <Severity>High</Severity>
    <File>File 1</File>
    <Code>$tainted = system('ls', $retval);</Code>
    <Justification>The code uses the system() function, which executes an external command. While the command itself ('ls') is hardcoded, there is no sanitization of the input. This can lead to command injection vulnerabilities if the context in which this code is executed allows for any form of external influence or unexpected behavior of the 'ls' command.</Justification>
  </Issue>
  <Issue>
    <Type>Security</Type>
    <Weakness>CWE-90</Weakness>
    <Description>Improper Neutralization of Special Elements used in an LDAP Query ('LDAP Injection')</Description>
    <Severity>High</Severity>
    <File>File 1</File>
    <Code>$tainted = system('ls', $retval);

$tainted = preg_replace('/\'/', '', $tainted);

$query = ""!name='"". $tainted . ""'"";


$ds=ldap_connect(""localhost""); 
$r=ldap_bind($ds);
$sr=ldap_search($ds,""o=My Company, c=US"", $query);  
ldap_close($ds);</Code>
    <Justification>The code constructs an LDAP query by concatenating a tainted variable $tainted into the query string. Even though the code attempts to remove single quotes using preg_replace, this is insufficient to prevent LDAP injection attacks, as other special characters or encoding techniques can be used to bypass this rudimentary sanitization. An attacker could manipulate the $tainted variable (which is indirectly influenced by the system command) to inject arbitrary LDAP syntax, potentially allowing them to bypass authentication, retrieve sensitive information, or modify the LDAP directory.</Justification>
  </Issue>
  <Issue>
    <Type>Security</Type>
    <Weakness>CWE-252</Weakness>
    <Description>Unchecked Return Value</Description>
    <Severity>Low</Severity>
    <File>File 1</File>
    <Code>$ds=ldap_connect(""localhost""); 
$r=ldap_bind($ds);
$sr=ldap_search($ds,""o=My Company, c=US"", $query);  
ldap_close($ds);</Code>
    <Justification>The code does not check the return values of ldap_connect, ldap_bind and ldap_search. Failure to check these return values can lead to unexpected behavior, including denial of service or security vulnerabilities, if these functions fail.</Justification>
  </Issue>
  <Issue>
    <Type>Reliability</Type>
    <Weakness>CWE-252</Weakness>
    <Description>Unchecked Return Value</Description>
    <Severity>Medium</Severity>
    <File>File 1</File>
    <Code>$ds=ldap_connect(""localhost""); 
$r=ldap_bind($ds);
$sr=ldap_search($ds,""o=My Company, c=US"", $query);  
ldap_close($ds);</Code>
    <Justification>The code does not check the return values of ldap_connect, ldap_bind and ldap_search. If ldap_connect fails, $ds will be false, and subsequent calls to ldap_bind, ldap_search and ldap_close will result in errors, potentially causing the application to crash or behave unpredictably. Similarly, if ldap_bind or ldap_search fail, the application should handle the error appropriately, rather than continuing with potentially invalid data.</Justification>
  </Issue>
  <Issue>
    <Type>Performance Efficiency</Type>
    <Weakness>CWE-1050</Weakness>
    <Description>Excessive Platform Resource Consumption within a Loop</Description>
    <Severity>Low</Severity>
    <File>File 1</File>
    <Code>$ds=ldap_connect(""localhost""); 
$r=ldap_bind($ds);
$sr=ldap_search($ds,""o=My Company, c=US"", $query);  
ldap_close($ds);</Code>
    <Justification>Although there is no explicit loop, if the context of this code involves multiple calls to this block (e.g., within a web request handling multiple entries), repeatedly connecting and disconnecting to the LDAP server ($ds=ldap_connect and ldap_close) is inefficient. Connection pooling or persistent connections should be considered to reduce overhead.</Justification>
  </Issue>
</Issues>
```"
CWE-79,src/CWE_79__shell_exec__func_htmlentities__Use_untrusted_data_propertyValue_CSS-double_Quoted_Property_Value.php,"<!-- 
Unsafe sample
input : use shell_exec to cat /tmp/tainted.txt
sanitize : use of the function htmlentities. Sanitizes the query but has a high chance to produce unexpected results
File : use of untrusted data in a double quoted property value (CSS)
-->

<!--Copyright 2015 Bertrand STIVALET 

Permission is hereby granted, without written agreement or royalty fee, to

use, copy, modify, and distribute this software and its documentation for

any purpose, provided that the above copyright notice and the following

three paragraphs appear in all copies of this software.


IN NO EVENT SHALL AUTHORS BE LIABLE TO ANY PARTY FOR DIRECT,

INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES ARISING OUT OF THE 

USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF AUTHORS HAVE

BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.


AUTHORS SPECIFICALLY DISCLAIM ANY WARRANTIES INCLUDING, BUT NOT

LIMITED TO THE IMPLIED WARRANTIES OF MERCHANTABILITY, FITNESS FOR A

PARTICULAR PURPOSE, AND NON-INFRINGEMENT.


THE SOFTWARE IS PROVIDED ON AN ""AS-IS"" BASIS AND AUTHORS HAVE NO

OBLIGATION TO PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR

MODIFICATIONS.-->


<!DOCTYPE html>
<html>
<head>
<style>
<?php
$tainted = shell_exec('cat /tmp/tainted.txt');

$tainted = htmlentities($tainted, ENT_QUOTES);


echo ""body { color :\"""". $tainted .""\"" ; }"" ;
?>
</style> 
</head>
<body>
<h1>Hello World!</h1>
</body>
</html>","echo ""body { color :\"""". $tainted .""\"" ; }"" ;",True,True,"$tainted = htmlentities($tainted, ENT_QUOTES);


echo ""body { color :\"""". $tainted .""\"" ; }"" ;","```xml
<Issues>
  <Issue>
    <Type>Security</Type>
    <Weakness>CWE-78</Weakness>
    <Description>Improper Neutralization of Special Elements used in a Command ('Command Injection')</Description>
    <Severity>High</Severity>
    <File>File 1</File>
    <Code>$tainted = shell_exec('cat /tmp/tainted.txt');</Code>
    <Justification>The code uses shell_exec to execute a command. If the file /tmp/tainted.txt is controlled by a malicious user, they can inject arbitrary commands into the shell.</Justification>
  </Issue>
  <Issue>
    <Type>Security</Type>
    <Weakness>CWE-79</Weakness>
    <Description>Improper Neutralization of Input During Web Page Generation ('Cross-site Scripting')</Description>
    <Severity>Medium</Severity>
    <File>File 1</File>
    <Code>$tainted = htmlentities($tainted, ENT_QUOTES);


echo ""body { color :\"""". $tainted .""\"" ; }"" ;</Code>
    <Justification>The code uses htmlentities to sanitize the input, but it's being used in a CSS context within double quotes. While htmlentities can prevent HTML injection, it might not be sufficient to prevent CSS injection, especially if the injected string contains characters that are interpreted specially in CSS, leading to potential style manipulation or information disclosure.</Justification>
  </Issue>
</Issues>
```"
CWE-90,src/CWE_90__fopen__func_preg_match-no_filtering__userByMail-sprintf_%s_simple_quote.php,"<?php







$handle = @fopen(""/tmp/tainted.txt"", ""r"");

if ($handle) {
  if(($tainted = fgets($handle, 4096)) == false) {
    $tainted = """";
  }
  fclose($handle);
} else {
  $tainted = """";
}

$re = ""/^.*$/"";
if(preg_match($re, $tainted) == 1){
  $tainted = $tainted;
}
else{
  $tainted = """";
}

$query = sprintf(""(&(objectCategory=person)(objectClass=user)(mail='%s'))"", $tainted);


$ds=ldap_connect(""localhost""); 
$r=ldap_bind($ds);
$sr=ldap_search($ds,""o=My Company, c=US"", $query);  
ldap_close($ds);

?>","$ds=ldap_connect(""localhost"");",True,False,"$query = sprintf(""(&(objectCategory=person)(objectClass=user)(mail='%s'))"", $tainted);","```xml
<Issues>
  <Issue>
    <Type>Security</Type>
    <Weakness>CWE-90</Weakness>
    <Description>Improper Neutralization of Special Elements used in an LDAP Query ('LDAP Injection')</Description>
    <Severity>High</Severity>
    <File>File 1</File>
    <Code>$query = sprintf(""(&(objectCategory=person)(objectClass=user)(mail='%s'))"", $tainted);</Code>
    <Justification>The code uses sprintf to construct an LDAP query, directly embedding the $tainted variable without proper sanitization. This allows an attacker to inject arbitrary LDAP code, potentially bypassing authentication or retrieving sensitive information.</Justification>
  </Issue>
  <Issue>
    <Type>Reliability</Type>
    <Weakness>CWE-252</Weakness>
    <Description>Unchecked Return Value</Description>
    <Severity>Medium</Severity>
    <File>File 1</File>
    <Code>$handle = @fopen(""/tmp/tainted.txt"", ""r"");</Code>
    <Justification>The code uses the @ error suppression operator when opening the file. This prevents error messages from being displayed, but the return value of fopen is not checked. If fopen fails (e.g., due to permissions or file not existing), $handle will be false, and subsequent operations will lead to errors.</Justification>
  </Issue>
  <Issue>
    <Type>Reliability</Type>
    <Weakness>CWE-252</Weakness>
    <Description>Unchecked Return Value</Description>
    <Severity>Medium</Severity>
    <File>File 1</File>
    <Code>  if(($tainted = fgets($handle, 4096)) == false) {</Code>
    <Justification>The code checks if fgets returns false, indicating an error or end-of-file. However, fgets can also return an empty string if it reads nothing from the file, which is not explicitly handled, potentially leading to unexpected behavior later in the code.</Justification>
  </Issue>
  <Issue>
    <Type>Reliability</Type>
    <Weakness>CWE-252</Weakness>
    <Description>Unchecked Return Value</Description>
    <Severity>Medium</Severity>
    <File>File 1</File>
    <Code>$r=ldap_bind($ds);</Code>
    <Justification>The code does not check the return value of ldap_bind. A failure during the bind operation can lead to subsequent operations failing or returning incorrect results. Checking the return value allows for proper error handling.</Justification>
  </Issue>
  <Issue>
    <Type>Reliability</Type>
    <Weakness>CWE-252</Weakness>
    <Description>Unchecked Return Value</Description>
    <Severity>Medium</Severity>
    <File>File 1</File>
    <Code>$sr=ldap_search($ds,""o=My Company, c=US"", $query);</Code>
    <Justification>The code does not check the return value of ldap_search. A failure during the search operation can lead to the program continuing with potentially invalid or incomplete data. Checking the return value allows for proper error handling and prevents the use of potentially invalid search results.</Justification>
  </Issue>
  <Issue>
    <Type>Security</Type>
    <Weakness>CWE-798</Weakness>
    <Description>Use of Hard-coded Credentials</Description>
    <Severity>High</Severity>
    <File>File 1</File>
    <Code>$ds=ldap_connect(""localhost"");
$r=ldap_bind($ds);</Code>
    <Justification>The code connects to the LDAP server without specifying any credentials for the bind operation. While not explicitly hardcoded, it implicitly relies on anonymous access or a default configuration. If the LDAP server requires authentication, this will fail. If anonymous access is enabled, this could lead to unauthorized access, depending on the privileges granted to anonymous users.</Justification>
  </Issue>
  <Issue>
    <Type>Security</Type>
    <Weakness>CWE-22</Weakness>
    <Description>Improper Limitation of a Pathname to a Restricted Directory ('Path Traversal')</Description>
    <Severity>Medium</Severity>
    <File>File 1</File>
    <Code>$handle = @fopen(""/tmp/tainted.txt"", ""r"");</Code>
    <Justification>The code opens a file with a fixed path ""/tmp/tainted.txt"". Although the path is fixed and not directly influenced by user input, it is still reading data from an external source (the file). If the application's security relies on the contents of this file being trustworthy and the file is writable by other users, it could be compromised. The application is implicitly trusting that the /tmp directory and the file are properly secured.</Justification>
  </Issue>
  <Issue>
    <Type>Maintainability</Type>
    <Weakness>CWE-571</Weakness>
    <Description>Expression is Always True</Description>
    <Severity>Low</Severity>
    <File>File 1</File>
    <Code>if(preg_match($re, $tainted) == 1){
  $tainted = $tainted;
}
else{
  $tainted = """";
}</Code>
    <Justification>The regular expression ""/^.*$/"" will always match any string, including an empty string. Thus, the if condition will always be true, and the else block will never be executed. This makes the else block and the assignment $tainted = """"; redundant and unnecessary, reducing code maintainability.</Justification>
  </Issue>
</Issues>
```"
CWE-91,src/CWE_91__object-Array__func_FILTER-CLEANING-special_chars_filter__username_text-sprintf_%s_simple_quote.php,"<?php







class Input{
  private $input;

  public function getInput(){
    return $this->input[1];
  }

  public  function __construct(){
    $this->input = array();
    $this->input[0]= 'safe' ;
    $this->input[1]= $_GET['UserData'] ;
    $this->input[2]= 'safe' ;
  }
}
$temp = new Input();
$tainted =  $temp->getInput();

$sanitized = filter_var($tainted, FILTER_SANITIZE_SPECIAL_CHARS);
  $tainted = $sanitized ;
      

$query = sprintf(""


$xml = simplexml_load_file(""users.xml"");
echo ""query : "". $query .""<br /><br />"" ;

$res=$xml->xpath($query);
print_r($res);
echo ""<br />"" ;

?>","$xml = simplexml_load_file(""users.xml"");",False,False,,"```xml
<Issues>
  <Issue>
    <Type>Security</Type>
    <Weakness>CWE-643</Weakness>
    <Description>Improper Neutralization of Data within XPath Expressions ('XPath Injection')</Description>
    <Severity>High</Severity>
    <File>File 1</File>
    <Code>$query = sprintf(""


$xml = simplexml_load_file(""users.xml"");
echo ""query : "". $query .""&lt;br /&gt;&lt;br /&gt;"" ;

$res=$xml->xpath($query);</Code>
    <Justification>The code constructs an XPath query using user-controlled input ($tainted) without proper neutralization. Although the input is sanitized with FILTER_SANITIZE_SPECIAL_CHARS, this is insufficient to prevent XPath injection attacks. An attacker could still manipulate the query to extract sensitive information or cause denial of service by crafting a malicious XPath expression.</Justification>
  </Issue>
  <Issue>
    <Type>Reliability</Type>
    <Weakness>CWE-252</Weakness>
    <Description>Unchecked Return Value</Description>
    <Severity>Low</Severity>
    <File>File 1</File>
    <Code>$xml = simplexml_load_file(""users.xml"");
echo ""query : "". $query .""&lt;br /&gt;&lt;br /&gt;"" ;

$res=$xml->xpath($query);</Code>
    <Justification>The code doesn't check the return value of simplexml_load_file(). If the file does not exist or is malformed, the function will return FALSE but the code will continue using the $xml variable, potentially leading to errors or unexpected behavior.</Justification>
  </Issue>
  <Issue>
    <Type>Security</Type>
    <Weakness>CWE-434</Weakness>
    <Description>Unrestricted Upload of File with Dangerous Type</Description>
    <Severity>Low</Severity>
    <File>File 1</File>
    <Code>$xml = simplexml_load_file(""users.xml"");</Code>
    <Justification>The code uses simplexml_load_file(""users.xml""), which can be vulnerable if the ""users.xml"" file is an external file. An attacker could replace the legitimate ""users.xml"" file with a malicious XML file, potentially leading to code execution or other security breaches when the file is parsed.</Justification>
  </Issue>
  <Issue>
    <Type>Security</Type>
    <Weakness>CWE-798</Weakness>
    <Description>Use of Hard-coded Credentials</Description>
    <Severity>Low</Severity>
    <File>File 1</File>
    <Code>$xml = simplexml_load_file(""users.xml"");</Code>
    <Justification>The code uses a hard-coded filename ""users.xml"". While not directly credentials, it can be considered a resource identifier. If the application relies on the integrity of this file and an attacker can modify or replace it, this becomes a security issue.</Justification>
  </Issue>
</Issues>
```"
CWE-89,src/CWE_89__proc_open__no_sanitizing__select_from_where-interpretation.php,"<?php







$descriptorspec = array(
  0 => array(""pipe"", ""r""),
  1 => array(""pipe"", ""w""),
  2 => array(""file"", ""/tmp/error-output.txt"", ""a"")
  );
$cwd = '/tmp';
$process = proc_open('more /tmp/tainted.txt', $descriptorspec, $pipes, $cwd, NULL);
if (is_resource($process)) {
  fclose($pipes[0]);
  $tainted = stream_get_contents($pipes[1]);
  fclose($pipes[1]);
  $return_value = proc_close($process);
}



$query = ""SELECT * FROM student where id= $tainted "";


$conn = mysql_connect('localhost', 'mysql_user', 'mysql_password'); 
mysql_select_db('dbname') ;
echo ""query : "". $query .""<br /><br />"" ;

$res = mysql_query($query); 

while($data =mysql_fetch_array($res)){
print_r($data) ;
echo ""<br />"" ;
} 
mysql_close($conn);

?>","$conn = mysql_connect('localhost', 'mysql_user', 'mysql_password'); ",True,False,"$query = ""SELECT * FROM student where id= $tainted "";","```xml
<Issues>
  <Issue>
    <Type>Security</Type>
    <Weakness>CWE-89</Weakness>
    <Description>Improper Neutralization of Special Elements used in an SQL Command ('SQL Injection')</Description>
    <Severity>Critical</Severity>
    <File>File 1</File>
    <Code>$query = ""SELECT * FROM student where id= $tainted "";</Code>
    <Justification>The code directly embeds the `$tainted` variable, which is derived from an external source (/tmp/tainted.txt), into a SQL query without proper sanitization. This allows for SQL injection attacks.</Justification>
  </Issue>
  <Issue>
    <Type>Security</Type>
    <Weakness>CWE-477</Weakness>
    <Description>Use of Obsolete Function</Description>
    <Severity>Medium</Severity>
    <File>File 1</File>
    <Code>$conn = mysql_connect('localhost', 'mysql_user', 'mysql_password'); 
mysql_select_db('dbname') ;
echo ""query : "". $query .""&lt;br /&gt;&lt;br /&gt;"" ;

$res = mysql_query($query); </Code>
    <Justification>The `mysql_connect` and `mysql_query` functions are deprecated and should not be used.  They are vulnerable to security issues and are no longer maintained.</Justification>
  </Issue>
  <Issue>
    <Type>Reliability</Type>
    <Weakness>CWE-252</Weakness>
    <Description>Unchecked Return Value</Description>
    <Severity>Medium</Severity>
    <File>File 1</File>
    <Code>$conn = mysql_connect('localhost', 'mysql_user', 'mysql_password'); 
mysql_select_db('dbname') ;
echo ""query : "". $query .""&lt;br /&gt;&lt;br /&gt;"" ;

$res = mysql_query($query); </Code>
    <Justification>The code does not check the return values of `mysql_connect` and `mysql_query`. If these functions fail, the script will continue to execute, potentially leading to errors or unexpected behavior.</Justification>
  </Issue>
  <Issue>
    <Type>Security</Type>
    <Weakness>CWE-798</Weakness>
    <Description>Use of Hard-coded Credentials</Description>
    <Severity>Critical</Severity>
    <File>File 1</File>
    <Code>$conn = mysql_connect('localhost', 'mysql_user', 'mysql_password'); </Code>
    <Justification>The code contains hard-coded database credentials (`mysql_user`, `mysql_password`). This is a security risk, as anyone with access to the code can gain access to the database.</Justification>
  </Issue>
  <Issue>
    <Type>Reliability</Type>
    <Weakness>CWE-772</Weakness>
    <Description>Missing Release of Resource after Effective Lifetime</Description>
    <Severity>Medium</Severity>
    <File>File 1</File>
    <Code>while($data =mysql_fetch_array($res)){
print_r($data) ;
echo ""&lt;br /&gt;"" ;
} 
mysql_close($conn);</Code>
    <Justification>The code uses `mysql_close($conn)` to close the database connection. However, if an error occurs before this line is reached (e.g., during the `mysql_query` or `mysql_fetch_array` calls), the connection might not be closed, leading to resource exhaustion.</Justification>
  </Issue>
</Issues>
```"
CWE-90,src/CWE_90__backticks__func_addslashes__userByMail-concatenation_simple_quote.php,"<?php







$tainted = `cat /tmp/tainted.txt`;

$tainted = addslashes($tainted);

$query = ""(&(objectCategory=person)(objectClass=user)(mail='"". $tainted . ""'))"";


$ds=ldap_connect(""localhost""); 
$r=ldap_bind($ds);
$sr=ldap_search($ds,""o=My Company, c=US"", $query);  
ldap_close($ds);

?>","$ds=ldap_connect(""localhost"");",True,True,"$tainted = `cat /tmp/tainted.txt`;

$tainted = addslashes($tainted);

$query = ""(&(objectCategory=person)(objectClass=user)(mail='"". $tainted . ""'))"";","```xml
<Issues>
  <Issue>
    <Type>Security</Type>
    <Weakness>CWE-90</Weakness>
    <Description>Improper Neutralization of Special Elements used in an LDAP Query ('LDAP Injection')</Description>
    <Severity>High</Severity>
    <File>File 1</File>
    <Code>$tainted = `cat /tmp/tainted.txt`;

$tainted = addslashes($tainted);

$query = ""(&(objectCategory=person)(objectClass=user)(mail='"". $tainted . ""'))"";</Code>
    <Justification>The code constructs an LDAP query by directly embedding user-controlled input ($tainted) into the query string. Although addslashes() is used, it's insufficient to prevent LDAP injection.  LDAP injection can allow attackers to bypass authentication, extract sensitive information, or modify the LDAP directory.  The input from `cat /tmp/tainted.txt` is considered external and untrusted.</Justification>
  </Issue>
  <Issue>
    <Type>Security</Type>
    <Weakness>CWE-77</Weakness>
    <Description>Improper Neutralization of Special Elements used in a Command ('Command Injection')</Description>
    <Severity>High</Severity>
    <File>File 1</File>
    <Code>$tainted = `cat /tmp/tainted.txt`;</Code>
    <Justification>The code uses backticks to execute the command `cat /tmp/tainted.txt`. This is equivalent to using `shell_exec()` and is vulnerable to command injection if the filename `/tmp/tainted.txt` is derived from user input or an otherwise untrusted source. An attacker could potentially inject arbitrary commands into the filename.</Justification>
  </Issue>
</Issues>
```"
CWE-79,src/CWE_79__popen__func_preg_replace__Use_untrusted_data-body.php,"<!-- 
Unsafe sample
input : Uses popen to read the file /tmp/tainted.txt using cat command
SANITIZE : use of preg_replace
File : use of untrusted data in the body
-->

<!--Copyright 2015 Bertrand STIVALET 

Permission is hereby granted, without written agreement or royalty fee, to

use, copy, modify, and distribute this software and its documentation for

any purpose, provided that the above copyright notice and the following

three paragraphs appear in all copies of this software.


IN NO EVENT SHALL AUTHORS BE LIABLE TO ANY PARTY FOR DIRECT,

INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES ARISING OUT OF THE 

USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF AUTHORS HAVE

BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.


AUTHORS SPECIFICALLY DISCLAIM ANY WARRANTIES INCLUDING, BUT NOT

LIMITED TO THE IMPLIED WARRANTIES OF MERCHANTABILITY, FITNESS FOR A

PARTICULAR PURPOSE, AND NON-INFRINGEMENT.


THE SOFTWARE IS PROVIDED ON AN ""AS-IS"" BASIS AND AUTHORS HAVE NO

OBLIGATION TO PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR

MODIFICATIONS.-->


<!DOCTYPE html>
<html>
<head/>
<body>
<?php
$handle = popen('/bin/cat /tmp/tainted.txt', 'r');
$tainted = fread($handle, 4096);
pclose($handle);

$tainted = preg_replace('/\'/', '', $tainted);


echo $tainted ;
?>
<h1>Hello World!</h1>
</body>
</html>
",echo $tainted ;,True,True,echo $tainted ;,"```xml
<Issues>
  <Issue>
    <Type>Security</Type>
    <Weakness>CWE-79</Weakness>
    <Description>Improper Neutralization of Input During Web Page Generation ('Cross-site Scripting')</Description>
    <Severity>Medium</Severity>
    <File>File 1</File>
    <Code>echo $tainted ;</Code>
    <Justification>The code echoes the variable $tainted directly to the output without proper encoding. If $tainted contains HTML or JavaScript, it will be executed in the user's browser, leading to a cross-site scripting (XSS) vulnerability. Although the code uses preg_replace to remove single quotes, this is not sufficient to prevent XSS.</Justification>
  </Issue>
  <Issue>
    <Type>Security</Type>
    <Weakness>CWE-78</Weakness>
    <Description>Improper Neutralization of Special Elements used in an OS Command ('OS Command Injection')</Description>
    <Severity>High</Severity>
    <File>File 1</File>
    <Code>$handle = popen('/bin/cat /tmp/tainted.txt', 'r');</Code>
    <Justification>The code uses popen to execute a command. While the command itself is hardcoded, if the system is configured in a way that allows an attacker to modify /tmp/tainted.txt, they could inject malicious commands into that file, which would then be executed by the popen call. This is an OS command injection vulnerability.</Justification>
  </Issue>
  <Issue>
    <Type>Reliability</Type>
    <Weakness>CWE-252</Weakness>
    <Description>Unchecked Return Value</Description>
    <Severity>Low</Severity>
    <File>File 1</File>
    <Code>$handle = popen('/bin/cat /tmp/tainted.txt', 'r');
$tainted = fread($handle, 4096);
pclose($handle);</Code>
    <Justification>The code does not check the return values of popen, fread, and pclose. If any of these functions fail, the script will continue to execute, potentially leading to unexpected behavior. For example, if popen fails and returns false, fread will be called on a non-resource, which would cause an error.</Justification>
  </Issue>
</Issues>
```"
CWE-91,src/CWE_91__backticks__func_FILTER-CLEANING-special_chars_filter__username_text-sprintf_%s_simple_quote.php,"<?php







$tainted = `cat /tmp/tainted.txt`;

$sanitized = filter_var($tainted, FILTER_SANITIZE_SPECIAL_CHARS);
  $tainted = $sanitized ;
      

$query = sprintf(""


$xml = simplexml_load_file(""users.xml"");
echo ""query : "". $query .""<br /><br />"" ;

$res=$xml->xpath($query);
print_r($res);
echo ""<br />"" ;

?>","$xml = simplexml_load_file(""users.xml"");",False,False,,"```xml
<Issues>
  <Issue>
    <Type>Security</Type>
    <Weakness>CWE-78</Weakness>
    <Description>Improper Neutralization of Special Elements used in a Command ('Command Injection')</Description>
    <Severity>High</Severity>
    <File>File 1</File>
    <Code>$tainted = `cat /tmp/tainted.txt`;</Code>
    <Justification>The code uses backticks to execute an external command (`cat /tmp/tainted.txt`). This can be vulnerable to command injection if the content of `/tmp/tainted.txt` is influenced by an attacker, allowing them to execute arbitrary commands on the server.</Justification>
  </Issue>
  <Issue>
    <Type>Security</Type>
    <Weakness>CWE-643</Weakness>
    <Description>Improper Neutralization of Data within XPath Expressions ('XPath Injection')</Description>
    <Severity>High</Severity>
    <File>File 1</File>
    <Code>$sanitized = filter_var($tainted, FILTER_SANITIZE_SPECIAL_CHARS);
  $tainted = $sanitized ;
      

$query = sprintf(""
</Code>
    <Justification>The code uses `sprintf` to construct an XPath query. Even after sanitization, the `FILTER_SANITIZE_SPECIAL_CHARS` filter might not be sufficient to prevent XPath injection. An attacker could potentially manipulate the query to extract sensitive data or perform other unauthorized actions.</Justification>
  </Issue>
</Issues>
```"
CWE-89,src/CWE_89__object-indexArray__func_FILTER-CLEANING-special_chars_filter__select_from-concatenation_simple_quote.php,"<?php







class Input{
  private $input;

  public function getInput(){
    return $this->input['realOne'];
  }

  public  function __construct(){
    $this->input = array();
    $this->input['test']= 'safe' ;
    $this->input['realOne']= $_GET['UserData'] ;
    $this->input['trap']= 'safe' ;
  }
}
$temp = new Input();
$tainted =  $temp->getInput();

$sanitized = filter_var($tainted, FILTER_SANITIZE_SPECIAL_CHARS);
  $tainted = $sanitized ;
      

$query = ""SELECT * FROM '"". $tainted . ""'"";


$conn = mysql_connect('localhost', 'mysql_user', 'mysql_password'); 
mysql_select_db('dbname') ;
echo ""query : "". $query .""<br /><br />"" ;

$res = mysql_query($query); 

while($data =mysql_fetch_array($res)){
print_r($data) ;
echo ""<br />"" ;
} 
mysql_close($conn);

?>","$conn = mysql_connect('localhost', 'mysql_user', 'mysql_password'); ",True,False,"$query = ""SELECT * FROM '"". $tainted . ""'"";","```xml
<Issues>
  <Issue>
    <Type>Security</Type>
    <Weakness>CWE-89</Weakness>
    <Description>Improper Neutralization of Special Elements used in an SQL Command ('SQL Injection')</Description>
    <Severity>Critical</Severity>
    <File>File 1</File>
    <Code>$query = ""SELECT * FROM '"". $tainted . ""'"";</Code>
    <Justification>The code constructs an SQL query by directly concatenating user-controlled input ($tainted) into the query string. Even though filter_var with FILTER_SANITIZE_SPECIAL_CHARS is used, it's insufficient to prevent SQL injection because it doesn't properly escape or quote the input for use as a table name.</Justification>
  </Issue>
  <Issue>
    <Type>Security</Type>
    <Weakness>CWE-477</Weakness>
    <Description>Use of Obsolete Function</Description>
    <Severity>High</Severity>
    <File>File 1</File>
    <Code>$conn = mysql_connect('localhost', 'mysql_user', 'mysql_password'); 
mysql_select_db('dbname') ;
echo ""query : "". $query .""&lt;br /&gt;&lt;br /&gt;"" ;

$res = mysql_query($query);</Code>
    <Justification>The code uses the `mysql_connect` and `mysql_query` functions, which are deprecated.  These functions are known to be insecure and should not be used.  The use of these functions also impacts maintainability, as they are no longer supported.</Justification>
  </Issue>
  <Issue>
    <Type>Maintainability</Type>
    <Weakness>CWE-477</Weakness>
    <Description>Use of Obsolete Function</Description>
    <Severity>Medium</Severity>
    <File>File 1</File>
    <Code>$conn = mysql_connect('localhost', 'mysql_user', 'mysql_password'); 
mysql_select_db('dbname') ;
echo ""query : "". $query .""&lt;br /&gt;&lt;br /&gt;"" ;

$res = mysql_query($query);</Code>
    <Justification>The code uses the `mysql_connect` and `mysql_query` functions, which are deprecated.  Using deprecated functions reduces maintainability as they are no longer supported and may be removed in future PHP versions.</Justification>
  </Issue>
</Issues>
```"
CWE-78,src/CWE_78__shell_exec__func_FILTER-CLEANING-special_chars_filter__cat-concatenation_simple_quote.php,"<?php







$tainted = shell_exec('cat /tmp/tainted.txt');

$sanitized = filter_var($tainted, FILTER_SANITIZE_SPECIAL_CHARS);
  $tainted = $sanitized ;
      

$query = ""cat '"". $tainted . ""'"";


$ret = system($query);


?>",$ret = system($query);,True,True,"$query = ""cat '"". $tainted . ""'"";


$ret = system($query);","```xml
<Issues>
  <Issue>
    <Type>Security</Type>
    <Weakness>CWE-78</Weakness>
    <Description>Improper Neutralization of Special Elements used in a Command ('Command Injection')</Description>
    <Severity>High</Severity>
    <File>File 1</File>
    <Code>$query = ""cat '"". $tainted . ""'"";


$ret = system($query);</Code>
    <Justification>The code constructs a shell command using user-controlled input ($tainted) without proper neutralization of special characters. This allows an attacker to inject arbitrary commands into the system call via the $tainted variable. Although the code uses filter_var with FILTER_SANITIZE_SPECIAL_CHARS, this sanitization is insufficient to prevent command injection in all cases, as it may not neutralize all characters that are significant to the shell.</Justification>
  </Issue>
  <Issue>
    <Type>Security</Type>
    <Weakness>CWE-252</Weakness>
    <Description>Unchecked Return Value</Description>
    <Severity>Low</Severity>
    <File>File 1</File>
    <Code>$ret = system($query);</Code>
    <Justification>The code does not check the return value of the system() function. If the command fails to execute, the program will not be aware of the failure, which could lead to unexpected behavior or security vulnerabilities.</Justification>
  </Issue>
</Issues>
```"
CWE-90,src/CWE_90__fopen__func_htmlentities__not_name-concatenation_simple_quote.php,"<?php







$handle = @fopen(""/tmp/tainted.txt"", ""r"");

if ($handle) {
  if(($tainted = fgets($handle, 4096)) == false) {
    $tainted = """";
  }
  fclose($handle);
} else {
  $tainted = """";
}

$tainted = htmlentities($tainted, ENT_QUOTES);

$query = ""!name='"". $tainted . ""'"";


$ds=ldap_connect(""localhost""); 
$r=ldap_bind($ds);
$sr=ldap_search($ds,""o=My Company, c=US"", $query);  
ldap_close($ds);

?>","$ds=ldap_connect(""localhost"");",True,True,"$query = ""!name='"". $tainted . ""'"";\n$ds=ldap_connect(""localhost""); \n$r=ldap_bind($ds);\n$sr=ldap_search($ds,""o=My Company, c=US"", $query);","```xml
<Issues>
  <Issue>
    <Type>Security</Type>
    <Weakness>CWE-90</Weakness>
    <Description>Improper Neutralization of Special Elements used in an LDAP Query ('LDAP Injection')</Description>
    <Severity>High</Severity>
    <File>File 1</File>
    <Code>$query = ""!name='"". $tainted . ""'"";\n$ds=ldap_connect(""localhost""); \n$r=ldap_bind($ds);\n$sr=ldap_search($ds,""o=My Company, c=US"", $query);</Code>
    <Justification>The code constructs an LDAP query by directly concatenating user-controlled input ($tainted) into the query string. Although htmlentities is used, it might not be sufficient to prevent LDAP injection attacks, as certain characters relevant to LDAP syntax may not be properly neutralized. An attacker could manipulate the $tainted variable to inject malicious LDAP code, potentially bypassing authentication, modifying data, or gaining unauthorized access.</Justification>
  </Issue>
  <Issue>
    <Type>Reliability</Type>
    <Weakness>CWE-252</Weakness>
    <Description>Unchecked Return Value</Description>
    <Severity>Medium</Severity>
    <File>File 1</File>
    <Code>$r=ldap_bind($ds);\n$sr=ldap_search($ds,""o=My Company, c=US"", $query);</Code>
    <Justification>The code does not check the return values of ldap_bind() and ldap_search(). If these functions fail, they will return false, and the script will continue to execute, potentially leading to unexpected behavior or incorrect results. The application should check these return values and handle any errors appropriately.</Justification>
  </Issue>
  <Issue>
    <Type>Security</Type>
    <Weakness>CWE-798</Weakness>
    <Description>Use of Hard-coded Credentials</Description>
    <Severity>High</Severity>
    <File>File 1</File>
    <Code>$sr=ldap_search($ds,""o=My Company, c=US"", $query);</Code>
    <Justification>The code uses a hard-coded base DN (""o=My Company, c=US"") for the LDAP search. While not a credential in the traditional sense, this hardcoding limits the flexibility and portability of the application. If the LDAP directory structure changes, the code will need to be modified. It is better to externalize such configuration values.</Justification>
  </Issue>
</Issues>
```"
CWE-90,src/CWE_90__proc_open__func_preg_match-no_filtering__not_name-sprintf_%s_simple_quote.php,"<?php







$descriptorspec = array(
  0 => array(""pipe"", ""r""),
  1 => array(""pipe"", ""w""),
  2 => array(""file"", ""/tmp/error-output.txt"", ""a"")
  );
$cwd = '/tmp';
$process = proc_open('more /tmp/tainted.txt', $descriptorspec, $pipes, $cwd, NULL);
if (is_resource($process)) {
  fclose($pipes[0]);
  $tainted = stream_get_contents($pipes[1]);
  fclose($pipes[1]);
  $return_value = proc_close($process);
}

$re = ""/^.*$/"";
if(preg_match($re, $tainted) == 1){
  $tainted = $tainted;
}
else{
  $tainted = """";
}

$query = sprintf(""!name='%s'"", $tainted);


$ds=ldap_connect(""localhost""); 
$r=ldap_bind($ds);
$sr=ldap_search($ds,""o=My Company, c=US"", $query);  
ldap_close($ds);

?>","$ds=ldap_connect(""localhost"");",True,True,"$query = sprintf(""!name='%s'"", $tainted);


$ds=ldap_connect(""localhost""); 
$r=ldap_bind($ds);
$sr=ldap_search($ds,""o=My Company, c=US"", $query);  
ldap_close($ds);","```xml
<Issues>
  <Issue>
    <Type>Security</Type>
    <Weakness>CWE-90</Weakness>
    <Description>Improper Neutralization of Special Elements used in an LDAP Query ('LDAP Injection')</Description>
    <Severity>High</Severity>
    <File>File 1</File>
    <Code>$query = sprintf(""!name='%s'"", $tainted);


$ds=ldap_connect(""localhost""); 
$r=ldap_bind($ds);
$sr=ldap_search($ds,""o=My Company, c=US"", $query);  
ldap_close($ds);</Code>
    <Justification>The code uses sprintf to construct an LDAP query with user-controlled input ($tainted) without proper sanitization, leading to LDAP injection vulnerability. An attacker could inject malicious LDAP syntax to bypass intended restrictions or retrieve sensitive information.</Justification>
  </Issue>
  <Issue>
    <Type>Security</Type>
    <Weakness>CWE-77</Weakness>
    <Description>Improper Neutralization of Special Elements used in a Command ('Command Injection')</Description>
    <Severity>High</Severity>
    <File>File 1</File>
    <Code>$process = proc_open('more /tmp/tainted.txt', $descriptorspec, $pipes, $cwd, NULL);</Code>
    <Justification>The code executes the 'more' command on a file named 'tainted.txt' located in '/tmp'.  While the command itself isn't directly using user-provided data, if the content of `/tmp/tainted.txt` is influenced by an external source without proper sanitization, it could lead to command injection if 'more' interprets any special characters within that file as commands.</Justification>
  </Issue>
</Issues>
```"
CWE-89,src/CWE_89__unserialize__no_sanitizing__select_from-interpretation_simple_quote.php,"<?php







$string = $_POST['UserData'] ;
$tainted = unserialize($string);
    



$query = ""SELECT * FROM ' $tainted '"";


$conn = mysql_connect('localhost', 'mysql_user', 'mysql_password'); 
mysql_select_db('dbname') ;
echo ""query : "". $query .""<br /><br />"" ;

$res = mysql_query($query); 

while($data =mysql_fetch_array($res)){
print_r($data) ;
echo ""<br />"" ;
} 
mysql_close($conn);

?>","$conn = mysql_connect('localhost', 'mysql_user', 'mysql_password'); ",True,False,"$query = ""SELECT * FROM ' $tainted '"";","```xml
<Issues>
  <Issue>
    <Type>Security</Type>
    <Weakness>CWE-502</Weakness>
    <Description>Deserialization of Untrusted Data</Description>
    <Severity>Critical</Severity>
    <File>File 1</File>
    <Code>$string = $_POST['UserData'] ;
$tainted = unserialize($string);</Code>
    <Justification>The code uses unserialize() on user-supplied data ($_POST['UserData']), which can lead to arbitrary code execution if the serialized data is malicious. This is a critical security vulnerability as it allows an attacker to inject and execute arbitrary code on the server.</Justification>
  </Issue>
  <Issue>
    <Type>Security</Type>
    <Weakness>CWE-89</Weakness>
    <Description>Improper Neutralization of Special Elements used in an SQL Command ('SQL Injection')</Description>
    <Severity>Critical</Severity>
    <File>File 1</File>
    <Code>$query = ""SELECT * FROM ' $tainted '"";</Code>
    <Justification>The code constructs a SQL query by directly embedding the unserialized user input ($tainted) without proper sanitization. This makes the application vulnerable to SQL injection attacks, allowing an attacker to execute arbitrary SQL commands.</Justification>
  </Issue>
  <Issue>
    <Type>Reliability</Type>
    <Weakness>CWE-252</Weakness>
    <Description>Unchecked Return Value</Description>
    <Severity>Medium</Severity>
    <File>File 1</File>
    <Code>$conn = mysql_connect('localhost', 'mysql_user', 'mysql_password'); 
mysql_select_db('dbname') ;</Code>
    <Justification>The code does not check the return value of mysql_connect() and mysql_select_db(). If the connection fails or the database selection fails, the subsequent code will operate on an invalid connection, leading to unpredictable behavior or errors.</Justification>
  </Issue>
  <Issue>
    <Type>Maintainability</Type>
    <Weakness>CWE-477</Weakness>
    <Description>Use of Obsolete Function</Description>
    <Severity>Low</Severity>
    <File>File 1</File>
    <Code>$conn = mysql_connect('localhost', 'mysql_user', 'mysql_password'); 
mysql_select_db('dbname') ;
echo ""query : "". $query .""&lt;br /&gt;&lt;br /&gt;"" ;

$res = mysql_query($query); 

while($data =mysql_fetch_array($res)){
print_r($data) ;
echo ""&lt;br /&gt;"" ;
} 
mysql_close($conn);</Code>
    <Justification>The code uses the mysql_* functions, which are deprecated. Using deprecated functions can lead to compatibility issues in the future and may not receive security updates.</Justification>
  </Issue>
</Issues>
```"
CWE-90,src/CWE_90__fopen__func_FILTER-VALIDATION-email_filter__userByMail-concatenation_simple_quote.php,"<?php







$handle = @fopen(""/tmp/tainted.txt"", ""r"");

if ($handle) {
  if(($tainted = fgets($handle, 4096)) == false) {
    $tainted = """";
  }
  fclose($handle);
} else {
  $tainted = """";
}

if (filter_var($sanitized, FILTER_VALIDATE_EMAIL))
  $tainted = $sanitized ;
else
  $tainted = """" ;

$query = ""(&(objectCategory=person)(objectClass=user)(mail='"". $tainted . ""'))"";


$ds=ldap_connect(""localhost""); 
$r=ldap_bind($ds);
$sr=ldap_search($ds,""o=My Company, c=US"", $query);  
ldap_close($ds);

?>","$ds=ldap_connect(""localhost"");",True,True,"$query = ""(&(objectCategory=person)(objectClass=user)(mail='"". $tainted . ""'))"";


$ds=ldap_connect(""localhost""); 
$r=ldap_bind($ds);
$sr=ldap_search($ds,""o=My Company, c=US"", $query);  
ldap_close($ds);","```xml
<Issues>
  <Issue>
    <Type>Security</Type>
    <Weakness>CWE-90</Weakness>
    <Description>Improper Neutralization of Special Elements used in an LDAP Query ('LDAP Injection')</Description>
    <Severity>High</Severity>
    <File>File 1</File>
    <Code>$query = ""(&(objectCategory=person)(objectClass=user)(mail='"". $tainted . ""'))"";


$ds=ldap_connect(""localhost""); 
$r=ldap_bind($ds);
$sr=ldap_search($ds,""o=My Company, c=US"", $query);  
ldap_close($ds);</Code>
    <Justification>The code constructs an LDAP query by directly concatenating user-controlled input ($tainted) into the query string. This allows an attacker to inject arbitrary LDAP code, potentially bypassing authentication or gaining unauthorized access to sensitive information.</Justification>
  </Issue>
  <Issue>
    <Type>Reliability</Type>
    <Weakness>CWE-252</Weakness>
    <Description>Unchecked Return Value</Description>
    <Severity>Medium</Severity>
    <File>File 1</File>
    <Code>$handle = @fopen(""/tmp/tainted.txt"", ""r"");</Code>
    <Justification>The code uses the @ operator to suppress errors from fopen. While this prevents error messages from being displayed to the user, it also means that the code doesn't check if fopen was successful. If fopen fails, $handle will be false, and later code that uses $handle will cause errors.</Justification>
  </Issue>
  <Issue>
    <Type>Reliability</Type>
    <Weakness>CWE-252</Weakness>
    <Description>Unchecked Return Value</Description>
    <Severity>Medium</Severity>
    <File>File 1</File>
    <Code>$r=ldap_bind($ds);</Code>
    <Justification>The code does not check the return value of ldap_bind. If ldap_bind fails, the script will continue to execute, potentially leading to errors or unexpected behavior.</Justification>
  </Issue>
  <Issue>
    <Type>Reliability</Type>
    <Weakness>CWE-252</Weakness>
    <Description>Unchecked Return Value</Description>
    <Severity>Medium</Severity>
    <File>File 1</File>
    <Code>$sr=ldap_search($ds,""o=My Company, c=US"", $query);  </Code>
    <Justification>The code does not check the return value of ldap_search. If ldap_search fails, the script will continue to execute, potentially leading to errors or unexpected behavior.</Justification>
  </Issue>
  <Issue>
    <Type>Reliability</Type>
    <Weakness>CWE-391</Weakness>
    <Description>Unchecked Error Condition</Description>
    <Severity>Medium</Severity>
    <File>File 1</File>
    <Code>if(($tainted = fgets($handle, 4096)) == false) {
    $tainted = """";
  }</Code>
    <Justification>fgets can return false on error, but the code only checks if the return value is false. It does not distinguish between an error and reaching the end of the file, leading to potential issues if an error occurs during file reading.</Justification>
  </Issue>
</Issues>
```"
CWE-90,src/CWE_90__GET__func_preg_match-no_filtering__not_name-interpretation_simple_quote.php,"<?php







$tainted = $_GET['UserData'];

$re = ""/^.*$/"";
if(preg_match($re, $tainted) == 1){
  $tainted = $tainted;
}
else{
  $tainted = """";
}

$query = ""!name=' $tainted '"";


$ds=ldap_connect(""localhost""); 
$r=ldap_bind($ds);
$sr=ldap_search($ds,""o=My Company, c=US"", $query);  
ldap_close($ds);

?>","$ds=ldap_connect(""localhost"");",True,True,"$tainted = $_GET['UserData'];

$re = ""/^.*$/"";
if(preg_match($re, $tainted) == 1){
  $tainted = $tainted;
}
else{
  $tainted = """";
}

$query = ""!name=' $tainted '"";","```xml
<Issues>
  <Issue>
    <Type>Security</Type>
    <Weakness>CWE-90</Weakness>
    <Description>Improper Neutralization of Special Elements used in an LDAP Query ('LDAP Injection')</Description>
    <Severity>High</Severity>
    <File>File 1</File>
    <Code>$tainted = $_GET['UserData'];

$re = ""/^.*$/"";
if(preg_match($re, $tainted) == 1){
  $tainted = $tainted;
}
else{
  $tainted = """";
}

$query = ""!name=' $tainted '"";</Code>
    <Justification>The code is vulnerable to LDAP injection. The $tainted variable, which comes directly from user input ($_GET['UserData']), is concatenated into an LDAP query without proper sanitization. Although there is a regex to validate the input, it allows any character, so it does not prevent LDAP injection. An attacker could manipulate the query by injecting special characters or LDAP syntax, potentially gaining unauthorized access or modifying data.</Justification>
  </Issue>
</Issues>
```"
CWE-79,src/CWE_79__fopen__whitelist_using_array__Use_untrusted_data_script-doublequoted_String.php,"<!-- 
Unsafe sample
input : use fopen to read /tmp/tainted.txt and put the first line in $tainted
SANITIZE : use in_array to check if $tainted is in the white list
File : use of untrusted data in a double quoted string in a script
-->

<!--Copyright 2015 Bertrand STIVALET 

Permission is hereby granted, without written agreement or royalty fee, to

use, copy, modify, and distribute this software and its documentation for

any purpose, provided that the above copyright notice and the following

three paragraphs appear in all copies of this software.


IN NO EVENT SHALL AUTHORS BE LIABLE TO ANY PARTY FOR DIRECT,

INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES ARISING OUT OF THE 

USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF AUTHORS HAVE

BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.


AUTHORS SPECIFICALLY DISCLAIM ANY WARRANTIES INCLUDING, BUT NOT

LIMITED TO THE IMPLIED WARRANTIES OF MERCHANTABILITY, FITNESS FOR A

PARTICULAR PURPOSE, AND NON-INFRINGEMENT.


THE SOFTWARE IS PROVIDED ON AN ""AS-IS"" BASIS AND AUTHORS HAVE NO

OBLIGATION TO PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR

MODIFICATIONS.-->


<!DOCTYPE html>
<html>
<head>
<script>
<?php
$handle = @fopen(""/tmp/tainted.txt"", ""r"");

if ($handle) {
  if(($tainted = fgets($handle, 4096)) == false) {
    $tainted = """";
  }
  fclose($handle);
} else {
  $tainted = """";
}

$legal_table = array(""safe1"", ""safe2"");
if (in_array($tainted, $legal_table, true)) {
  $tainted = $tainted;
} else {
  $tainted = $legal_table[0];
}


echo ""alert(\"""". $tainted .""\"")"" ;
?>
</script>
</head>
<body>
<h1>Hello World!</h1>
</body>
</html>","echo ""alert(\"""". $tainted .""\"")"" ;",True,True,"echo ""alert(\"""". $tainted .""\"")"" ;","```xml
<Issues>
  <Issue>
    <Type>Security</Type>
    <Weakness>CWE-79</Weakness>
    <Description>Improper Neutralization of Input During Web Page Generation ('Cross-site Scripting')</Description>
    <Severity>Medium</Severity>
    <File>File 1</File>
    <Code>echo ""alert(\"""". $tainted .""\"")"" ;</Code>
    <Justification>The code echoes user-controlled input ($tainted) directly into a JavaScript alert within a double-quoted string. Even though the input is sanitized against a whitelist, a crafted string in the whitelist could still contain characters that, when interpreted in the JavaScript context, could lead to cross-site scripting (XSS). For example, a string like ""safe1\""); alert('XSS');//"" would bypass the whitelist and inject arbitrary JavaScript code. The proper way to neutralize the output is to use output encoding.</Justification>
  </Issue>
</Issues>
```"
CWE-91,src/CWE_91__proc_open__func_preg_match-no_filtering__username_text-sprintf_%s_simple_quote.php,"<?php







$descriptorspec = array(
  0 => array(""pipe"", ""r""),
  1 => array(""pipe"", ""w""),
  2 => array(""file"", ""/tmp/error-output.txt"", ""a"")
  );
$cwd = '/tmp';
$process = proc_open('more /tmp/tainted.txt', $descriptorspec, $pipes, $cwd, NULL);
if (is_resource($process)) {
  fclose($pipes[0]);
  $tainted = stream_get_contents($pipes[1]);
  fclose($pipes[1]);
  $return_value = proc_close($process);
}

$re = ""/^.*$/"";
if(preg_match($re, $tainted) == 1){
  $tainted = $tainted;
}
else{
  $tainted = """";
}

$query = sprintf(""


$xml = simplexml_load_file(""users.xml"");
echo ""query : "". $query .""<br /><br />"" ;

$res=$xml->xpath($query);
print_r($res);
echo ""<br />"" ;

?>","$xml = simplexml_load_file(""users.xml"");",False,False,,"```xml
<Issues>
  <Issue>
    <Type>Security</Type>
    <Weakness>CWE-78</Weakness>
    <Description>Improper Neutralization of Special Elements used in a Command ('Command Injection')</Description>
    <Severity>High</Severity>
    <File>File 1</File>
    <Code>$process = proc_open('more /tmp/tainted.txt', $descriptorspec, $pipes, $cwd, NULL);</Code>
    <Justification>The code uses proc_open with a hardcoded command 'more /tmp/tainted.txt'. While the command itself is not directly influenced by user input in this snippet, the vulnerability arises if /tmp/tainted.txt contains attacker-controlled data. An attacker could inject shell commands into the file, leading to command execution when 'more' processes it.</Justification>
  </Issue>
  <Issue>
    <Type>Security</Type>
    <Weakness>CWE-643</Weakness>
    <Description>Improper Neutralization of Data within XPath Expressions ('XPath Injection')</Description>
    <Severity>High</Severity>
    <File>File 1</File>
    <Code>$query = sprintf(""
//users/user[username/text()='%s']"",
  $tainted
);</Code>
    <Justification>The code constructs an XPath query using sprintf to embed the value of $tainted. If $tainted contains malicious XPath syntax, it can modify the intended query and potentially expose sensitive data or even allow for denial of service. This constitutes an XPath injection vulnerability.</Justification>
  </Issue>
  <Issue>
    <Type>Security</Type>
    <Weakness>CWE-502</Weakness>
    <Description>Deserialization of Untrusted Data</Description>
    <Severity>High</Severity>
    <File>File 1</File>
    <Code>$xml = simplexml_load_file(""users.xml"");</Code>
    <Justification>The code loads a XML file without validation of the content. If the content of ""users.xml"" file is controlled by an attacker, they can inject malicious XML entities or structures that, upon parsing, can lead to code execution or denial-of-service.</Justification>
  </Issue>
  <Issue>
    <Type>Reliability</Type>
    <Weakness>CWE-252</Weakness>
    <Description>Unchecked Return Value</Description>
    <Severity>Medium</Severity>
    <File>File 1</File>
    <Code>if(preg_match($re, $tainted) == 1){
  $tainted = $tainted;
}
else{
  $tainted = """";
}</Code>
    <Justification>The code checks if preg_match returns 1, but doesn't handle the case where it returns 0 (no match) or FALSE (error). If preg_match fails, it could indicate a problem with the regular expression or input, which the code doesn't address, potentially leading to unexpected behavior.</Justification>
  </Issue>
</Issues>
```"
CWE-79,src/CWE_79__system__no_sanitizing__Use_untrusted_data_script-side_Quoted_Expr.php,"<!-- 
Unsafe sample
input : execute a ls command using the function system, and put the last result in $tainted
sanitize : none
File : use of untrusted data in one side of a quoted expression in a script
-->

<!--Copyright 2015 Bertrand STIVALET 

Permission is hereby granted, without written agreement or royalty fee, to

use, copy, modify, and distribute this software and its documentation for

any purpose, provided that the above copyright notice and the following

three paragraphs appear in all copies of this software.


IN NO EVENT SHALL AUTHORS BE LIABLE TO ANY PARTY FOR DIRECT,

INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES ARISING OUT OF THE 

USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF AUTHORS HAVE

BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.


AUTHORS SPECIFICALLY DISCLAIM ANY WARRANTIES INCLUDING, BUT NOT

LIMITED TO THE IMPLIED WARRANTIES OF MERCHANTABILITY, FITNESS FOR A

PARTICULAR PURPOSE, AND NON-INFRINGEMENT.


THE SOFTWARE IS PROVIDED ON AN ""AS-IS"" BASIS AND AUTHORS HAVE NO

OBLIGATION TO PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR

MODIFICATIONS.-->


<!DOCTYPE html>
<html>
<head>
<script>
<?php
$tainted = system('ls', $retval);




echo ""x='"". $tainted .""'"" ;
?>
</script>
</head>
<body>
<h1>Hello World!</h1>
</body>
</html>","echo ""x='"". $tainted .""'"" ;",True,True,"echo ""x='"". $tainted .""'"" ;","```xml
<Issues>
  <Issue>
    <Type>Security</Type>
    <Weakness>CWE-77</Weakness>
    <Description>Improper Neutralization of Special Elements used in a Command ('Command Injection')</Description>
    <Severity>High</Severity>
    <File>File 1</File>
    <Code>$tainted = system('ls', $retval);</Code>
    <Justification>The code uses the `system()` function to execute an OS command ('ls'). While the output of this command isn't directly used to construct another command, the `system()` function itself can be dangerous if the command being executed comes from an untrusted source. In this example, even though 'ls' is a fixed command, there's no guarantee about the environment in which it's executed. An attacker could potentially manipulate the environment to influence the behavior of 'ls' or even replace it with a malicious executable.</Justification>
  </Issue>
  <Issue>
    <Type>Security</Type>
    <Weakness>CWE-79</Weakness>
    <Description>Improper Neutralization of Input During Web Page Generation ('Cross-site Scripting')</Description>
    <Severity>Medium</Severity>
    <File>File 1</File>
    <Code>echo ""x='"". $tainted .""'"" ;</Code>
    <Justification>The code echoes the output of the system command `$tainted` directly into a Javascript variable without proper sanitization. The output of `ls` could contain characters that, when interpreted as Javascript, could lead to cross-site scripting (XSS) vulnerabilities. Even though the system command is 'ls', the filenames could contain malicious characters.</Justification>
  </Issue>
</Issues>
```"
CWE-79,src/CWE_79__POST__func_FILTER-CLEANING-magic_quotes_filter__Unsafe_use_untrusted_data-attribute_Name.php,"<!-- 
Unsafe sample
input : get the field UserData from the variable $_POST
Uses a magic_quotes_filter via filter_var function
File : unsafe, use of untrusted data in an attribute name
-->

<!--Copyright 2015 Bertrand STIVALET 

Permission is hereby granted, without written agreement or royalty fee, to

use, copy, modify, and distribute this software and its documentation for

any purpose, provided that the above copyright notice and the following

three paragraphs appear in all copies of this software.


IN NO EVENT SHALL AUTHORS BE LIABLE TO ANY PARTY FOR DIRECT,

INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES ARISING OUT OF THE 

USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF AUTHORS HAVE

BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.


AUTHORS SPECIFICALLY DISCLAIM ANY WARRANTIES INCLUDING, BUT NOT

LIMITED TO THE IMPLIED WARRANTIES OF MERCHANTABILITY, FITNESS FOR A

PARTICULAR PURPOSE, AND NON-INFRINGEMENT.


THE SOFTWARE IS PROVIDED ON AN ""AS-IS"" BASIS AND AUTHORS HAVE NO

OBLIGATION TO PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR

MODIFICATIONS.-->


<!DOCTYPE html>
<html>
<body>
<?php
$tainted = $_POST['UserData'];

$sanitized = filter_var($tainted, FILTER_SANITIZE_MAGIC_QUOTES);
  $tainted = $sanitized ;
      


echo ""<div "". $tainted .""= bob />"" ;
?>
<h1>Hello World!</h1>
</div>
</body>
</html>","echo ""<div "". $tainted .""= bob />"" ;",True,True,"echo ""<div "". $tainted .""= bob />"" ;","```xml
<Issues>
  <Issue>
    <Type>Security</Type>
    <Weakness>CWE-79</Weakness>
    <Description>Improper Neutralization of Input During Web Page Generation ('Cross-site Scripting')</Description>
    <Severity>High</Severity>
    <File>File 1</File>
    <Code>echo ""&lt;div "". $tainted .""= bob />"" ;</Code>
    <Justification>The code directly uses unsanitized user input ($tainted) to construct an HTML attribute name. This allows an attacker to inject malicious code into the HTML, leading to Cross-Site Scripting (XSS).  Even though magic quotes are applied, these are deprecated and unreliable for preventing XSS.</Justification>
  </Issue>
  <Issue>
    <Type>Security</Type>
    <Weakness>CWE-477</Weakness>
    <Description>Use of Obsolete Function</Description>
    <Severity>Low</Severity>
    <File>File 1</File>
    <Code>$sanitized = filter_var($tainted, FILTER_SANITIZE_MAGIC_QUOTES);</Code>
    <Justification>The code uses FILTER_SANITIZE_MAGIC_QUOTES, which employs magic quotes. Magic quotes are deprecated and provide insufficient protection against vulnerabilities like XSS or SQL injection. Their use indicates that the code may not be actively maintained or reviewed for modern security practices.</Justification>
  </Issue>
</Issues>
```"
CWE-91,src/CWE_91__exec__no_sanitizing__username-sprintf_%s_simple_quote.php,"<?php







$script = ""/tmp/tainted.php"";
exec($script, $result, $return);

$tainted = $result[0];



$query = sprintf(""user[username='%s']"", $tainted);


$xml = simplexml_load_file(""users.xml"");
echo ""query : "". $query .""<br /><br />"" ;

$res=$xml->xpath($query);
print_r($res);
echo ""<br />"" ;

?>","$xml = simplexml_load_file(""users.xml"");",False,False,,"```xml
<Issues>
  <Issue>
    <Type>Security</Type>
    <Weakness>CWE-78</Weakness>
    <Description>Improper Neutralization of Special Elements used in a Command ('Command Injection')</Description>
    <Severity>High</Severity>
    <File>File 1</File>
    <Code>$script = ""/tmp/tainted.php"";
exec($script, $result, $return);</Code>
    <Justification>The script executes an external program without sanitizing the input. This is a command injection vulnerability. An attacker could modify the script path to execute arbitrary commands on the system.</Justification>
  </Issue>
  <Issue>
    <Type>Security</Type>
    <Weakness>CWE-643</Weakness>
    <Description>Improper Neutralization of Data within XPath Expressions ('XPath Injection')</Description>
    <Severity>High</Severity>
    <File>File 1</File>
    <Code>$query = sprintf(""user[username='%s']"", $tainted);


$xml = simplexml_load_file(""users.xml"");
echo ""query : "". $query .""&lt;br /&gt;&lt;br /&gt;"" ;

$res=$xml->xpath($query);</Code>
    <Justification>The code constructs an XPath query using unsanitized input from the `$tainted` variable. This makes the application vulnerable to XPath injection attacks. An attacker could manipulate the input to extract sensitive information or bypass security restrictions.</Justification>
  </Issue>
  <Issue>
    <Type>Reliability</Type>
    <Weakness>CWE-252</Weakness>
    <Description>Unchecked Return Value</Description>
    <Severity>Medium</Severity>
    <File>File 1</File>
    <Code>exec($script, $result, $return);

$tainted = $result[0];</Code>
    <Justification>The code does not check the return value of `exec()`. If the execution fails (e.g., due to permissions or the script not existing), $result[0] will be empty. This can lead to unexpected behavior later, especially if $tainted is used in security-sensitive operations (which it is in this case).</Justification>
  </Issue>
</Issues>
```"
CWE-79,src/CWE_79__object-classicGet__func_urlencode__Unsafe_use_untrusted_data-tag_Name.php,"<!-- 
Unsafe sample
input : get the field userData from the variable $_GET via an object
SANITIZE : use of urlencode
File : unsafe, use of untrusted data in an tag name
-->

<!--Copyright 2015 Bertrand STIVALET 

Permission is hereby granted, without written agreement or royalty fee, to

use, copy, modify, and distribute this software and its documentation for

any purpose, provided that the above copyright notice and the following

three paragraphs appear in all copies of this software.


IN NO EVENT SHALL AUTHORS BE LIABLE TO ANY PARTY FOR DIRECT,

INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES ARISING OUT OF THE 

USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF AUTHORS HAVE

BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.


AUTHORS SPECIFICALLY DISCLAIM ANY WARRANTIES INCLUDING, BUT NOT

LIMITED TO THE IMPLIED WARRANTIES OF MERCHANTABILITY, FITNESS FOR A

PARTICULAR PURPOSE, AND NON-INFRINGEMENT.


THE SOFTWARE IS PROVIDED ON AN ""AS-IS"" BASIS AND AUTHORS HAVE NO

OBLIGATION TO PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR

MODIFICATIONS.-->


<!DOCTYPE html>
<html>
<head/>
<body>
<?php
class Input{
  private $input;

  public function getInput(){
    return $this->input;
  }

  public  function __construct(){
   $this->input = $_GET['UserData'] ;
  }
}
$temp = new Input();
$tainted =  $temp->getInput();

$tainted = urlencode($tainted);


echo ""<"".  $tainted ."" href= \""/bob\"" />"" ;
?>
<h1>Hello World!</h1>
</body>
</html>","echo ""<"".  $tainted ."" href= \""/bob\"" />"" ;",True,True,"$tainted = urlencode($tainted);


echo ""<"".  $tainted ."" href= \""/bob\"" />"" ;
?>
<h1>Hello World!</h1>","```xml
<Issues>
  <Issue>
    <Type>Security</Type>
    <Weakness>CWE-79</Weakness>
    <Description>Improper Neutralization of Input During Web Page Generation ('Cross-site Scripting')</Description>
    <Severity>Medium</Severity>
    <File>File 1</File>
    <Code>
$tainted = urlencode($tainted);


echo ""&lt;"".  $tainted ."" href= \""/bob\"" /&gt;"" ;
?>
&lt;h1&gt;Hello World!&lt;/h1&gt;</Code>
    <Justification>The code uses user-controlled input ($tainted) within an HTML tag name without proper sanitization beyond url encoding. While url encoding can prevent some forms of injection, it is insufficient to prevent XSS in this context.  An attacker could inject arbitrary HTML/script by manipulating the $tainted variable, potentially leading to XSS if the injected string contains valid HTML tag characters or attributes.</Justification>
  </Issue>
</Issues>
```"
CWE-79,src/CWE_79__fopen__func_urlencode__Unsafe_use_untrusted_data-attribute_Name.php,"<!-- 
Unsafe sample
input : use fopen to read /tmp/tainted.txt and put the first line in $tainted
SANITIZE : use of urlencode
File : unsafe, use of untrusted data in an attribute name
-->

<!--Copyright 2015 Bertrand STIVALET 

Permission is hereby granted, without written agreement or royalty fee, to

use, copy, modify, and distribute this software and its documentation for

any purpose, provided that the above copyright notice and the following

three paragraphs appear in all copies of this software.


IN NO EVENT SHALL AUTHORS BE LIABLE TO ANY PARTY FOR DIRECT,

INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES ARISING OUT OF THE 

USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF AUTHORS HAVE

BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.


AUTHORS SPECIFICALLY DISCLAIM ANY WARRANTIES INCLUDING, BUT NOT

LIMITED TO THE IMPLIED WARRANTIES OF MERCHANTABILITY, FITNESS FOR A

PARTICULAR PURPOSE, AND NON-INFRINGEMENT.


THE SOFTWARE IS PROVIDED ON AN ""AS-IS"" BASIS AND AUTHORS HAVE NO

OBLIGATION TO PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR

MODIFICATIONS.-->


<!DOCTYPE html>
<html>
<body>
<?php
$handle = @fopen(""/tmp/tainted.txt"", ""r"");

if ($handle) {
  if(($tainted = fgets($handle, 4096)) == false) {
    $tainted = """";
  }
  fclose($handle);
} else {
  $tainted = """";
}

$tainted = urlencode($tainted);


echo ""<div "". $tainted .""= bob />"" ;
?>
<h1>Hello World!</h1>
</div>
</body>
</html>","echo ""<div "". $tainted .""= bob />"" ;",True,True,"$tainted = urlencode($tainted);


echo ""<div "". $tainted .""= bob />"" ;
?>
<h1>Hello World!</h1>
</div>","```xml
<Issues>
  <Issue>
    <Type>Security</Type>
    <Weakness>CWE-79</Weakness>
    <Description>Improper Neutralization of Input During Web Page Generation ('Cross-site Scripting')</Description>
    <Severity>High</Severity>
    <File>File 1</File>
    <Code>
$tainted = urlencode($tainted);


echo ""&lt;div "". $tainted .""= bob /&gt;"" ;
?>
&lt;h1&gt;Hello World!&lt;/h1&gt;
&lt;/div&gt;</Code>
    <Justification>The code takes tainted data, URL encodes it, and then uses it directly as an attribute name in an HTML div tag. While urlencode can prevent some types of injection, it's insufficient to prevent XSS in this context. An attacker could inject arbitrary HTML attributes, including event handlers like 'onload' or 'onclick', leading to XSS.</Justification>
  </Issue>
</Issues>
```"
CWE-91,src/CWE_91__object-directGet__no_sanitizing__username-concatenation_simple_quote.php,"<?php







class Input{
  public function getInput(){
    return $_GET['UserData'] ;
  }
}

$temp = new Input();
$tainted =  $temp->getInput();



$query = ""user[username='"". $tainted . ""']"";


$xml = simplexml_load_file(""users.xml"");
echo ""query : "". $query .""<br /><br />"" ;

$res=$xml->xpath($query);
print_r($res);
echo ""<br />"" ;

?>","$xml = simplexml_load_file(""users.xml"");",False,False,,"```xml
<Issues>
  <Issue>
    <Type>Security</Type>
    <Weakness>CWE-643</Weakness>
    <Description>Improper Neutralization of Data within XPath Expressions ('XPath Injection')</Description>
    <Severity>High</Severity>
    <File>File 1</File>
    <Code>$query = ""user[username='"". $tainted . ""']"";</Code>
    <Justification>The code constructs an XPath query by directly embedding user-controlled data ($tainted) without proper sanitization. This allows an attacker to inject malicious XPath syntax, potentially leading to the extraction of sensitive data or other unintended operations on the XML document.</Justification>
  </Issue>
</Issues>
```"
CWE-90,src/CWE_90__proc_open__func_preg_replace__userByMail-interpretation_simple_quote.php,"<?php







$descriptorspec = array(
  0 => array(""pipe"", ""r""),
  1 => array(""pipe"", ""w""),
  2 => array(""file"", ""/tmp/error-output.txt"", ""a"")
  );
$cwd = '/tmp';
$process = proc_open('more /tmp/tainted.txt', $descriptorspec, $pipes, $cwd, NULL);
if (is_resource($process)) {
  fclose($pipes[0]);
  $tainted = stream_get_contents($pipes[1]);
  fclose($pipes[1]);
  $return_value = proc_close($process);
}

$tainted = preg_replace('/\'/', '', $tainted);

$query = ""(&(objectCategory=person)(objectClass=user)(mail=' $tainted '))"";


$ds=ldap_connect(""localhost""); 
$r=ldap_bind($ds);
$sr=ldap_search($ds,""o=My Company, c=US"", $query);  
ldap_close($ds);

?>","$ds=ldap_connect(""localhost"");",True,False,"$query = ""(&(objectCategory=person)(objectClass=user)(mail=' $tainted '))"";","```xml
<Issues>
  <Issue>
    <Type>Security</Type>
    <Weakness>CWE-90</Weakness>
    <Description>Improper Neutralization of Special Elements used in an LDAP Query ('LDAP Injection')</Description>
    <Severity>High</Severity>
    <File>File 1</File>
    <Code>$query = ""(&(objectCategory=person)(objectClass=user)(mail=' $tainted '))"";</Code>
    <Justification>The code constructs an LDAP query by directly embedding a variable $tainted into the query string without proper sanitization, which can lead to LDAP injection vulnerabilities. An attacker could manipulate the $tainted variable to inject malicious LDAP code, potentially bypassing authentication or accessing unauthorized data.</Justification>
  </Issue>
  <Issue>
    <Type>Security</Type>
    <Weakness>CWE-77</Weakness>
    <Description>Improper Neutralization of Special Elements used in a Command ('Command Injection')</Description>
    <Severity>High</Severity>
    <File>File 1</File>
    <Code>$process = proc_open('more /tmp/tainted.txt', $descriptorspec, $pipes, $cwd, NULL);</Code>
    <Justification>The code uses proc_open to execute a command ('more /tmp/tainted.txt') with a hardcoded file path. While the command itself is not directly influenced by user input at this point, the reliance on a file named 'tainted.txt' in a potentially shared location (/tmp) could lead to command injection if the contents of 'tainted.txt' are controllable by an attacker. The attacker could inject shell commands into 'tainted.txt' which would then be executed by 'more'.</Justification>
  </Issue>
  <Issue>
    <Type>Security</Type>
    <Weakness>CWE-22</Weakness>
    <Description>Improper Limitation of a Pathname to a Restricted Directory ('Path Traversal')</Description>
    <Severity>Medium</Severity>
    <File>File 1</File>
    <Code>$process = proc_open('more /tmp/tainted.txt', $descriptorspec, $pipes, $cwd, NULL);</Code>
    <Justification>The code uses proc_open to execute the 'more' command on a hardcoded file path '/tmp/tainted.txt'. While not directly vulnerable to user-supplied input, this can become a vulnerability if an attacker can influence the contents or the existence of the file at that location. An attacker could potentially create or modify this file to contain malicious data or act as a symbolic link to another file outside the intended directory, leading to path traversal.</Justification>
  </Issue>
  <Issue>
    <Type>Reliability</Type>
    <Weakness>CWE-252</Weakness>
    <Description>Unchecked Return Value</Description>
    <Severity>Low</Severity>
    <File>File 1</File>
    <Code>$r=ldap_bind($ds);
$sr=ldap_search($ds,""o=My Company, c=US"", $query);</Code>
    <Justification>The code does not check the return values of ldap_bind() and ldap_search(). If these functions fail, the script may continue to execute, leading to unexpected behavior or incorrect results. Checking the return values would allow the script to handle errors gracefully and prevent further execution if a critical operation fails.</Justification>
  </Issue>
</Issues>
```"
CWE-79,src/CWE_79__shell_exec__whitelist_using_array__Use_untrusted_data_script-doublequoted_String.php,"<!-- 
Unsafe sample
input : use shell_exec to cat /tmp/tainted.txt
SANITIZE : use in_array to check if $tainted is in the white list
File : use of untrusted data in a double quoted string in a script
-->

<!--Copyright 2015 Bertrand STIVALET 

Permission is hereby granted, without written agreement or royalty fee, to

use, copy, modify, and distribute this software and its documentation for

any purpose, provided that the above copyright notice and the following

three paragraphs appear in all copies of this software.


IN NO EVENT SHALL AUTHORS BE LIABLE TO ANY PARTY FOR DIRECT,

INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES ARISING OUT OF THE 

USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF AUTHORS HAVE

BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.


AUTHORS SPECIFICALLY DISCLAIM ANY WARRANTIES INCLUDING, BUT NOT

LIMITED TO THE IMPLIED WARRANTIES OF MERCHANTABILITY, FITNESS FOR A

PARTICULAR PURPOSE, AND NON-INFRINGEMENT.


THE SOFTWARE IS PROVIDED ON AN ""AS-IS"" BASIS AND AUTHORS HAVE NO

OBLIGATION TO PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR

MODIFICATIONS.-->


<!DOCTYPE html>
<html>
<head>
<script>
<?php
$tainted = shell_exec('cat /tmp/tainted.txt');

$legal_table = array(""safe1"", ""safe2"");
if (in_array($tainted, $legal_table, true)) {
  $tainted = $tainted;
} else {
  $tainted = $legal_table[0];
}


echo ""alert(\"""". $tainted .""\"")"" ;
?>
</script>
</head>
<body>
<h1>Hello World!</h1>
</body>
</html>","echo ""alert(\"""". $tainted .""\"")"" ;",True,True,"echo ""alert(\"""". $tainted .""\"")"" ;","```xml
<Issues>
  <Issue>
    <Type>Security</Type>
    <Weakness>CWE-79</Weakness>
    <Description>Improper Neutralization of Input During Web Page Generation ('Cross-site Scripting')</Description>
    <Severity>Medium</Severity>
    <File>File 1</File>
    <Code>echo ""alert(\"""". $tainted .""\"")"" ;</Code>
    <Justification>The code outputs the variable $tainted directly into a Javascript alert box without proper sanitization. Although the code uses in_array to check against a whitelist, the check is performed *before* being used in the Javascript context. If the $tainted variable contains Javascript code (e.g., &lt;script&gt;alert(""XSS"")&lt;/script&gt;), it will be executed in the user's browser, leading to a Cross-Site Scripting (XSS) vulnerability.  The double quotes in the echo statement do not provide adequate protection against XSS.</Justification>
  </Issue>
  <Issue>
    <Type>Security</Type>
    <Weakness>CWE-78</Weakness>
    <Description>Improper Neutralization of Special Elements used in an OS Command ('OS Command Injection')</Description>
    <Severity>High</Severity>
    <File>File 1</File>
    <Code>$tainted = shell_exec('cat /tmp/tainted.txt');</Code>
    <Justification>The code uses shell_exec to execute the command 'cat /tmp/tainted.txt'.  If an attacker can control the contents of /tmp/tainted.txt, they can inject arbitrary OS commands into the shell_exec call.  Even though the output of shell_exec is later validated against a whitelist, the command injection vulnerability exists in the initial execution of the shell command.</Justification>
  </Issue>
</Issues>
```"
CWE-89,src/CWE_89__object-directGet__no_sanitizing__select_from_where-interpretation_simple_quote.php,"<?php







class Input{
  public function getInput(){
    return $_GET['UserData'] ;
  }
}

$temp = new Input();
$tainted =  $temp->getInput();



$query = ""SELECT * FROM student where id=' $tainted '"";


$conn = mysql_connect('localhost', 'mysql_user', 'mysql_password'); 
mysql_select_db('dbname') ;
echo ""query : "". $query .""<br /><br />"" ;

$res = mysql_query($query); 

while($data =mysql_fetch_array($res)){
print_r($data) ;
echo ""<br />"" ;
} 
mysql_close($conn);

?>","$conn = mysql_connect('localhost', 'mysql_user', 'mysql_password'); ",True,False,"$query = ""SELECT * FROM student where id=' $tainted '"";","```xml
<Issues>
  <Issue>
    <Type>Security</Type>
    <Weakness>CWE-89</Weakness>
    <Description>Improper Neutralization of Special Elements used in an SQL Command ('SQL Injection')</Description>
    <Severity>High</Severity>
    <File>File 1</File>
    <Code>$query = ""SELECT * FROM student where id=' $tainted '"";</Code>
    <Justification>The code is vulnerable to SQL injection because it directly incorporates user-supplied input ($tainted) into an SQL query without proper sanitization or parameterization. An attacker could manipulate the input to execute arbitrary SQL code, potentially compromising the database.</Justification>
  </Issue>
  <Issue>
    <Type>Security</Type>
    <Weakness>CWE-477</Weakness>
    <Description>Use of Obsolete Function</Description>
    <Severity>Medium</Severity>
    <File>File 1</File>
    <Code>$conn = mysql_connect('localhost', 'mysql_user', 'mysql_password'); 
mysql_select_db('dbname') ;
$res = mysql_query($query); 
mysql_close($conn);</Code>
    <Justification>The code uses the `mysql_connect`, `mysql_select_db`, `mysql_query` and `mysql_close` functions, which are deprecated. These functions are no longer maintained and have known security vulnerabilities. It is recommended to use `mysqli` or `PDO` instead.</Justification>
  </Issue>
</Issues>
```"
CWE-90,src/CWE_90__exec__func_addslashes__userByMail-sprintf_%s_simple_quote.php,"<?php







$script = ""/tmp/tainted.php"";
exec($script, $result, $return);

$tainted = $result[0];

$tainted = addslashes($tainted);

$query = sprintf(""(&(objectCategory=person)(objectClass=user)(mail='%s'))"", $tainted);


$ds=ldap_connect(""localhost""); 
$r=ldap_bind($ds);
$sr=ldap_search($ds,""o=My Company, c=US"", $query);  
ldap_close($ds);

?>","$ds=ldap_connect(""localhost"");",True,True,"$tainted = addslashes($tainted);

$query = sprintf(""(&(objectCategory=person)(objectClass=user)(mail='%s'))"", $tainted);

$sr=ldap_search($ds,""o=My Company, c=US"", $query);","```xml
<Issues>
  <Issue>
    <Type>Security</Type>
    <Weakness>CWE-77</Weakness>
    <Description>Improper Neutralization of Special Elements used in a Command ('Command Injection')</Description>
    <Severity>High</Severity>
    <File>File 1</File>
    <Code>exec($script, $result, $return);</Code>
    <Justification>The code executes an external script specified by the $script variable. If this script's path or content is influenced by user input, it could lead to command injection vulnerabilities, allowing attackers to execute arbitrary commands on the server.</Justification>
  </Issue>
  <Issue>
    <Type>Security</Type>
    <Weakness>CWE-90</Weakness>
    <Description>Improper Neutralization of Special Elements used in an LDAP Query ('LDAP Injection')</Description>
    <Severity>High</Severity>
    <File>File 1</File>
    <Code>$tainted = addslashes($tainted);

$query = sprintf(""(&(objectCategory=person)(objectClass=user)(mail='%s'))"", $tainted);

$sr=ldap_search($ds,""o=My Company, c=US"", $query);</Code>
    <Justification>The code constructs an LDAP query using sprintf with the $tainted variable, which is derived from the output of exec. While addslashes is used, it's insufficient to prevent LDAP injection attacks. Attackers could still manipulate the query to bypass authentication or retrieve sensitive information.</Justification>
  </Issue>
</Issues>
```"
CWE-78,src/CWE_78__unserialize__no_sanitizing__ls-sprintf_%s_simple_quote.php,"<?php







$string = $_POST['UserData'] ;
$tainted = unserialize($string);
    



$query = sprintf(""ls '%s'"", $tainted);


$ret = system($query);


?>",$ret = system($query);,True,True,"$query = sprintf(""ls '%s'"", $tainted);


$ret = system($query);","```xml
<Issues>
  <Issue>
    <Type>Security</Type>
    <Weakness>CWE-78</Weakness>
    <Description>Improper Neutralization of Special Elements used in a Command ('Command Injection')</Description>
    <Severity>High</Severity>
    <File>File 1</File>
    <Code>$query = sprintf(""ls '%s'"", $tainted);


$ret = system($query);</Code>
    <Justification>The code uses sprintf to construct a command and then executes it using system(). The $tainted variable, which comes from user input via $_POST['UserData'] and is processed by unserialize(), is directly inserted into the command string. This is a command injection vulnerability because an attacker could inject arbitrary commands by crafting a malicious string in $_POST['UserData']. The lack of proper sanitization of the $tainted variable allows for the execution of arbitrary commands on the server.</Justification>
  </Issue>
  <Issue>
    <Type>Security</Type>
    <Weakness>CWE-502</Weakness>
    <Description>Deserialization of Untrusted Data</Description>
    <Severity>Critical</Severity>
    <File>File 1</File>
    <Code>$string = $_POST['UserData'] ;
$tainted = unserialize($string);</Code>
    <Justification>The code uses unserialize() on user-provided data from $_POST['UserData']. Deserializing untrusted data can lead to arbitrary code execution because the attacker can control the structure and content of the serialized object. This allows the attacker to instantiate arbitrary classes and execute arbitrary code on the server.</Justification>
  </Issue>
</Issues>
```"
CWE-90,src/CWE_90__object-Array__func_FILTER-CLEANING-magic_quotes_filter__not_name-interpretation_simple_quote.php,"<?php







class Input{
  private $input;

  public function getInput(){
    return $this->input[1];
  }

  public  function __construct(){
    $this->input = array();
    $this->input[0]= 'safe' ;
    $this->input[1]= $_GET['UserData'] ;
    $this->input[2]= 'safe' ;
  }
}
$temp = new Input();
$tainted =  $temp->getInput();

$sanitized = filter_var($tainted, FILTER_SANITIZE_MAGIC_QUOTES);
  $tainted = $sanitized ;
      

$query = ""!name=' $tainted '"";


$ds=ldap_connect(""localhost""); 
$r=ldap_bind($ds);
$sr=ldap_search($ds,""o=My Company, c=US"", $query);  
ldap_close($ds);

?>","$ds=ldap_connect(""localhost"");",True,True,"$this->input[1]= $_GET['UserData'] ;
    $this->input[2]= 'safe' ;
  }
}
$temp = new Input();
$tainted =  $temp->getInput();

$sanitized = filter_var($tainted, FILTER_SANITIZE_MAGIC_QUOTES);
  $tainted = $sanitized ;
      

$query = ""!name=' $tainted '"";","```xml
<Issues>
  <Issue>
    <Type>Security</Type>
    <Weakness>CWE-90</Weakness>
    <Description>Improper Neutralization of Special Elements used in an LDAP Query ('LDAP Injection')</Description>
    <Severity>High</Severity>
    <File>File 1</File>
    <Code>    $this->input[1]= $_GET['UserData'] ;
    $this->input[2]= 'safe' ;
  }
}
$temp = new Input();
$tainted =  $temp->getInput();

$sanitized = filter_var($tainted, FILTER_SANITIZE_MAGIC_QUOTES);
  $tainted = $sanitized ;
      

$query = ""!name=' $tainted '"";</Code>
    <Justification>The code retrieves user input from $_GET['UserData'] without proper validation or sanitization against LDAP injection attacks. Although magic quotes are applied, they are deprecated and insufficient to prevent injection. The user-controlled input is directly incorporated into the LDAP query, potentially allowing an attacker to manipulate the query and retrieve unauthorized information or perform other malicious actions.</Justification>
  </Issue>
  <Issue>
    <Type>Security</Type>
    <Weakness>CWE-477</Weakness>
    <Description>Use of Obsolete Function</Description>
    <Severity>Low</Severity>
    <File>File 1</File>
    <Code>$sanitized = filter_var($tainted, FILTER_SANITIZE_MAGIC_QUOTES);</Code>
    <Justification>The code uses the FILTER_SANITIZE_MAGIC_QUOTES filter, which relies on magic quotes. Magic quotes are deprecated in PHP 5.3.0 and removed in PHP 5.4.0. Using deprecated features can lead to unexpected behavior and potential security vulnerabilities.</Justification>
  </Issue>
</Issues>
```"
CWE-91,src/CWE_91__SESSION__no_sanitizing__username-interpretation_simple_quote.php,"<?php







$tainted = $_SESSION['UserData'];



$query = ""user[username=' $tainted ']"";


$xml = simplexml_load_file(""users.xml"");
echo ""query : "". $query .""<br /><br />"" ;

$res=$xml->xpath($query);
print_r($res);
echo ""<br />"" ;

?>","$xml = simplexml_load_file(""users.xml"");",True,True,"$tainted = $_SESSION['UserData'];

$query = ""user[username=' $tainted ']"";


$xml = simplexml_load_file(""users.xml"");
echo ""query : "". $query .""<br /><br />"" ;

$res=$xml->xpath($query);","```xml
<Issues>
  <Issue>
    <Type>Security</Type>
    <Weakness>CWE-91</Weakness>
    <Description>XML Injection (aka Blind XPath Injection)</Description>
    <Severity>High</Severity>
    <File>File 1</File>
    <Code>$tainted = $_SESSION['UserData'];

$query = ""user[username=' $tainted ']"";


$xml = simplexml_load_file(""users.xml"");
echo ""query : "". $query .""&lt;br /&gt;&lt;br /&gt;"" ;

$res=$xml->xpath($query);</Code>
    <Justification>The code constructs an XPath query using user-controlled input ($tainted) without proper sanitization. This allows an attacker to modify the query's structure, potentially extracting sensitive information or causing a denial of service. Specifically, the $tainted variable coming from $_SESSION['UserData'] is directly embedded into the XPath query string, leading to vulnerability.</Justification>
  </Issue>
  <Issue>
    <Type>Reliability</Type>
    <Weakness>CWE-252</Weakness>
    <Description>Unchecked Return Value</Description>
    <Severity>Low</Severity>
    <File>File 1</File>
    <Code>$xml = simplexml_load_file(""users.xml"");</Code>
    <Justification>The code does not check the return value of simplexml_load_file(). If the file ""users.xml"" does not exist or is malformed, the function will return false, and subsequent operations on $xml will cause an error.</Justification>
  </Issue>
</Issues>
```"
CWE-90,src/CWE_90__unserialize__func_htmlspecialchars__userByCN-concatenation_simple_quote.php,"<?php







$string = $_POST['UserData'] ;
$tainted = unserialize($string);
    

$tainted = htmlspecialchars($tainted, ENT_QUOTES);

$query = ""(&(objectCategory=person)(objectClass=user)(cn='"". $tainted . ""'))"";


$ds=ldap_connect(""localhost""); 
$r=ldap_bind($ds);
$sr=ldap_search($ds,""o=My Company, c=US"", $query);  
ldap_close($ds);

?>","$ds=ldap_connect(""localhost"");",True,True,"$tainted = htmlspecialchars($tainted, ENT_QUOTES);

$query = ""(&(objectCategory=person)(objectClass=user)(cn='"". $tainted . ""'))"";","```xml
<Issues>
  <Issue>
    <Type>Security</Type>
    <Weakness>CWE-502</Weakness>
    <Description>Deserialization of Untrusted Data</Description>
    <Severity>Critical</Severity>
    <File>File 1</File>
    <Code>$string = $_POST['UserData'] ;
$tainted = unserialize($string);</Code>
    <Justification>The code uses unserialize() on user-supplied data ($_POST['UserData']), which can lead to arbitrary code execution if the serialized data is malicious.</Justification>
  </Issue>
  <Issue>
    <Type>Security</Type>
    <Weakness>CWE-90</Weakness>
    <Description>Improper Neutralization of Special Elements used in an LDAP Query ('LDAP Injection')</Description>
    <Severity>High</Severity>
    <File>File 1</File>
    <Code>$tainted = htmlspecialchars($tainted, ENT_QUOTES);

$query = ""(&(objectCategory=person)(objectClass=user)(cn='"". $tainted . ""'))"";</Code>
    <Justification>The code constructs an LDAP query using user-supplied data ($tainted) without proper sanitization. Even after using htmlspecialchars(), the $tainted variable is concatenated directly into the LDAP query string, which can lead to LDAP injection if $tainted contains malicious characters or sequences that are not neutralized by htmlspecialchars() in the context of LDAP.</Justification>
  </Issue>
  <Issue>
    <Type>Reliability</Type>
    <Weakness>CWE-252</Weakness>
    <Description>Unchecked Return Value</Description>
    <Severity>Medium</Severity>
    <File>File 1</File>
    <Code>$ds=ldap_connect(""localhost""); 
$r=ldap_bind($ds);
$sr=ldap_search($ds,""o=My Company, c=US"", $query);  
ldap_close($ds);</Code>
    <Justification>The code does not check the return values of ldap_connect(), ldap_bind(), and ldap_search(). If any of these functions fail, the script will continue to execute, potentially leading to unexpected behavior or security vulnerabilities.  For example, if ldap_connect fails, $ds will be false, and subsequent calls to ldap_bind and ldap_search will cause errors. Similarly, if ldap_bind fails, the search will be performed without proper authentication.</Justification>
  </Issue>
</Issues>
```"
CWE-89,src/CWE_89__shell_exec__func_FILTER-CLEANING-special_chars_filter__select_from-sprintf_%s_simple_quote.php,"<?php







$tainted = shell_exec('cat /tmp/tainted.txt');

$sanitized = filter_var($tainted, FILTER_SANITIZE_SPECIAL_CHARS);
  $tainted = $sanitized ;
      

$query = sprintf(""SELECT * FROM '%s'"", $tainted);


$conn = mysql_connect('localhost', 'mysql_user', 'mysql_password'); 
mysql_select_db('dbname') ;
echo ""query : "". $query .""<br /><br />"" ;

$res = mysql_query($query); 

while($data =mysql_fetch_array($res)){
print_r($data) ;
echo ""<br />"" ;
} 
mysql_close($conn);

?>","$conn = mysql_connect('localhost', 'mysql_user', 'mysql_password'); ",True,False,"$query = sprintf(""SELECT * FROM '%s'"", $tainted);","```xml
<Issues>
  <Issue>
    <Type>Security</Type>
    <Weakness>CWE-89</Weakness>
    <Description>Improper Neutralization of Special Elements used in an SQL Command ('SQL Injection')</Description>
    <Severity>Critical</Severity>
    <File>File 1</File>
    <Code>$query = sprintf(""SELECT * FROM '%s'"", $tainted);</Code>
    <Justification>The code constructs an SQL query using sprintf with user-controlled input ($tainted) without proper sanitization, leading to SQL injection vulnerability. Although filter_var is used, it is then overridden, thus is ineffective.</Justification>
  </Issue>
  <Issue>
    <Type>Security</Type>
    <Weakness>CWE-477</Weakness>
    <Description>Use of Obsolete Function</Description>
    <Severity>Medium</Severity>
    <File>File 1</File>
    <Code>$conn = mysql_connect('localhost', 'mysql_user', 'mysql_password'); 
mysql_select_db('dbname') ;
$res = mysql_query($query); 
mysql_close($conn);</Code>
    <Justification>The code uses the 'mysql_*' functions, which are deprecated and insecure. These functions are vulnerable to SQL injection and other security flaws and are no longer maintained.</Justification>
  </Issue>
  <Issue>
    <Type>Reliability</Type>
    <Weakness>CWE-252</Weakness>
    <Description>Unchecked Return Value</Description>
    <Severity>Medium</Severity>
    <File>File 1</File>
    <Code>$conn = mysql_connect('localhost', 'mysql_user', 'mysql_password'); 
mysql_select_db('dbname') ;
$res = mysql_query($query);</Code>
    <Justification>The code does not check the return values of mysql_connect, mysql_select_db, and mysql_query. If any of these functions fail, the script will continue to execute, potentially leading to unexpected behavior or errors.</Justification>
  </Issue>
  <Issue>
    <Type>Security</Type>
    <Weakness>CWE-798</Weakness>
    <Description>Use of Hard-coded Credentials</Description>
    <Severity>Critical</Severity>
    <File>File 1</File>
    <Code>$conn = mysql_connect('localhost', 'mysql_user', 'mysql_password');</Code>
    <Justification>The code contains hard-coded database credentials ('mysql_user', 'mysql_password'). This is a security risk because if the code is compromised, the database credentials will also be compromised.</Justification>
  </Issue>
</Issues>
```"
CWE-90,src/CWE_90__system__func_pg_escape_string__userByMail-sprintf_%s_simple_quote.php,"<?php







$tainted = system('ls', $retval);

$tainted = pg_escape_string($tainted);

$query = sprintf(""(&(objectCategory=person)(objectClass=user)(mail='%s'))"", $tainted);


$ds=ldap_connect(""localhost""); 
$r=ldap_bind($ds);
$sr=ldap_search($ds,""o=My Company, c=US"", $query);  
ldap_close($ds);

?>","$ds=ldap_connect(""localhost"");",True,True,"$tainted = system('ls', $retval);

$tainted = pg_escape_string($tainted);

$query = sprintf(""(&(objectCategory=person)(objectClass=user)(mail='%s'))"", $tainted);","```xml
<Issues>
  <Issue>
    <Type>Security</Type>
    <Weakness>CWE-77</Weakness>
    <Description>Improper Neutralization of Special Elements used in a Command ('Command Injection')</Description>
    <Severity>High</Severity>
    <File>File 1</File>
    <Code>$tainted = system('ls', $retval);</Code>
    <Justification>The code uses the `system()` function with a hardcoded command 'ls'. Although the command itself might seem harmless, this practice introduces a potential vulnerability. If the script were ever modified to include user-supplied input into the command string, it would become susceptible to command injection attacks.</Justification>
  </Issue>
  <Issue>
    <Type>Security</Type>
    <Weakness>CWE-90</Weakness>
    <Description>Improper Neutralization of Special Elements used in an LDAP Query ('LDAP Injection')</Description>
    <Severity>High</Severity>
    <File>File 1</File>
    <Code>$tainted = system('ls', $retval);

$tainted = pg_escape_string($tainted);

$query = sprintf(""(&(objectCategory=person)(objectClass=user)(mail='%s'))"", $tainted);</Code>
    <Justification>The code constructs an LDAP query using `sprintf` and includes data from the `system()` call, which can be influenced by external factors. Even with `pg_escape_string`, there's a risk of LDAP injection if the escaped data contains characters that can manipulate the LDAP query structure.  LDAP injection can allow attackers to bypass authentication, extract sensitive information, or modify the LDAP directory.</Justification>
  </Issue>
</Issues>
```"
CWE-79,src/CWE_79__GET__func_rawurlencode__Unsafe_use_untrusted_data-script.php,"<!-- 
Unsafe sample
input : reads the field UserData from the variable $_GET
SANITIZE : use of rawurlencode
File : unsafe, use of untrusted data in a script
-->

<!--Copyright 2015 Bertrand STIVALET 

Permission is hereby granted, without written agreement or royalty fee, to

use, copy, modify, and distribute this software and its documentation for

any purpose, provided that the above copyright notice and the following

three paragraphs appear in all copies of this software.


IN NO EVENT SHALL AUTHORS BE LIABLE TO ANY PARTY FOR DIRECT,

INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES ARISING OUT OF THE 

USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF AUTHORS HAVE

BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.


AUTHORS SPECIFICALLY DISCLAIM ANY WARRANTIES INCLUDING, BUT NOT

LIMITED TO THE IMPLIED WARRANTIES OF MERCHANTABILITY, FITNESS FOR A

PARTICULAR PURPOSE, AND NON-INFRINGEMENT.


THE SOFTWARE IS PROVIDED ON AN ""AS-IS"" BASIS AND AUTHORS HAVE NO

OBLIGATION TO PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR

MODIFICATIONS.-->


<!DOCTYPE html>
<html>
<head>
<script>
<?php
$tainted = $_GET['UserData'];

$tainted = rawurlencode($tainted);


echo $tainted ;
?>
</script>
</head>
<body onload=""xss()"">
<h1>Hello World!</h1>
</body>
</html>",echo $tainted ;,True,True,"<script>
<?php
$tainted = $_GET['UserData'];

$tainted = rawurlencode($tainted);


echo $tainted ;
?>
</script>","```xml
<Issues>
  <Issue>
    <Type>Security</Type>
    <Weakness>CWE-79</Weakness>
    <Description>Improper Neutralization of Input During Web Page Generation ('Cross-site Scripting')</Description>
    <Severity>Medium</Severity>
    <File>File 1</File>
    <Code>&lt;script&gt;
&lt;?php
$tainted = $_GET['UserData'];

$tainted = rawurlencode($tainted);


echo $tainted ;
?&gt;
&lt;/script&gt;</Code>
    <Justification>The code retrieves user input from $_GET['UserData'], URL-encodes it, and then directly echoes it into a &lt;script&gt; block. While URL encoding can prevent some XSS attacks, it's not a foolproof solution, especially within script contexts.  If the input contains characters that are still interpreted as code after URL encoding (e.g., certain escape sequences or control characters), XSS is still possible.  This is because the browser will decode the URL-encoded characters before executing the script.  The use of rawurlencode is meant as a sanitization function, however, it is insufficient in this context.</Justification>
  </Issue>
  <Issue>
    <Type>Reliability</Type>
    <Weakness>CWE-252</Weakness>
    <Description>Unchecked Return Value</Description>
    <Severity>Low</Severity>
    <File>File 1</File>
    <Code>$tainted = $_GET['UserData'];

$tainted = rawurlencode($tainted);</Code>
    <Justification>The code does not check if $_GET['UserData'] is set before accessing it. If the 'UserData' parameter is missing from the URL, $_GET['UserData'] will be null, and the code will proceed without handling the missing parameter. Although PHP may not throw an immediate error, relying on an unset $_GET variable can lead to unexpected behavior and potential issues down the line. Similarly, the return value of rawurlencode is not checked.</Justification>
  </Issue>
</Issues>
```"
CWE-91,src/CWE_91__popen__func_preg_match-no_filtering__username_text-concatenation_simple_quote.php,"<?php







$handle = popen('/bin/cat /tmp/tainted.txt', 'r');
$tainted = fread($handle, 4096);
pclose($handle);

$re = ""/^.*$/"";
if(preg_match($re, $tainted) == 1){
  $tainted = $tainted;
}
else{
  $tainted = """";
}

$query = ""


$xml = simplexml_load_file(""users.xml"");
echo ""query : "". $query .""<br /><br />"" ;

$res=$xml->xpath($query);
print_r($res);
echo ""<br />"" ;

?>","$xml = simplexml_load_file(""users.xml"");",False,False,,"```xml
<Issues>
  <Issue>
    <Type>Security</Type>
    <Weakness>CWE-77</Weakness>
    <Description>Improper Neutralization of Special Elements used in a Command ('Command Injection')</Description>
    <Severity>High</Severity>
    <File>File 1</File>
    <Code>$handle = popen('/bin/cat /tmp/tainted.txt', 'r');
$tainted = fread($handle, 4096);
pclose($handle);</Code>
    <Justification>The code uses popen to execute a command to read a file, which could be vulnerable to command injection if the filename is attacker-controlled. Even though the filename is hardcoded here, the contents of the file are attacker-controlled and could contain shell metacharacters that are then executed by the shell.</Justification>
  </Issue>
  <Issue>
    <Type>Security</Type>
    <Weakness>CWE-643</Weakness>
    <Description>Improper Neutralization of Data within XPath Expressions ('XPath Injection')</Description>
    <Severity>High</Severity>
    <File>File 1</File>
    <Code>$query = ""


$xml = simplexml_load_file(""users.xml"");
echo ""query : "". $query .""<br /><br />"" ;

$res=$xml->xpath($query);</Code>
    <Justification>The code uses user-controlled data from $tainted to construct an XPath query without proper sanitization. This can lead to XPath injection, where an attacker can manipulate the query to extract sensitive information or perform unauthorized actions.</Justification>
  </Issue>
</Issues>
```"
CWE-79,src/CWE_79__popen__func_FILTER-CLEANING-full_special_chars_filter__Unsafe_use_untrusted_data-style.php,"<!-- 
Unsafe sample
input : Uses popen to read the file /tmp/tainted.txt using cat command
Uses a full_special_chars_filter via filter_var function
File : unsafe, use of untrusted data in CSS
-->

<!--Copyright 2015 Bertrand STIVALET 

Permission is hereby granted, without written agreement or royalty fee, to

use, copy, modify, and distribute this software and its documentation for

any purpose, provided that the above copyright notice and the following

three paragraphs appear in all copies of this software.


IN NO EVENT SHALL AUTHORS BE LIABLE TO ANY PARTY FOR DIRECT,

INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES ARISING OUT OF THE 

USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF AUTHORS HAVE

BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.


AUTHORS SPECIFICALLY DISCLAIM ANY WARRANTIES INCLUDING, BUT NOT

LIMITED TO THE IMPLIED WARRANTIES OF MERCHANTABILITY, FITNESS FOR A

PARTICULAR PURPOSE, AND NON-INFRINGEMENT.


THE SOFTWARE IS PROVIDED ON AN ""AS-IS"" BASIS AND AUTHORS HAVE NO

OBLIGATION TO PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR

MODIFICATIONS.-->


<!DOCTYPE html>
<html>
<head>
<style>
<?php
$handle = popen('/bin/cat /tmp/tainted.txt', 'r');
$tainted = fread($handle, 4096);
pclose($handle);

$sanitized = filter_var($tainted, FILTER_SANITIZE_FULL_SPECIAL_CHARS);
  $tainted = $sanitized ;
     


echo $tainted ;
?>
</style>
</head>
<body>
<h1>Hello World!</h1>
</body>
</html>",echo $tainted ;,True,True,"<style>
<?php
$handle = popen('/bin/cat /tmp/tainted.txt', 'r');
$tainted = fread($handle, 4096);
pclose($handle);

$sanitized = filter_var($tainted, FILTER_SANITIZE_FULL_SPECIAL_CHARS);
  $tainted = $sanitized ;
     


echo $tainted ;
?>
</style>","```xml
<Issues>
  <Issue>
    <Type>Security</Type>
    <Weakness>CWE-79</Weakness>
    <Description>Improper Neutralization of Input During Web Page Generation ('Cross-site Scripting')</Description>
    <Severity>Medium</Severity>
    <File>File 1</File>
    <Code>&lt;style&gt;
&lt;?php
$handle = popen('/bin/cat /tmp/tainted.txt', 'r');
$tainted = fread($handle, 4096);
pclose($handle);

$sanitized = filter_var($tainted, FILTER_SANITIZE_FULL_SPECIAL_CHARS);
  $tainted = $sanitized ;
     


echo $tainted ;
?&gt;
&lt;/style&gt;</Code>
    <Justification>The code reads data from a file, sanitizes it using FILTER_SANITIZE_FULL_SPECIAL_CHARS, and then directly echoes it into a &lt;style&gt; tag. While the sanitization function encodes special characters, it may not be sufficient to prevent all forms of CSS injection, especially if the original file contains characters that, when combined with CSS syntax, can lead to unexpected behavior. For instance, improperly escaped quotes or semicolons could break the CSS rules and potentially allow malicious styles to be injected.</Justification>
  </Issue>
  <Issue>
    <Type>Security</Type>
    <Weakness>CWE-78</Weakness>
    <Description>Improper Neutralization of Special Elements used in an OS Command ('OS Command Injection')</Description>
    <Severity>High</Severity>
    <File>File 1</File>
    <Code>$handle = popen('/bin/cat /tmp/tainted.txt', 'r');</Code>
    <Justification>The code uses `popen` to execute a command. While the command itself (`/bin/cat /tmp/tainted.txt`) is hardcoded, the existence and content of `/tmp/tainted.txt` are external factors. If an attacker can control the content of `/tmp/tainted.txt`, they might be able to inject shell commands into the filename itself that would then be executed by `cat`. This is a form of command injection. While the file path is hardcoded, the contents of the file could be influenced by external factors and thus lead to the execution of arbitrary commands.</Justification>
  </Issue>
</Issues>
```"
CWE-79,src/CWE_79__system__func_FILTER-CLEANING-full_special_chars_filter__Unsafe_use_untrusted_data-tag_Name.php,"<!-- 
Unsafe sample
input : execute a ls command using the function system, and put the last result in $tainted
Uses a full_special_chars_filter via filter_var function
File : unsafe, use of untrusted data in an tag name
-->

<!--Copyright 2015 Bertrand STIVALET 

Permission is hereby granted, without written agreement or royalty fee, to

use, copy, modify, and distribute this software and its documentation for

any purpose, provided that the above copyright notice and the following

three paragraphs appear in all copies of this software.


IN NO EVENT SHALL AUTHORS BE LIABLE TO ANY PARTY FOR DIRECT,

INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES ARISING OUT OF THE 

USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF AUTHORS HAVE

BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.


AUTHORS SPECIFICALLY DISCLAIM ANY WARRANTIES INCLUDING, BUT NOT

LIMITED TO THE IMPLIED WARRANTIES OF MERCHANTABILITY, FITNESS FOR A

PARTICULAR PURPOSE, AND NON-INFRINGEMENT.


THE SOFTWARE IS PROVIDED ON AN ""AS-IS"" BASIS AND AUTHORS HAVE NO

OBLIGATION TO PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR

MODIFICATIONS.-->


<!DOCTYPE html>
<html>
<head/>
<body>
<?php
$tainted = system('ls', $retval);

$sanitized = filter_var($tainted, FILTER_SANITIZE_FULL_SPECIAL_CHARS);
  $tainted = $sanitized ;
     


echo ""<"".  $tainted ."" href= \""/bob\"" />"" ;
?>
<h1>Hello World!</h1>
</body>
</html>","echo ""<"".  $tainted ."" href= \""/bob\"" />"" ;",True,True,"<?php
$tainted = system('ls', $retval);

$sanitized = filter_var($tainted, FILTER_SANITIZE_FULL_SPECIAL_CHARS);
  $tainted = $sanitized ;
     


echo ""<"".  $tainted ."" href= \""/bob\"" />"" ;
?>","```xml
<Issues>
  <Issue>
    <Type>Security</Type>
    <Weakness>CWE-79</Weakness>
    <Description>Improper Neutralization of Input During Web Page Generation ('Cross-site Scripting')</Description>
    <Severity>High</Severity>
    <File>File 1</File>
    <Code>&lt;?php
$tainted = system('ls', $retval);

$sanitized = filter_var($tainted, FILTER_SANITIZE_FULL_SPECIAL_CHARS);
  $tainted = $sanitized ;
     


echo ""&lt;"".  $tainted ."" href= \""/bob\"" /&gt;"" ;
?&gt;</Code>
    <Justification>The code executes an OS command ('ls') and uses its output to construct part of an HTML tag name. Although the output is sanitized using FILTER_SANITIZE_FULL_SPECIAL_CHARS, this only encodes special characters and does not prevent injection if the output contains characters that are invalid or dangerous in tag names. An attacker could potentially inject arbitrary HTML elements if the 'ls' command returns malicious data.</Justification>
  </Issue>
  <Issue>
    <Type>Security</Type>
    <Weakness>CWE-78</Weakness>
    <Description>Improper Neutralization of Special Elements used in an OS Command ('OS Command Injection')</Description>
    <Severity>High</Severity>
    <File>File 1</File>
    <Code>$tainted = system('ls', $retval);</Code>
    <Justification>The code uses the `system()` function to execute the 'ls' command. While the example uses a static command, if the command were constructed using user-controlled input, it would be vulnerable to OS command injection. Although not directly exploitable here, it represents a coding pattern that can lead to vulnerabilities.</Justification>
  </Issue>
  <Issue>
    <Type>Reliability</Type>
    <Weakness>CWE-252</Weakness>
    <Description>Unchecked Return Value</Description>
    <Severity>Low</Severity>
    <File>File 1</File>
    <Code>$tainted = system('ls', $retval);</Code>
    <Justification>The code uses the `system()` function but does not check its return value. If the command execution fails, the `$tainted` variable might contain unexpected data or remain uninitialized, leading to unpredictable behavior in subsequent code.</Justification>
  </Issue>
</Issues>
```"
CWE-79,src/CWE_79__unserialize__func_FILTER-CLEANING-full_special_chars_filter__Use_untrusted_data_propertyValue_CSS-property_Value.php,"<!-- 
Unsafe sample
input : Get a serialize string in POST and unserialize it
Uses a full_special_chars_filter via filter_var function
File : use of untrusted data in a property value (CSS)
-->

<!--Copyright 2015 Bertrand STIVALET 

Permission is hereby granted, without written agreement or royalty fee, to

use, copy, modify, and distribute this software and its documentation for

any purpose, provided that the above copyright notice and the following

three paragraphs appear in all copies of this software.


IN NO EVENT SHALL AUTHORS BE LIABLE TO ANY PARTY FOR DIRECT,

INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES ARISING OUT OF THE 

USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF AUTHORS HAVE

BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.


AUTHORS SPECIFICALLY DISCLAIM ANY WARRANTIES INCLUDING, BUT NOT

LIMITED TO THE IMPLIED WARRANTIES OF MERCHANTABILITY, FITNESS FOR A

PARTICULAR PURPOSE, AND NON-INFRINGEMENT.


THE SOFTWARE IS PROVIDED ON AN ""AS-IS"" BASIS AND AUTHORS HAVE NO

OBLIGATION TO PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR

MODIFICATIONS.-->


<!DOCTYPE html>
<html>
<head>
<style>
<?php
$string = $_POST['UserData'] ;
$tainted = unserialize($string);
    

$sanitized = filter_var($tainted, FILTER_SANITIZE_FULL_SPECIAL_CHARS);
  $tainted = $sanitized ;
     


echo ""body { color :"". $tainted ."" ; }"" ;
?>
 </style> 
 </script>
</head>
<body>
<h1>Hello World!</h1>
</body>
</html>","echo ""body { color :"". $tainted ."" ; }"" ;",True,True,"$sanitized = filter_var($tainted, FILTER_SANITIZE_FULL_SPECIAL_CHARS);
  $tainted = $sanitized ;
     


echo ""body { color :"". $tainted ."" ; }"" ;","```xml
<Issues>
  <Issue>
    <Type>Security</Type>
    <Weakness>CWE-502</Weakness>
    <Description>Deserialization of Untrusted Data</Description>
    <Severity>Critical</Severity>
    <File>File 1</File>
    <Code>$string = $_POST['UserData'] ;
$tainted = unserialize($string);</Code>
    <Justification>The code uses unserialize() on user-controlled data ($_POST['UserData']), which can lead to arbitrary code execution if the serialized data is malicious.</Justification>
  </Issue>
  <Issue>
    <Type>Security</Type>
    <Weakness>CWE-79</Weakness>
    <Description>Improper Neutralization of Input During Web Page Generation ('Cross-site Scripting')</Description>
    <Severity>Medium</Severity>
    <File>File 1</File>
    <Code>$sanitized = filter_var($tainted, FILTER_SANITIZE_FULL_SPECIAL_CHARS);
  $tainted = $sanitized ;
     


echo ""body { color :"". $tainted ."" ; }"" ;</Code>
    <Justification>Even after sanitizing with FILTER_SANITIZE_FULL_SPECIAL_CHARS, the value is used directly in a CSS property, which might still allow for CSS injection. Although this filter mitigates HTML and JavaScript injection, CSS injection remains a risk.</Justification>
  </Issue>
</Issues>
```"
CWE-90,src/CWE_90__shell_exec__func_htmlentities__userByCN-sprintf_%s_simple_quote.php,"<?php







$tainted = shell_exec('cat /tmp/tainted.txt');

$tainted = htmlentities($tainted, ENT_QUOTES);

$query = sprintf(""(&(objectCategory=person)(objectClass=user)(cn='%s'))"", $tainted);


$ds=ldap_connect(""localhost""); 
$r=ldap_bind($ds);
$sr=ldap_search($ds,""o=My Company, c=US"", $query);  
ldap_close($ds);

?>","$ds=ldap_connect(""localhost"");",True,True,"$tainted = shell_exec('cat /tmp/tainted.txt');

$tainted = htmlentities($tainted, ENT_QUOTES);

$query = sprintf(""(&(objectCategory=person)(objectClass=user)(cn='%s'))"", $tainted);


$ds=ldap_connect(""localhost""); 
$r=ldap_bind($ds);
$sr=ldap_search($ds,""o=My Company, c=US"", $query);  
ldap_close($ds);","```xml
<Issues>
  <Issue>
    <Type>Security</Type>
    <Weakness>CWE-90</Weakness>
    <Description>Improper Neutralization of Special Elements used in an LDAP Query ('LDAP Injection')</Description>
    <Severity>High</Severity>
    <File>File 1</File>
    <Code>$tainted = shell_exec('cat /tmp/tainted.txt');

$tainted = htmlentities($tainted, ENT_QUOTES);

$query = sprintf(""(&(objectCategory=person)(objectClass=user)(cn='%s'))"", $tainted);


$ds=ldap_connect(""localhost""); 
$r=ldap_bind($ds);
$sr=ldap_search($ds,""o=My Company, c=US"", $query);  
ldap_close($ds);</Code>
    <Justification>The code constructs an LDAP query using unsanitized input from the $tainted variable. Although htmlentities is used, it might not be sufficient to prevent LDAP injection attacks, as certain characters relevant to LDAP syntax may not be properly neutralized. This could allow an attacker to modify the LDAP query and potentially retrieve sensitive information or perform unauthorized actions.</Justification>
  </Issue>
  <Issue>
    <Type>Security</Type>
    <Weakness>CWE-77</Weakness>
    <Description>Improper Neutralization of Special Elements used in a Command ('Command Injection')</Description>
    <Severity>High</Severity>
    <File>File 1</File>
    <Code>$tainted = shell_exec('cat /tmp/tainted.txt');</Code>
    <Justification>The code uses shell_exec to execute the command 'cat /tmp/tainted.txt'. If the contents of /tmp/tainted.txt are attacker-controlled, this could lead to command injection vulnerabilities. An attacker could insert shell commands into the file, which would then be executed by the server.</Justification>
  </Issue>
  <Issue>
    <Type>Reliability</Type>
    <Weakness>CWE-252</Weakness>
    <Description>Unchecked Return Value</Description>
    <Severity>Medium</Severity>
    <File>File 1</File>
    <Code>$ds=ldap_connect(""localhost""); 
$r=ldap_bind($ds);
$sr=ldap_search($ds,""o=My Company, c=US"", $query);  
ldap_close($ds);</Code>
    <Justification>The code does not check the return values of ldap_connect, ldap_bind, and ldap_search. If any of these functions fail, the script will continue to execute, potentially leading to unexpected behavior or security vulnerabilities. For example, if ldap_connect fails, $ds will be false, and subsequent calls to ldap_bind and ldap_search will result in errors.</Justification>
  </Issue>
</Issues>
```"
CWE-79,src/CWE_79__shell_exec__func_http_build_query__Use_untrusted_data_propertyValue_CSS-span_Style_Property_Value.php,"<!-- 
Unsafe sample
input : use shell_exec to cat /tmp/tainted.txt
SANITIZE : use of http_build_query
File : unsafe, use of untrusted data in a property value in a span tag(CSS)
-->

<!--Copyright 2015 Bertrand STIVALET 

Permission is hereby granted, without written agreement or royalty fee, to

use, copy, modify, and distribute this software and its documentation for

any purpose, provided that the above copyright notice and the following

three paragraphs appear in all copies of this software.


IN NO EVENT SHALL AUTHORS BE LIABLE TO ANY PARTY FOR DIRECT,

INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES ARISING OUT OF THE 

USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF AUTHORS HAVE

BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.


AUTHORS SPECIFICALLY DISCLAIM ANY WARRANTIES INCLUDING, BUT NOT

LIMITED TO THE IMPLIED WARRANTIES OF MERCHANTABILITY, FITNESS FOR A

PARTICULAR PURPOSE, AND NON-INFRINGEMENT.


THE SOFTWARE IS PROVIDED ON AN ""AS-IS"" BASIS AND AUTHORS HAVE NO

OBLIGATION TO PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR

MODIFICATIONS.-->


<!DOCTYPE html>
<html>
<head/>
<body>
<?php
$tainted = shell_exec('cat /tmp/tainted.txt');

$tainted = http_build_query($tainted);


echo ""<span style=\""color :"". checked_data .""\"">Hey</span>"" ;
?>
<h1>Hello World!</h1>
</body>
</html>","echo ""<span style=\""color :"". checked_data .""\"">Hey</span>"" ;",True,True,"echo ""<span style=\""color :"". checked_data .""\"">Hey</span>"" ;","```xml
<Issues>
  <Issue>
    <Type>Security</Type>
    <Weakness>CWE-77</Weakness>
    <Description>Improper Neutralization of Special Elements used in a Command ('Command Injection')</Description>
    <Severity>High</Severity>
    <File>File 1</File>
    <Code>$tainted = shell_exec('cat /tmp/tainted.txt');</Code>
    <Justification>The code uses shell_exec to execute a command. If /tmp/tainted.txt contains malicious commands, it could lead to command injection.</Justification>
  </Issue>
  <Issue>
    <Type>Security</Type>
    <Weakness>CWE-79</Weakness>
    <Description>Improper Neutralization of Input During Web Page Generation ('Cross-site Scripting')</Description>
    <Severity>Medium</Severity>
    <File>File 1</File>
    <Code>echo ""&lt;span style=\""color :"". checked_data .""\""&gt;Hey&lt;/span&gt;"" ;</Code>
    <Justification>The code uses unchecked_data directly in the style attribute of a span tag, which can lead to CSS injection and potentially XSS if unchecked_data contains malicious CSS code.</Justification>
  </Issue>
</Issues>
```"
CWE-90,src/CWE_90__array-GET__func_htmlentities__name-sprintf_%s_simple_quote.php,"<?php







$array = array();
$array[] = 'safe' ;
$array[] = $_GET['userData'] ;
$array[] = 'safe' ;
$tainted = $array[1] ;

$tainted = htmlentities($tainted, ENT_QUOTES);

$query = sprintf(""name='%s'"", $tainted);


$ds=ldap_connect(""localhost""); 
$r=ldap_bind($ds);
$sr=ldap_search($ds,""o=My Company, c=US"", $query);  
ldap_close($ds);

?>","$ds=ldap_connect(""localhost"");",True,True,"$query = sprintf(""name='%s'"", $tainted);


$ds=ldap_connect(""localhost""); 
$r=ldap_bind($ds);
$sr=ldap_search($ds,""o=My Company, c=US"", $query);  
ldap_close($ds);","```xml
<Issues>
  <Issue>
    <Type>Security</Type>
    <Weakness>CWE-90</Weakness>
    <Description>Improper Neutralization of Special Elements used in an LDAP Query ('LDAP Injection')</Description>
    <Severity>High</Severity>
    <File>File 1</File>
    <Code>$query = sprintf(""name='%s'"", $tainted);


$ds=ldap_connect(""localhost""); 
$r=ldap_bind($ds);
$sr=ldap_search($ds,""o=My Company, c=US"", $query);  
ldap_close($ds);</Code>
    <Justification>The code constructs an LDAP query using user-controlled input ($tainted) without proper sanitization. Although htmlentities is used, it might not be sufficient to prevent LDAP injection attacks, as specific LDAP control characters may still be exploitable. This can allow an attacker to modify the LDAP query and potentially gain unauthorized access to sensitive information or perform malicious operations.</Justification>
  </Issue>
</Issues>
```"
CWE-79,src/CWE_79__popen__func_FILTER-VALIDATION-number_float_filter__Use_untrusted_data_propertyValue_CSS-quoted_Property_Value.php,"<!-- 
Unsafe sample
input : Uses popen to read the file /tmp/tainted.txt using cat command
Flushes content of $sanitized if the filter number_float_filter is not applied
File : unsafe, use of untrusted data in a quoted property value (CSS)
-->

<!--Copyright 2015 Bertrand STIVALET 

Permission is hereby granted, without written agreement or royalty fee, to

use, copy, modify, and distribute this software and its documentation for

any purpose, provided that the above copyright notice and the following

three paragraphs appear in all copies of this software.


IN NO EVENT SHALL AUTHORS BE LIABLE TO ANY PARTY FOR DIRECT,

INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES ARISING OUT OF THE 

USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF AUTHORS HAVE

BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.


AUTHORS SPECIFICALLY DISCLAIM ANY WARRANTIES INCLUDING, BUT NOT

LIMITED TO THE IMPLIED WARRANTIES OF MERCHANTABILITY, FITNESS FOR A

PARTICULAR PURPOSE, AND NON-INFRINGEMENT.


THE SOFTWARE IS PROVIDED ON AN ""AS-IS"" BASIS AND AUTHORS HAVE NO

OBLIGATION TO PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR

MODIFICATIONS.-->


<!DOCTYPE html>
<html>
<head>
<style>
<?php
$handle = popen('/bin/cat /tmp/tainted.txt', 'r');
$tainted = fread($handle, 4096);
pclose($handle);

if (filter_var($sanitized, FILTER_VALIDATE_FLOAT))
  $tainted = $sanitized ;
else
  $tainted = """" ;


echo ""body { color :\'"". $tainted .""\' ; }"" ;
?>
</style> 
</head>
<body>
<h1>Hello World!</h1>
</body>
</html>","echo ""body { color :\'"". $tainted .""\' ; }"" ;",True,True,"if (filter_var($sanitized, FILTER_VALIDATE_FLOAT))
  $tainted = $sanitized ;
else
  $tainted = """" ;


echo ""body { color :\'"". $tainted .""\' ; }"" ;","```xml
<Issues>
  <Issue>
    <Type>Security</Type>
    <Weakness>CWE-77</Weakness>
    <Description>Improper Neutralization of Special Elements used in a Command ('Command Injection')</Description>
    <Severity>High</Severity>
    <File>File 1</File>
    <Code>$handle = popen('/bin/cat /tmp/tainted.txt', 'r');</Code>
    <Justification>The code uses popen to execute a command, which can be vulnerable to command injection if the command string is constructed using untrusted input. In this case, '/bin/cat /tmp/tainted.txt' is hardcoded, so it is not directly vulnerable, but the use of popen itself can be dangerous if the intent is to execute dynamic commands based on external input.</Justification>
  </Issue>
  <Issue>
    <Type>Security</Type>
    <Weakness>CWE-79</Weakness>
    <Description>Improper Neutralization of Input During Web Page Generation ('Cross-site Scripting')</Description>
    <Severity>Medium</Severity>
    <File>File 1</File>
    <Code>if (filter_var($sanitized, FILTER_VALIDATE_FLOAT))
  $tainted = $sanitized ;
else
  $tainted = """" ;


echo ""body { color :\'"". $tainted .""\' ; }"" ;</Code>
    <Justification>The code echoes the $tainted variable directly into the CSS style without proper sanitization. If $tainted contains malicious code, it could lead to Cross-Site Scripting (XSS). The code attempts to sanitize with `filter_var` and `FILTER_VALIDATE_FLOAT` but the variable `$sanitized` is not defined. If the validation fails, it sets `$tainted` to an empty string, mitigating the XSS risk in that case. However, the absence of proper sanitization makes it vulnerable if `$sanitized` is validated without sanitization.</Justification>
  </Issue>
  <Issue>
    <Type>Reliability</Type>
    <Weakness>CWE-252</Weakness>
    <Description>Unchecked Return Value</Description>
    <Severity>Low</Severity>
    <File>File 1</File>
    <Code>$handle = popen('/bin/cat /tmp/tainted.txt', 'r');
$tainted = fread($handle, 4096);
pclose($handle);</Code>
    <Justification>The code does not check the return values of `popen`, `fread`, and `pclose`. If any of these functions fail, the program might proceed with uninitialized or incorrect data, leading to unexpected behavior or errors. For example, `popen` might return `false` if it fails to open the process, and `fread` might return `false` if it fails to read the file.</Justification>
  </Issue>
  <Issue>
    <Type>Security</Type>
    <Weakness>CWE-477</Weakness>
    <Description>Use of Obsolete Function</Description>
    <Severity>Low</Severity>
    <File>File 1</File>
    <Code>$handle = popen('/bin/cat /tmp/tainted.txt', 'r');
$tainted = fread($handle, 4096);
pclose($handle);</Code>
    <Justification>The `popen` function is considered by some to be potentially unsafe and has been superseded by other functions in some contexts. While not strictly obsolete, its use warrants caution and review, as it can be a source of vulnerabilities if used improperly.</Justification>
  </Issue>
</Issues>
```"
CWE-79,src/CWE_79__object-indexArray__func_FILTER-CLEANING-email_filter__Use_untrusted_data_propertyValue_CSS-double_Quoted_Property_Value.php,"<!-- 
Unsafe sample
input : get the field userData from the variable $_GET via an object, which store it in a array
Uses an email_filter via filter_var function
File : use of untrusted data in a double quoted property value (CSS)
-->

<!--Copyright 2015 Bertrand STIVALET 

Permission is hereby granted, without written agreement or royalty fee, to

use, copy, modify, and distribute this software and its documentation for

any purpose, provided that the above copyright notice and the following

three paragraphs appear in all copies of this software.


IN NO EVENT SHALL AUTHORS BE LIABLE TO ANY PARTY FOR DIRECT,

INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES ARISING OUT OF THE 

USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF AUTHORS HAVE

BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.


AUTHORS SPECIFICALLY DISCLAIM ANY WARRANTIES INCLUDING, BUT NOT

LIMITED TO THE IMPLIED WARRANTIES OF MERCHANTABILITY, FITNESS FOR A

PARTICULAR PURPOSE, AND NON-INFRINGEMENT.


THE SOFTWARE IS PROVIDED ON AN ""AS-IS"" BASIS AND AUTHORS HAVE NO

OBLIGATION TO PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR

MODIFICATIONS.-->


<!DOCTYPE html>
<html>
<head>
<style>
<?php
class Input{
  private $input;

  public function getInput(){
    return $this->input['realOne'];
  }

  public  function __construct(){
    $this->input = array();
    $this->input['test']= 'safe' ;
    $this->input['realOne']= $_GET['UserData'] ;
    $this->input['trap']= 'safe' ;
  }
}
$temp = new Input();
$tainted =  $temp->getInput();

$sanitized = filter_var($tainted, FILTER_SANITIZE_EMAIL);
if (filter_var($sanitized, FILTER_VALIDATE_EMAIL))
  $tainted = $sanitized ;
else
  $tainted = """" ;


echo ""body { color :\"""". $tainted .""\"" ; }"" ;
?>
</style> 
</head>
<body>
<h1>Hello World!</h1>
</body>
</html>","echo ""body { color :\"""". $tainted .""\"" ; }"" ;",True,True,"echo ""body { color :\"""". $tainted .""\"" ; }"" ;","```xml
<Issues>
  <Issue>
    <Type>Security</Type>
    <Weakness>CWE-79</Weakness>
    <Description>Improper Neutralization of Input During Web Page Generation ('Cross-site Scripting')</Description>
    <Severity>Medium</Severity>
    <File>File 1</File>
    <Code>echo ""body { color :\"""". $tainted .""\"" ; }"" ;</Code>
    <Justification>The code directly embeds user-controlled input ($tainted) into the CSS style section of the HTML document. While the code attempts to sanitize the input using FILTER_SANITIZE_EMAIL and FILTER_VALIDATE_EMAIL, CSS injection is still possible if the input contains valid email characters that can be interpreted as CSS properties. This can lead to Cross-Site Scripting (XSS) vulnerabilities.</Justification>
  </Issue>
</Issues>
```"
CWE-79,src/CWE_79__object-Array__func_FILTER-VALIDATION-number_int_filter__Use_untrusted_data_propertyValue_CSS-quoted_Property_Value.php,"<!-- 
Unsafe sample
input : get the field userData from the variable $_GET via an object, which store it in a array
Flushes content of $sanitized if the filter number_int_filter is not applied
File : unsafe, use of untrusted data in a quoted property value (CSS)
-->

<!--Copyright 2015 Bertrand STIVALET 

Permission is hereby granted, without written agreement or royalty fee, to

use, copy, modify, and distribute this software and its documentation for

any purpose, provided that the above copyright notice and the following

three paragraphs appear in all copies of this software.


IN NO EVENT SHALL AUTHORS BE LIABLE TO ANY PARTY FOR DIRECT,

INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES ARISING OUT OF THE 

USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF AUTHORS HAVE

BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.


AUTHORS SPECIFICALLY DISCLAIM ANY WARRANTIES INCLUDING, BUT NOT

LIMITED TO THE IMPLIED WARRANTIES OF MERCHANTABILITY, FITNESS FOR A

PARTICULAR PURPOSE, AND NON-INFRINGEMENT.


THE SOFTWARE IS PROVIDED ON AN ""AS-IS"" BASIS AND AUTHORS HAVE NO

OBLIGATION TO PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR

MODIFICATIONS.-->


<!DOCTYPE html>
<html>
<head>
<style>
<?php
class Input{
  private $input;

  public function getInput(){
    return $this->input[1];
  }

  public  function __construct(){
    $this->input = array();
    $this->input[0]= 'safe' ;
    $this->input[1]= $_GET['UserData'] ;
    $this->input[2]= 'safe' ;
  }
}
$temp = new Input();
$tainted =  $temp->getInput();

if (filter_var($sanitized, FILTER_VALIDATE_INT))
  $tainted = $sanitized ;
else
  $tainted = """" ;


echo ""body { color :\'"". $tainted .""\' ; }"" ;
?>
</style> 
</head>
<body>
<h1>Hello World!</h1>
</body>
</html>","echo ""body { color :\'"". $tainted .""\' ; }"" ;",True,True,"$this->input[1]= $_GET['UserData'] ;
    $this->input[2]= 'safe' ;
  }
}
$temp = new Input();
$tainted =  $temp->getInput();

if (filter_var($sanitized, FILTER_VALIDATE_INT))
  $tainted = $sanitized ;
else
  $tainted = """" ;


echo ""body { color :\'"". $tainted .""\' ; }"" ;","```xml
<Issues>
  <Issue>
    <Type>Security</Type>
    <Weakness>CWE-79</Weakness>
    <Description>Improper Neutralization of Input During Web Page Generation ('Cross-site Scripting')</Description>
    <Severity>Medium</Severity>
    <File>File 1</File>
    <Code>    $this->input[1]= $_GET['UserData'] ;
    $this->input[2]= 'safe' ;
  }
}
$temp = new Input();
$tainted =  $temp->getInput();

if (filter_var($sanitized, FILTER_VALIDATE_INT))
  $tainted = $sanitized ;
else
  $tainted = """" ;


echo ""body { color :\'"". $tainted .""\' ; }"" ;</Code>
    <Justification>The code retrieves user input from $_GET['UserData'] and uses it to dynamically generate CSS styles without proper sanitization. This can lead to Cross-Site Scripting (XSS) vulnerabilities if the user input contains malicious code (e.g., JavaScript) that could be executed by the victim's browser, due to the single quotes surrounding the variable.</Justification>
  </Issue>
  <Issue>
    <Type>Security</Type>
    <Weakness>CWE-477</Weakness>
    <Description>Use of Obsolete Function</Description>
    <Severity>Low</Severity>
    <File>File 1</File>
    <Code>if (filter_var($sanitized, FILTER_VALIDATE_INT))
  $tainted = $sanitized ;
else
  $tainted = """" ;</Code>
    <Justification>The code uses `$sanitized` without it being initialized. This could be a typo and an obsolete way of handling the input. It is better to check `$tainted` directly and sanitize it.</Justification>
  </Issue>
</Issues>
```"
CWE-79,src/CWE_79__array-GET__ternary_white_list__Use_untrusted_data_script-doublequoted_Event_Handler.php,"<!-- 
Unsafe sample
input : get the $_GET['userData'] in an array
sanitize : use of ternary condition
File : use of untrusted data in a double quoted event handler in a script
-->

<!--Copyright 2015 Bertrand STIVALET 

Permission is hereby granted, without written agreement or royalty fee, to

use, copy, modify, and distribute this software and its documentation for

any purpose, provided that the above copyright notice and the following

three paragraphs appear in all copies of this software.


IN NO EVENT SHALL AUTHORS BE LIABLE TO ANY PARTY FOR DIRECT,

INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES ARISING OUT OF THE 

USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF AUTHORS HAVE

BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.


AUTHORS SPECIFICALLY DISCLAIM ANY WARRANTIES INCLUDING, BUT NOT

LIMITED TO THE IMPLIED WARRANTIES OF MERCHANTABILITY, FITNESS FOR A

PARTICULAR PURPOSE, AND NON-INFRINGEMENT.


THE SOFTWARE IS PROVIDED ON AN ""AS-IS"" BASIS AND AUTHORS HAVE NO

OBLIGATION TO PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR

MODIFICATIONS.-->


<!DOCTYPE html>
<html>
<head/>
<body>
<?php
$array = array();
$array[] = 'safe' ;
$array[] = $_GET['userData'] ;
$array[] = 'safe' ;
$tainted = $array[1] ;

$tainted = $tainted  == 'safe1' ? 'safe1' : 'safe2';


echo ""<div onmouseover=\""x=\"""". $tainted .""\""\>"";
?>
<h1>Hello World!</h1>
</div>
</body>
</html>","echo ""<div onmouseover=\""x=\"""". $tainted .""\""\>"";",True,True,"$array = array();
$array[] = 'safe' ;
$array[] = $_GET['userData'] ;
$array[] = 'safe' ;
$tainted = $array[1] ;

$tainted = $tainted  == 'safe1' ? 'safe1' : 'safe2';


echo ""<div onmouseover=""x="""". $tainted ."""">"";","```xml
<Issues>
  <Issue>
    <Type>Security</Type>
    <Weakness>CWE-79</Weakness>
    <Description>Improper Neutralization of Input During Web Page Generation ('Cross-site Scripting')</Description>
    <Severity>Medium</Severity>
    <File>File 1</File>
    <Code>$array = array();
$array[] = 'safe' ;
$array[] = $_GET['userData'] ;
$array[] = 'safe' ;
$tainted = $array[1] ;

$tainted = $tainted  == 'safe1' ? 'safe1' : 'safe2';


echo ""&lt;div onmouseover=&quot;x=&quot;"". $tainted .""&quot;&gt;"";</Code>
    <Justification>The code retrieves user input from $_GET['userData'] and uses it in an HTML event handler (onmouseover) without proper sanitization. Although a ternary operator is used, it only checks if the input is equal to 'safe1' and assigns 'safe1' or 'safe2' accordingly, which doesn't neutralize potentially malicious JavaScript code. An attacker could inject arbitrary JavaScript code into the onmouseover event handler, leading to cross-site scripting (XSS).</Justification>
  </Issue>
</Issues>
```"
CWE-90,src/CWE_90__object-indexArray__func_preg_replace2__userByCN-sprintf_%s_simple_quote.php,"<?php







class Input{
  private $input;

  public function getInput(){
    return $this->input['realOne'];
  }

  public  function __construct(){
    $this->input = array();
    $this->input['test']= 'safe' ;
    $this->input['realOne']= $_GET['UserData'] ;
    $this->input['trap']= 'safe' ;
  }
}
$temp = new Input();
$tainted =  $temp->getInput();

$tainted = preg_replace('/\W/si','',$tainted);

$query = sprintf(""(&(objectCategory=person)(objectClass=user)(cn='%s'))"", $tainted);


$ds=ldap_connect(""localhost""); 
$r=ldap_bind($ds);
$sr=ldap_search($ds,""o=My Company, c=US"", $query);  
ldap_close($ds);

?>","$ds=ldap_connect(""localhost"");",True,True,"$tainted =  $temp->getInput();

$tainted = preg_replace('/\W/si','',$tainted);

$query = sprintf(""(&(objectCategory=person)(objectClass=user)(cn='%s'))"", $tainted);


$ds=ldap_connect(""localhost"");","```xml
<Issues>
  <Issue>
    <Type>Security</Type>
    <Weakness>CWE-90</Weakness>
    <Description>Improper Neutralization of Special Elements used in an LDAP Query ('LDAP Injection')</Description>
    <Severity>High</Severity>
    <File>File 1</File>
    <Code>$tainted =  $temp->getInput();

$tainted = preg_replace('/\W/si','',$tainted);

$query = sprintf(""(&(objectCategory=person)(objectClass=user)(cn='%s'))"", $tainted);


$ds=ldap_connect(""localhost"");</Code>
    <Justification>The code constructs an LDAP query using user-controlled input ($tainted), even after applying a regular expression. While the regex removes non-alphanumeric characters, it might not be sufficient to prevent LDAP injection. An attacker could still craft input that, after the regex, results in a modified LDAP query that exposes sensitive information or allows unauthorized access.</Justification>
  </Issue>
  <Issue>
    <Type>Reliability</Type>
    <Weakness>CWE-252</Weakness>
    <Description>Unchecked Return Value</Description>
    <Severity>Medium</Severity>
    <File>File 1</File>
    <Code>$ds=ldap_connect(""localhost""); 
$r=ldap_bind($ds);
$sr=ldap_search($ds,""o=My Company, c=US"", $query);  
ldap_close($ds);</Code>
    <Justification>The code does not check the return values of ldap_connect, ldap_bind, and ldap_search. If any of these functions fail, they will return FALSE, and the script will continue to execute, potentially leading to unexpected behavior or security vulnerabilities. For instance, if ldap_connect fails, subsequent calls to ldap_bind and ldap_search will operate on a null or invalid resource, leading to errors or crashes.</Justification>
  </Issue>
  <Issue>
    <Type>Security</Type>
    <Weakness>CWE-798</Weakness>
    <Description>Use of Hard-coded Credentials</Description>
    <Severity>Critical</Severity>
    <File>File 1</File>
    <Code>$ds=ldap_connect(""localhost""); 
$r=ldap_bind($ds);
$sr=ldap_search($ds,""o=My Company, c=US"", $query);  
ldap_close($ds);</Code>
    <Justification>The code connects to the LDAP server without specifying any credentials. While it might work in some environments, it implies that the LDAP server is configured for anonymous access. However, if the LDAP server requires authentication, the ldap_bind function will fail silently if it is configured for anonymous access. If authentication is required, hardcoding credentials directly in the code is a security risk, as it makes the application vulnerable if the code is exposed.</Justification>
  </Issue>
</Issues>
```"
CWE-90,src/CWE_90__object-classicGet__func_htmlentities__userByCN-sprintf_%s_simple_quote.php,"<?php







class Input{
  private $input;

  public function getInput(){
    return $this->input;
  }

  public  function __construct(){
   $this->input = $_GET['UserData'] ;
  }
}
$temp = new Input();
$tainted =  $temp->getInput();

$tainted = htmlentities($tainted, ENT_QUOTES);

$query = sprintf(""(&(objectCategory=person)(objectClass=user)(cn='%s'))"", $tainted);


$ds=ldap_connect(""localhost""); 
$r=ldap_bind($ds);
$sr=ldap_search($ds,""o=My Company, c=US"", $query);  
ldap_close($ds);

?>","$ds=ldap_connect(""localhost"");",True,True,"$tainted = htmlentities($tainted, ENT_QUOTES);

$query = sprintf(""(&(objectCategory=person)(objectClass=user)(cn='%s'))"", $tainted);


$ds=ldap_connect(""localhost"");","```xml
<Issues>
  <Issue>
    <Type>Security</Type>
    <Weakness>CWE-90</Weakness>
    <Description>Improper Neutralization of Special Elements used in an LDAP Query ('LDAP Injection')</Description>
    <Severity>High</Severity>
    <File>File 1</File>
    <Code>$tainted = htmlentities($tainted, ENT_QUOTES);

$query = sprintf(""(&(objectCategory=person)(objectClass=user)(cn='%s'))"", $tainted);


$ds=ldap_connect(""localhost"");</Code>
    <Justification>The code constructs an LDAP query using user-controlled input ($tainted) without proper sanitization. Although htmlentities is used, it might not be sufficient to prevent LDAP injection attacks, as certain characters relevant to LDAP syntax might not be neutralized.  An attacker could manipulate the input to inject malicious LDAP code, potentially gaining unauthorized access to sensitive information.</Justification>
  </Issue>
  <Issue>
    <Type>Reliability</Type>
    <Weakness>CWE-252</Weakness>
    <Description>Unchecked Return Value</Description>
    <Severity>Medium</Severity>
    <File>File 1</File>
    <Code>$ds=ldap_connect(""localhost""); 
$r=ldap_bind($ds);
$sr=ldap_search($ds,""o=My Company, c=US"", $query);  
ldap_close($ds);</Code>
    <Justification>The code does not check the return values of ldap_connect, ldap_bind, and ldap_search. If any of these functions fail, they will return FALSE (or an error code). The subsequent code will then operate on a potentially invalid resource, leading to unpredictable behavior or errors. This can cause the application to fail unexpectedly.</Justification>
  </Issue>
  <Issue>
    <Type>Maintainability</Type>
    <Weakness>CWE-1051</Weakness>
    <Description>Initialization with Hard-Coded Network Resource Configuration Data</Description>
    <Severity>Low</Severity>
    <File>File 1</File>
    <Code>$ds=ldap_connect(""localhost"");</Code>
    <Justification>The code initializes the LDAP connection with a hard-coded server address (""localhost""). This makes it difficult to change the server address without modifying the source code, reducing maintainability and flexibility. It would be better to use a configuration variable for the server address.</Justification>
  </Issue>
</Issues>
```"
CWE-78,src/CWE_78__backticks__func_FILTER-CLEANING-email_filter__ls-interpretation_simple_quote.php,"<?php







$tainted = `cat /tmp/tainted.txt`;

$sanitized = filter_var($tainted, FILTER_SANITIZE_EMAIL);
if (filter_var($sanitized, FILTER_VALIDATE_EMAIL))
  $tainted = $sanitized ;
else
  $tainted = """" ;

$query = ""ls ' $tainted '"";


$ret = system($query);


?>",$ret = system($query);,True,True,"$tainted = `cat /tmp/tainted.txt`;

$sanitized = filter_var($tainted, FILTER_SANITIZE_EMAIL);
if (filter_var($sanitized, FILTER_VALIDATE_EMAIL))
  $tainted = $sanitized ;
else
  $tainted = """" ;

$query = ""ls ' $tainted '"";


$ret = system($query);","```xml
<Issues>
  <Issue>
    <Type>Security</Type>
    <Weakness>CWE-78</Weakness>
    <Description>Improper Neutralization of Special Elements used in an OS Command ('OS Command Injection')</Description>
    <Severity>High</Severity>
    <File>File 1</File>
    <Code>$tainted = `cat /tmp/tainted.txt`;

$sanitized = filter_var($tainted, FILTER_SANITIZE_EMAIL);
if (filter_var($sanitized, FILTER_VALIDATE_EMAIL))
  $tainted = $sanitized ;
else
  $tainted = """" ;

$query = ""ls ' $tainted '"";


$ret = system($query);</Code>
    <Justification>The code is vulnerable to command injection because it uses backticks to execute an external command (`cat /tmp/tainted.txt`) and then incorporates the result into another command executed by `system()`. While the code attempts to sanitize the input using `filter_var` with `FILTER_SANITIZE_EMAIL` and `FILTER_VALIDATE_EMAIL`, this is insufficient to prevent command injection. An attacker can still inject arbitrary commands by crafting input that bypasses the email validation but contains malicious shell metacharacters.  Even if the email is validated, the ls command can still be exploited. The use of system() is unsafe with user controlled input.</Justification>
  </Issue>
  <Issue>
    <Type>Security</Type>
    <Weakness>CWE-477</Weakness>
    <Description>Use of Obsolete Function</Description>
    <Severity>Low</Severity>
    <File>File 1</File>
    <Code>$tainted = `cat /tmp/tainted.txt`;</Code>
    <Justification>The code uses backticks `` for command execution, which is an older, less readable, and sometimes less secure way to execute shell commands in PHP compared to functions like `shell_exec()` or `proc_open()`.  While not directly exploitable, the use of backticks suggests the code may not be actively maintained or reviewed for modern security practices. It's better practice to use shell_exec for command execution.</Justification>
  </Issue>
</Issues>
```"
CWE-79,src/CWE_79__proc_open__func_FILTER-VALIDATION-email_filter__Use_untrusted_data-body.php,"<!-- 
Unsafe sample
input : use proc_open to read /tmp/tainted.txt
Flushes content of $sanitized if the filter email_filter is not applied
File : use of untrusted data in the body
-->

<!--Copyright 2015 Bertrand STIVALET 

Permission is hereby granted, without written agreement or royalty fee, to

use, copy, modify, and distribute this software and its documentation for

any purpose, provided that the above copyright notice and the following

three paragraphs appear in all copies of this software.


IN NO EVENT SHALL AUTHORS BE LIABLE TO ANY PARTY FOR DIRECT,

INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES ARISING OUT OF THE 

USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF AUTHORS HAVE

BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.


AUTHORS SPECIFICALLY DISCLAIM ANY WARRANTIES INCLUDING, BUT NOT

LIMITED TO THE IMPLIED WARRANTIES OF MERCHANTABILITY, FITNESS FOR A

PARTICULAR PURPOSE, AND NON-INFRINGEMENT.


THE SOFTWARE IS PROVIDED ON AN ""AS-IS"" BASIS AND AUTHORS HAVE NO

OBLIGATION TO PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR

MODIFICATIONS.-->


<!DOCTYPE html>
<html>
<head/>
<body>
<?php
$descriptorspec = array(
  0 => array(""pipe"", ""r""),
  1 => array(""pipe"", ""w""),
  2 => array(""file"", ""/tmp/error-output.txt"", ""a"")
  );
$cwd = '/tmp';
$process = proc_open('more /tmp/tainted.txt', $descriptorspec, $pipes, $cwd, NULL);
if (is_resource($process)) {
  fclose($pipes[0]);
  $tainted = stream_get_contents($pipes[1]);
  fclose($pipes[1]);
  $return_value = proc_close($process);
}

if (filter_var($sanitized, FILTER_VALIDATE_EMAIL))
  $tainted = $sanitized ;
else
  $tainted = """" ;


echo $tainted ;
?>
<h1>Hello World!</h1>
</body>
</html>
",echo $tainted ;,True,True,echo $tainted ;,"```xml
<Issues>
  <Issue>
    <Type>Security</Type>
    <Weakness>CWE-79</Weakness>
    <Description>Improper Neutralization of Input During Web Page Generation ('Cross-site Scripting')</Description>
    <Severity>Medium</Severity>
    <File>File 1</File>
    <Code>echo $tainted ;</Code>
    <Justification>The variable $tainted, which originates from an external source (/tmp/tainted.txt), is directly echoed into the HTML output without any sanitization or encoding. This could allow an attacker to inject malicious scripts into the web page, leading to Cross-Site Scripting (XSS).</Justification>
  </Issue>
  <Issue>
    <Type>Security</Type>
    <Weakness>CWE-22</Weakness>
    <Description>Improper Limitation of a Pathname to a Restricted Directory ('Path Traversal')</Description>
    <Severity>Medium</Severity>
    <File>File 1</File>
    <Code>$process = proc_open('more /tmp/tainted.txt', $descriptorspec, $pipes, $cwd, NULL);</Code>
    <Justification>The code directly reads from '/tmp/tainted.txt' using proc_open.  While the code itself isn't directly taking user input to construct this path, the fact that it's reading from a file in /tmp which could be created or modified by an attacker is a potential path traversal risk. An attacker could potentially place a file with a malicious name containing path traversal sequences in /tmp, which the code would then read and process, potentially leading to unintended file access or execution.</Justification>
  </Issue>
  <Issue>
    <Type>Reliability</Type>
    <Weakness>CWE-252</Weakness>
    <Description>Unchecked Return Value</Description>
    <Severity>Low</Severity>
    <File>File 1</File>
    <Code>fclose($pipes[0]);
  $tainted = stream_get_contents($pipes[1]);
  fclose($pipes[1]);
  $return_value = proc_close($process);</Code>
    <Justification>The code does not check the return values of fclose, stream_get_contents or proc_close. If any of these functions fail, the program might continue execution with incorrect data or an unclosed resource, potentially leading to unexpected behavior or resource exhaustion.</Justification>
  </Issue>
  <Issue>
    <Type>Reliability</Type>
    <Weakness>CWE-703</Weakness>
    <Description>Improper Check or Handling of Exceptional Conditions</Description>
    <Severity>Low</Severity>
    <File>File 1</File>
    <Code>if (is_resource($process)) {
  fclose($pipes[0]);
  $tainted = stream_get_contents($pipes[1]);
  fclose($pipes[1]);
  $return_value = proc_close($process);
}</Code>
    <Justification>The code checks if $process is a resource but doesn't handle cases where stream_get_contents fails or returns false. It should check for errors during stream_get_contents to ensure that the $tainted variable contains valid data.</Justification>
  </Issue>
  <Issue>
    <Type>Security</Type>
    <Weakness>CWE-571</Weakness>
    <Description>Expression is Always True</Description>
    <Severity>Low</Severity>
    <File>File 1</File>
    <Code>if (filter_var($sanitized, FILTER_VALIDATE_EMAIL))
  $tainted = $sanitized ;
else
  $tainted = """" ;</Code>
    <Justification>The code attempts to validate `$sanitized` as an email, but then overwrites `$tainted` with either the (presumably safe) `$sanitized` or an empty string. Since `$tainted` is then echoed, this effectively bypasses any filtering performed earlier, negating the attempted protection. If `$sanitized` is not set it will cause an error. The fact that `$sanitized` is not set anywhere in the code makes the validation pointless.</Justification>
  </Issue>
</Issues>
```"
CWE-79,src/CWE_79__fopen__func_htmlspecialchars__Use_untrusted_data_attribute-unquoted_Attr.php,"<!-- 
Unsafe sample
input : use fopen to read /tmp/tainted.txt and put the first line in $tainted
sanitize : use of the function htmlspecialchars. Sanitizes the query but has a high chance to produce unexpected results
File : use of untrusted data in a unquoted attribute
-->

<!--Copyright 2015 Bertrand STIVALET 

Permission is hereby granted, without written agreement or royalty fee, to

use, copy, modify, and distribute this software and its documentation for

any purpose, provided that the above copyright notice and the following

three paragraphs appear in all copies of this software.


IN NO EVENT SHALL AUTHORS BE LIABLE TO ANY PARTY FOR DIRECT,

INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES ARISING OUT OF THE 

USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF AUTHORS HAVE

BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.


AUTHORS SPECIFICALLY DISCLAIM ANY WARRANTIES INCLUDING, BUT NOT

LIMITED TO THE IMPLIED WARRANTIES OF MERCHANTABILITY, FITNESS FOR A

PARTICULAR PURPOSE, AND NON-INFRINGEMENT.


THE SOFTWARE IS PROVIDED ON AN ""AS-IS"" BASIS AND AUTHORS HAVE NO

OBLIGATION TO PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR

MODIFICATIONS.-->


<!DOCTYPE html>
<html>
<head/>
<body>
<?php
$handle = @fopen(""/tmp/tainted.txt"", ""r"");

if ($handle) {
  if(($tainted = fgets($handle, 4096)) == false) {
    $tainted = """";
  }
  fclose($handle);
} else {
  $tainted = """";
}

$tainted = htmlspecialchars($tainted, ENT_QUOTES);


echo ""<div id="". $tainted ."">content</div>"" ;
?>
<h1>Hello World!</h1>
</body>
</html>","echo ""<div id="". $tainted ."">content</div>"" ;",True,True,"$tainted = htmlspecialchars($tainted, ENT_QUOTES);


echo ""<div id="". $tainted ."">content</div>"" ;","```xml
<Issues>
  <Issue>
    <Type>Security</Type>
    <Weakness>CWE-79</Weakness>
    <Description>Improper Neutralization of Input During Web Page Generation ('Cross-site Scripting')</Description>
    <Severity>Medium</Severity>
    <File>File 1</File>
    <Code>$tainted = htmlspecialchars($tainted, ENT_QUOTES);


echo ""&lt;div id="". $tainted ."">content&lt;/div>"" ;</Code>
    <Justification>The code uses htmlspecialchars to sanitize the input, but still uses it in an HTML attribute. While htmlspecialchars encodes characters to prevent script execution in the HTML body, it might not be sufficient to prevent XSS in HTML attributes, especially when combined with certain characters or contexts. Using untrusted data in HTML attributes without proper escaping can still lead to XSS vulnerabilities.</Justification>
  </Issue>
  <Issue>
    <Type>Reliability</Type>
    <Weakness>CWE-252</Weakness>
    <Description>Unchecked Return Value</Description>
    <Severity>Low</Severity>
    <File>File 1</File>
    <Code>if(($tainted = fgets($handle, 4096)) == false) {
    $tainted = """";
  }</Code>
    <Justification>The code checks if fgets returns false, but it does not check for other possible errors that fgets may return. Not checking the return value of functions can prevent the detection of unexpected states and conditions.</Justification>
  </Issue>
  <Issue>
    <Type>Reliability</Type>
    <Weakness>CWE-391</Weakness>
    <Description>Unchecked Error Condition</Description>
    <Severity>Low</Severity>
    <File>File 1</File>
    <Code>if ($handle) {
  if(($tainted = fgets($handle, 4096)) == false) {
    $tainted = """";
  }
  fclose($handle);
} else {
  $tainted = """";
}</Code>
    <Justification>The code checks if fopen returns a valid file handle, but it does not handle any error that could occur during the fclose operation. Ignoring exceptions and other error conditions may allow an attacker to induce unexpected behavior unnoticed.</Justification>
  </Issue>
  <Issue>
    <Type>Security</Type>
    <Weakness>CWE-477</Weakness>
    <Description>Use of Obsolete Function</Description>
    <Severity>Low</Severity>
    <File>File 1</File>
    <Code>$tainted = htmlspecialchars($tainted, ENT_QUOTES);</Code>
    <Justification>htmlspecialchars might be considered obsolete in certain contexts as it may not provide complete protection against all XSS vectors, especially in complex scenarios. Context-aware output encoding is generally recommended for better security.</Justification>
  </Issue>
  <Issue>
    <Type>Security</Type>
    <Weakness>CWE-22</Weakness>
    <Description>Improper Limitation of a Pathname to a Restricted Directory ('Path Traversal')</Description>
    <Severity>Medium</Severity>
    <File>File 1</File>
    <Code>$handle = @fopen(""/tmp/tainted.txt"", ""r"");</Code>
    <Justification>The code reads from a file with a fixed path. If an attacker can control the contents of /tmp/tainted.txt, they could potentially inject malicious data. While this specific instance doesn't involve user-supplied path traversal, the reliance on a file with potentially modifiable content introduces a risk.</Justification>
  </Issue>
</Issues>
```"
CWE-89,src/CWE_89__exec__func_mysql_real_escape_string__multiple_select-interpretation.php,"<?php







$script = ""/tmp/tainted.php"";
exec($script, $result, $return);

$tainted = $result[0];

$tainted = mysql_real_escape_string($tainted);

$query = ""SELECT * FROM COURSE c WHERE c.id IN (SELECT idcourse FROM REGISTRATION WHERE idstudent= $tainted )"";


$conn = mysql_connect('localhost', 'mysql_user', 'mysql_password'); 
mysql_select_db('dbname') ;
echo ""query : "". $query .""<br /><br />"" ;

$res = mysql_query($query); 

while($data =mysql_fetch_array($res)){
print_r($data) ;
echo ""<br />"" ;
} 
mysql_close($conn);

?>","$conn = mysql_connect('localhost', 'mysql_user', 'mysql_password'); ",True,True,"$tainted = $result[0];

$tainted = mysql_real_escape_string($tainted);

$query = ""SELECT * FROM COURSE c WHERE c.id IN (SELECT idcourse FROM REGISTRATION WHERE idstudent= $tainted )"";","```xml
<Issues>
  <Issue>
    <Type>Security</Type>
    <Weakness>CWE-89</Weakness>
    <Description>Improper Neutralization of Special Elements used in an SQL Command ('SQL Injection')</Description>
    <Severity>High</Severity>
    <File>File 1</File>
    <Code>$tainted = $result[0];

$tainted = mysql_real_escape_string($tainted);

$query = ""SELECT * FROM COURSE c WHERE c.id IN (SELECT idcourse FROM REGISTRATION WHERE idstudent= $tainted )"";</Code>
    <Justification>Even after using mysql_real_escape_string, the $tainted variable is directly embedded into the SQL query. While mysql_real_escape_string mitigates some forms of SQL injection, it's not a foolproof solution.  A more robust approach would involve using prepared statements with bound parameters to ensure that the input is treated as data and not executable code.</Justification>
  </Issue>
  <Issue>
    <Type>Security</Type>
    <Weakness>CWE-477</Weakness>
    <Description>Use of Obsolete Function</Description>
    <Severity>Low</Severity>
    <File>File 1</File>
    <Code>$conn = mysql_connect('localhost', 'mysql_user', 'mysql_password'); 
mysql_select_db('dbname') ;</Code>
    <Justification>The mysql_* functions are deprecated and should not be used.  They are no longer maintained and are inherently insecure.  mysqli or PDO should be used instead.</Justification>
  </Issue>
  <Issue>
    <Type>Reliability</Type>
    <Weakness>CWE-252</Weakness>
    <Description>Unchecked Return Value</Description>
    <Severity>Medium</Severity>
    <File>File 1</File>
    <Code>$conn = mysql_connect('localhost', 'mysql_user', 'mysql_password'); 
mysql_select_db('dbname') ;
echo ""query : "". $query .""&lt;br /&gt;&lt;br /&gt;"" ;

$res = mysql_query($query); </Code>
    <Justification>The code does not check the return values of `mysql_connect` and `mysql_query`. If these functions fail (e.g., due to incorrect credentials or a malformed query), the script will continue to execute, potentially leading to errors or unexpected behavior.  The return value should be checked and appropriate error handling implemented.</Justification>
  </Issue>
  <Issue>
    <Type>Security</Type>
    <Weakness>CWE-798</Weakness>
    <Description>Use of Hard-coded Credentials</Description>
    <Severity>Critical</Severity>
    <File>File 1</File>
    <Code>$conn = mysql_connect('localhost', 'mysql_user', 'mysql_password'); </Code>
    <Justification>The code uses hard-coded credentials ('mysql_user', 'mysql_password') for database access. This is a major security vulnerability, as anyone with access to the source code can gain access to the database. Credentials should be stored securely and retrieved using environment variables or a configuration file.</Justification>
  </Issue>
</Issues>
```"
CWE-90,src/CWE_90__GET__func_FILTER-VALIDATION-email_filter__userByCN-sprintf_%s_simple_quote.php,"<?php







$tainted = $_GET['UserData'];

if (filter_var($sanitized, FILTER_VALIDATE_EMAIL))
  $tainted = $sanitized ;
else
  $tainted = """" ;

$query = sprintf(""(&(objectCategory=person)(objectClass=user)(cn='%s'))"", $tainted);


$ds=ldap_connect(""localhost""); 
$r=ldap_bind($ds);
$sr=ldap_search($ds,""o=My Company, c=US"", $query);  
ldap_close($ds);

?>","$ds=ldap_connect(""localhost"");",True,True,"$tainted = $_GET['UserData'];

if (filter_var($sanitized, FILTER_VALIDATE_EMAIL))
  $tainted = $sanitized ;
else
  $tainted = """" ;

$query = sprintf(""(&(objectCategory=person)(objectClass=user)(cn='%s'))"", $tainted);","```xml
<Issues>
  <Issue>
    <Type>Security</Type>
    <Weakness>CWE-90</Weakness>
    <Description>Improper Neutralization of Special Elements used in an LDAP Query ('LDAP Injection')</Description>
    <Severity>High</Severity>
    <File>File 1</File>
    <Code>$tainted = $_GET['UserData'];

if (filter_var($sanitized, FILTER_VALIDATE_EMAIL))
  $tainted = $sanitized ;
else
  $tainted = """" ;

$query = sprintf(""(&(objectCategory=person)(objectClass=user)(cn='%s'))"", $tainted);</Code>
    <Justification>The code is vulnerable to LDAP injection. The $tainted variable, which is derived from user input ($_GET['UserData']), is directly incorporated into an LDAP query without proper sanitization. Although there is an attempt to filter the variable as an email, this does not prevent other characters that are harmful to LDAP queries. An attacker could manipulate the input to inject arbitrary LDAP commands, potentially bypassing authentication or retrieving sensitive information.</Justification>
  </Issue>
  <Issue>
    <Type>Reliability</Type>
    <Weakness>CWE-252</Weakness>
    <Description>Unchecked Return Value</Description>
    <Severity>Medium</Severity>
    <File>File 1</File>
    <Code>$ds=ldap_connect(""localhost""); 
$r=ldap_bind($ds);
$sr=ldap_search($ds,""o=My Company, c=US"", $query);  
ldap_close($ds);</Code>
    <Justification>The code does not check the return values of ldap_connect, ldap_bind, and ldap_search. If any of these functions fail, the script will continue to execute, potentially leading to unexpected behavior or errors. For example, if ldap_connect fails, $ds will be false and the subsequent calls will cause an error.</Justification>
  </Issue>
</Issues>
```"
CWE-91,src/CWE_91__backticks__func_FILTER-VALIDATION-email_filter__username_text-concatenation_simple_quote.php,"<?php







$tainted = `cat /tmp/tainted.txt`;

if (filter_var($sanitized, FILTER_VALIDATE_EMAIL))
  $tainted = $sanitized ;
else
  $tainted = """" ;

$query = ""


$xml = simplexml_load_file(""users.xml"");
echo ""query : "". $query .""<br /><br />"" ;

$res=$xml->xpath($query);
print_r($res);
echo ""<br />"" ;

?>","$xml = simplexml_load_file(""users.xml"");",False,False,,"```xml
<Issues>
  <Issue>
    <Type>Security</Type>
    <Weakness>CWE-78</Weakness>
    <Description>Improper Neutralization of Special Elements used in a Command ('Command Injection')</Description>
    <Severity>High</Severity>
    <File>File 1</File>
    <Code>$tainted = `cat /tmp/tainted.txt`;</Code>
    <Justification>The code uses backticks to execute a shell command with user-controlled input (potentially from /tmp/tainted.txt), which is a command injection vulnerability.</Justification>
  </Issue>
  <Issue>
    <Type>Security</Type>
    <Weakness>CWE-643</Weakness>
    <Description>Improper Neutralization of Data within XPath Expressions ('XPath Injection')</Description>
    <Severity>High</Severity>
    <File>File 1</File>
    <Code>$query = ""
"";

$xml = simplexml_load_file(""users.xml"");
echo ""query : "". $query .""&lt;br /&gt;&lt;br /&gt;"" ;

$res=$xml->xpath($query);</Code>
    <Justification>The code constructs an XPath query using the `$tainted` variable without proper sanitization. If `$tainted` contains malicious XPath syntax, it could lead to XPath injection.</Justification>
  </Issue>
  <Issue>
    <Type>Reliability</Type>
    <Weakness>CWE-252</Weakness>
    <Description>Unchecked Return Value</Description>
    <Severity>Medium</Severity>
    <File>File 1</File>
    <Code>$xml = simplexml_load_file(""users.xml"");</Code>
    <Justification>The return value of `simplexml_load_file` is not checked. If the file ""users.xml"" does not exist or cannot be parsed, the function will return `false`, and subsequent operations on `$xml` will cause errors.</Justification>
  </Issue>
  <Issue>
    <Type>Security</Type>
    <Weakness>CWE-79</Weakness>
    <Description>Improper Neutralization of Input During Web Page Generation ('Cross-site Scripting')</Description>
    <Severity>Medium</Severity>
    <File>File 1</File>
    <Code>echo ""query : "". $query .""&lt;br /&gt;&lt;br /&gt;"" ;</Code>
    <Justification>The code echoes the `$query` variable directly to the output without proper encoding. If `$query` contains HTML or JavaScript, it could lead to Cross-Site Scripting (XSS).</Justification>
  </Issue>
  <Issue>
    <Type>Reliability</Type>
    <Weakness>CWE-703</Weakness>
    <Description>Improper Check or Handling of Exceptional Conditions</Description>
    <Severity>Low</Severity>
    <File>File 1</File>
    <Code>if (filter_var($sanitized, FILTER_VALIDATE_EMAIL))
  $tainted = $sanitized ;
else
  $tainted = """" ;</Code>
    <Justification>The code attempts to validate `$sanitized` as an email, but does not handle the case where `$sanitized` is not defined at all. This could lead to unexpected behavior or errors if `$sanitized` is missing.</Justification>
  </Issue>
</Issues>
```"
CWE-89,src/CWE_89__array-GET__func_FILTER-CLEANING-full_special_chars_filter__select_from-interpretation_simple_quote.php,"<?php







$array = array();
$array[] = 'safe' ;
$array[] = $_GET['userData'] ;
$array[] = 'safe' ;
$tainted = $array[1] ;

$sanitized = filter_var($tainted, FILTER_SANITIZE_FULL_SPECIAL_CHARS);
  $tainted = $sanitized ;
     

$query = ""SELECT * FROM ' $tainted '"";


$conn = mysql_connect('localhost', 'mysql_user', 'mysql_password'); 
mysql_select_db('dbname') ;
echo ""query : "". $query .""<br /><br />"" ;

$res = mysql_query($query); 

while($data =mysql_fetch_array($res)){
print_r($data) ;
echo ""<br />"" ;
} 
mysql_close($conn);

?>","$conn = mysql_connect('localhost', 'mysql_user', 'mysql_password'); ",True,False,"$query = ""SELECT * FROM ' $tainted '"";","```xml
<Issues>
  <Issue>
    <Type>Security</Type>
    <Weakness>CWE-89</Weakness>
    <Description>Improper Neutralization of Special Elements used in an SQL Command ('SQL Injection')</Description>
    <Severity>Critical</Severity>
    <File>File 1</File>
    <Code>$query = ""SELECT * FROM ' $tainted '"";</Code>
    <Justification>The code directly incorporates unsanitized user input ($tainted) into an SQL query. Even though the input is sanitized using FILTER_SANITIZE_FULL_SPECIAL_CHARS, this is insufficient to prevent SQL injection because it only encodes characters and does not prevent malicious SQL code from being injected. The entire tainted variable is used as the table name, which means encoding is irrelevant. An attacker could manipulate the table name, potentially leading to unauthorized data access or modification.</Justification>
  </Issue>
  <Issue>
    <Type>Security</Type>
    <Weakness>CWE-477</Weakness>
    <Description>Use of Obsolete Function</Description>
    <Severity>High</Severity>
    <File>File 1</File>
    <Code>$conn = mysql_connect('localhost', 'mysql_user', 'mysql_password'); 
mysql_select_db('dbname') ;
$res = mysql_query($query); 
mysql_close($conn);</Code>
    <Justification>The code uses the `mysql_connect`, `mysql_select_db`, and `mysql_query` functions, which are deprecated.  These functions are known to have security vulnerabilities and are no longer maintained, making the application susceptible to exploits.  The use of `mysql_*` functions is discouraged in favor of `mysqli_*` or PDO.</Justification>
  </Issue>
</Issues>
```"
CWE-89,src/CWE_89__object-Array__no_sanitizing__select_from-interpretation_simple_quote.php,"<?php







class Input{
  private $input;

  public function getInput(){
    return $this->input[1];
  }

  public  function __construct(){
    $this->input = array();
    $this->input[0]= 'safe' ;
    $this->input[1]= $_GET['UserData'] ;
    $this->input[2]= 'safe' ;
  }
}
$temp = new Input();
$tainted =  $temp->getInput();



$query = ""SELECT * FROM ' $tainted '"";


$conn = mysql_connect('localhost', 'mysql_user', 'mysql_password'); 
mysql_select_db('dbname') ;
echo ""query : "". $query .""<br /><br />"" ;

$res = mysql_query($query); 

while($data =mysql_fetch_array($res)){
print_r($data) ;
echo ""<br />"" ;
} 
mysql_close($conn);

?>","$conn = mysql_connect('localhost', 'mysql_user', 'mysql_password'); ",True,False,"$query = ""SELECT * FROM ' $tainted '"";","```xml
<Issues>
  <Issue>
    <Type>Security</Type>
    <Weakness>CWE-89</Weakness>
    <Description>Improper Neutralization of Special Elements used in an SQL Command ('SQL Injection')</Description>
    <Severity>High</Severity>
    <File>File 1</File>
    <Code>$query = ""SELECT * FROM ' $tainted '"";</Code>
    <Justification>The code constructs an SQL query by directly embedding user-controlled data ($tainted) into the query string without proper sanitization or parameterization. This allows an attacker to inject arbitrary SQL code, potentially leading to data breaches or other malicious actions.</Justification>
  </Issue>
  <Issue>
    <Type>Security</Type>
    <Weakness>CWE-477</Weakness>
    <Description>Use of Obsolete Function</Description>
    <Severity>Low</Severity>
    <File>File 1</File>
    <Code>$conn = mysql_connect('localhost', 'mysql_user', 'mysql_password'); 
mysql_select_db('dbname') ;
$res = mysql_query($query); </Code>
    <Justification>The code uses the `mysql_connect`, `mysql_select_db`, and `mysql_query` functions, which are deprecated and considered obsolete. These functions are vulnerable to security issues and should be replaced with the more secure `mysqli` or `PDO` extensions.</Justification>
  </Issue>
  <Issue>
    <Type>Security</Type>
    <Weakness>CWE-798</Weakness>
    <Description>Use of Hard-coded Credentials</Description>
    <Severity>Critical</Severity>
    <File>File 1</File>
    <Code>$conn = mysql_connect('localhost', 'mysql_user', 'mysql_password');</Code>
    <Justification>The code includes hard-coded database credentials (`mysql_user`, `mysql_password`). This poses a significant security risk, as anyone with access to the source code can gain unauthorized access to the database.</Justification>
  </Issue>
  <Issue>
    <Type>Reliability</Type>
    <Weakness>CWE-252</Weakness>
    <Description>Unchecked Return Value</Description>
    <Severity>Medium</Severity>
    <File>File 1</File>
    <Code>$res = mysql_query($query); </Code>
    <Justification>The code does not check the return value of `mysql_query`. If the query fails, `mysql_query` will return FALSE, but the code continues to use `$res` without checking, which may lead to unexpected behavior or errors. The return values of `mysql_connect` and `mysql_select_db` are also unchecked.</Justification>
  </Issue>
</Issues>
```"
CWE-89,src/CWE_89__unserialize__func_FILTER-VALIDATION-email_filter__select_from-concatenation_simple_quote.php,"<?php







$string = $_POST['UserData'] ;
$tainted = unserialize($string);
    

if (filter_var($sanitized, FILTER_VALIDATE_EMAIL))
  $tainted = $sanitized ;
else
  $tainted = """" ;

$query = ""SELECT * FROM '"". $tainted . ""'"";


$conn = mysql_connect('localhost', 'mysql_user', 'mysql_password'); 
mysql_select_db('dbname') ;
echo ""query : "". $query .""<br /><br />"" ;

$res = mysql_query($query); 

while($data =mysql_fetch_array($res)){
print_r($data) ;
echo ""<br />"" ;
} 
mysql_close($conn);

?>","$conn = mysql_connect('localhost', 'mysql_user', 'mysql_password'); ",True,False,"$query = ""SELECT * FROM '"". $tainted . ""'"";","```xml
<Issues>
  <Issue>
    <Type>Security</Type>
    <Weakness>CWE-502</Weakness>
    <Description>Deserialization of Untrusted Data</Description>
    <Severity>High</Severity>
    <File>File 1</File>
    <Code>$string = $_POST['UserData'] ;
$tainted = unserialize($string);</Code>
    <Justification>The code uses unserialize() on user-controlled data ($_POST['UserData']), which can lead to arbitrary code execution if the serialized data is malicious.</Justification>
  </Issue>
  <Issue>
    <Type>Security</Type>
    <Weakness>CWE-89</Weakness>
    <Description>Improper Neutralization of Special Elements used in an SQL Command ('SQL Injection')</Description>
    <Severity>High</Severity>
    <File>File 1</File>
    <Code>$query = ""SELECT * FROM '"". $tainted . ""'"";</Code>
    <Justification>The code constructs an SQL query by directly concatenating the $tainted variable, which originates from user input, without proper sanitization or escaping. This makes the application vulnerable to SQL injection attacks.</Justification>
  </Issue>
  <Issue>
    <Type>Reliability</Type>
    <Weakness>CWE-252</Weakness>
    <Description>Unchecked Return Value</Description>
    <Severity>Medium</Severity>
    <File>File 1</File>
    <Code>$conn = mysql_connect('localhost', 'mysql_user', 'mysql_password'); 
mysql_select_db('dbname') ;
echo ""query : "". $query .""&lt;br /&gt;&lt;br /&gt;"" ;

$res = mysql_query($query);</Code>
    <Justification>The code does not check the return values of mysql_connect() and mysql_query(). If these functions fail (e.g., due to incorrect credentials or an invalid query), the script will continue to execute, potentially leading to unexpected behavior or errors.</Justification>
  </Issue>
  <Issue>
    <Type>Security</Type>
    <Weakness>CWE-424</Weakness>
    <Description>Improper Protection of Alternate Path</Description>
    <Severity>Medium</Severity>
    <File>File 1</File>
    <Code>if (filter_var($sanitized, FILTER_VALIDATE_EMAIL))
  $tainted = $sanitized ;
else
  $tainted = """" ;</Code>
    <Justification>The code attempts to sanitize input using filter_var with FILTER_VALIDATE_EMAIL but still uses the potentially tainted value after the else statement. If the validation fails, the $tainted variable is set to an empty string, but the SQL query will still execute with an empty table name, which could lead to unexpected behavior.</Justification>
  </Issue>
  <Issue>
    <Type>Maintainability</Type>
    <Weakness>CWE-478</Weakness>
    <Description>Missing Default Case in Switch Statement</Description>
    <Severity>Low</Severity>
    <File>File 1</File>
    <Code>if (filter_var($sanitized, FILTER_VALIDATE_EMAIL))
  $tainted = $sanitized ;
else
  $tainted = """" ;</Code>
    <Justification>The `if...else` block is used like a switch statement but is missing a default case (or a more robust fallback). While currently setting `$tainted = """"` might seem sufficient, a more complex logic might benefit from a clearly defined default behavior for maintainability and future modifications.</Justification>
  </Issue>
  <Issue>
    <Type>Security</Type>
    <Weakness>CWE-477</Weakness>
    <Description>Use of Obsolete Function</Description>
    <Severity>High</Severity>
    <File>File 1</File>
    <Code>$conn = mysql_connect('localhost', 'mysql_user', 'mysql_password'); 
mysql_select_db('dbname') ;
echo ""query : "". $query .""&lt;br /&gt;&lt;br /&gt;"" ;

$res = mysql_query($query);</Code>
    <Justification>The code uses the `mysql_connect`, `mysql_select_db`, and `mysql_query` functions, which are deprecated.  These functions are known to have security vulnerabilities and have been removed from newer versions of PHP.  The code should be updated to use `mysqli` or `PDO` instead.</Justification>
  </Issue>
</Issues>
```"
CWE-79,src/CWE_79__popen__no_sanitizing__Unsafe_use_untrusted_data-script.php,"<!-- 
Unsafe sample
input : Uses popen to read the file /tmp/tainted.txt using cat command
sanitize : none
File : unsafe, use of untrusted data in a script
-->

<!--Copyright 2015 Bertrand STIVALET 

Permission is hereby granted, without written agreement or royalty fee, to

use, copy, modify, and distribute this software and its documentation for

any purpose, provided that the above copyright notice and the following

three paragraphs appear in all copies of this software.


IN NO EVENT SHALL AUTHORS BE LIABLE TO ANY PARTY FOR DIRECT,

INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES ARISING OUT OF THE 

USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF AUTHORS HAVE

BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.


AUTHORS SPECIFICALLY DISCLAIM ANY WARRANTIES INCLUDING, BUT NOT

LIMITED TO THE IMPLIED WARRANTIES OF MERCHANTABILITY, FITNESS FOR A

PARTICULAR PURPOSE, AND NON-INFRINGEMENT.


THE SOFTWARE IS PROVIDED ON AN ""AS-IS"" BASIS AND AUTHORS HAVE NO

OBLIGATION TO PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR

MODIFICATIONS.-->


<!DOCTYPE html>
<html>
<head>
<script>
<?php
$handle = popen('/bin/cat /tmp/tainted.txt', 'r');
$tainted = fread($handle, 4096);
pclose($handle);




echo $tainted ;
?>
</script>
</head>
<body onload=""xss()"">
<h1>Hello World!</h1>
</body>
</html>",echo $tainted ;,True,True,echo $tainted ;,"```xml
<Issues>
  <Issue>
    <Type>Security</Type>
    <Weakness>CWE-79</Weakness>
    <Description>Improper Neutralization of Input During Web Page Generation ('Cross-site Scripting')</Description>
    <Severity>High</Severity>
    <File>File 1</File>
    <Code>echo $tainted ;</Code>
    <Justification>The code reads data from a file and directly echoes it into the HTML output. If the file contains malicious JavaScript, it will be executed in the user's browser, leading to XSS.</Justification>
  </Issue>
  <Issue>
    <Type>Security</Type>
    <Weakness>CWE-78</Weakness>
    <Description>Improper Neutralization of Special Elements used in an OS Command ('OS Command Injection')</Description>
    <Severity>High</Severity>
    <File>File 1</File>
    <Code>$handle = popen('/bin/cat /tmp/tainted.txt', 'r');</Code>
    <Justification>The code uses popen to execute a command. If the filename ""/tmp/tainted.txt"" was derived from an external source, this could lead to command injection.</Justification>
  </Issue>
  <Issue>
    <Type>Reliability</Type>
    <Weakness>CWE-252</Weakness>
    <Description>Unchecked Return Value</Description>
    <Severity>Medium</Severity>
    <File>File 1</File>
    <Code>$handle = popen('/bin/cat /tmp/tainted.txt', 'r');
$tainted = fread($handle, 4096);
pclose($handle);</Code>
    <Justification>The code does not check the return values of `popen`, `fread`, and `pclose`. If any of these functions fail, the program might continue execution with invalid data or resources, leading to unpredictable behavior.</Justification>
  </Issue>
  <Issue>
    <Type>Performance Efficiency</Type>
    <Weakness>CWE-772</Weakness>
    <Description>Missing Release of Resource after Effective Lifetime</Description>
    <Severity>Medium</Severity>
    <File>File 1</File>
    <Code>$handle = popen('/bin/cat /tmp/tainted.txt', 'r');
$tainted = fread($handle, 4096);
pclose($handle);</Code>
    <Justification>Although `pclose` is called, failing to check the return value and handle errors could lead to resource leaks if `pclose` fails. The resource is the file handle.</Justification>
  </Issue>
</Issues>
```"
CWE-78,src/CWE_78__object-classicGet__func_FILTER-CLEANING-full_special_chars_filter__ls-interpretation_simple_quote.php,"<?php







class Input{
  private $input;

  public function getInput(){
    return $this->input;
  }

  public  function __construct(){
   $this->input = $_GET['UserData'] ;
  }
}
$temp = new Input();
$tainted =  $temp->getInput();

$sanitized = filter_var($tainted, FILTER_SANITIZE_FULL_SPECIAL_CHARS);
  $tainted = $sanitized ;
     

$query = ""ls ' $tainted '"";


$ret = system($query);


?>",$ret = system($query);,True,True,"$query = ""ls ' $tainted '"";

$ret = system($query);","```xml
<Issues>
  <Issue>
    <Type>Security</Type>
    <Weakness>CWE-78</Weakness>
    <Description>Improper Neutralization of Special Elements used in a Command ('Command Injection')</Description>
    <Severity>High</Severity>
    <File>File 1</File>
    <Code>$query = ""ls ' $tainted '"";

$ret = system($query);</Code>
    <Justification>The code constructs an OS command using externally-influenced input ($tainted) without proper neutralization of special elements. This can lead to command injection vulnerabilities, allowing attackers to execute arbitrary commands on the system.</Justification>
  </Issue>
</Issues>
```"
CWE-79,src/CWE_79__array-GET__func_FILTER-CLEANING-number_int_filter__Unsafe_use_untrusted_data-style.php,"<!-- 
Unsafe sample
input : get the $_GET['userData'] in an array
Uses a number_int_filter via filter_var function
File : unsafe, use of untrusted data in CSS
-->

<!--Copyright 2015 Bertrand STIVALET 

Permission is hereby granted, without written agreement or royalty fee, to

use, copy, modify, and distribute this software and its documentation for

any purpose, provided that the above copyright notice and the following

three paragraphs appear in all copies of this software.


IN NO EVENT SHALL AUTHORS BE LIABLE TO ANY PARTY FOR DIRECT,

INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES ARISING OUT OF THE 

USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF AUTHORS HAVE

BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.


AUTHORS SPECIFICALLY DISCLAIM ANY WARRANTIES INCLUDING, BUT NOT

LIMITED TO THE IMPLIED WARRANTIES OF MERCHANTABILITY, FITNESS FOR A

PARTICULAR PURPOSE, AND NON-INFRINGEMENT.


THE SOFTWARE IS PROVIDED ON AN ""AS-IS"" BASIS AND AUTHORS HAVE NO

OBLIGATION TO PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR

MODIFICATIONS.-->


<!DOCTYPE html>
<html>
<head>
<style>
<?php
$array = array();
$array[] = 'safe' ;
$array[] = $_GET['userData'] ;
$array[] = 'safe' ;
$tainted = $array[1] ;

$sanitized = filter_var($tainted, FILTER_SANITIZE_NUMBER_INT);
if (filter_var($sanitized, FILTER_VALIDATE_INT))
  $tainted = $sanitized ;
else
  $tainted = """" ;


echo $tainted ;
?>
</style>
</head>
<body>
<h1>Hello World!</h1>
</body>
</html>",echo $tainted ;,True,True,"$array = array();
$array[] = 'safe' ;
$array[] = $_GET['userData'] ;
$array[] = 'safe' ;
$tainted = $array[1] ;

$sanitized = filter_var($tainted, FILTER_SANITIZE_NUMBER_INT);
if (filter_var($sanitized, FILTER_VALIDATE_INT))
  $tainted = $sanitized ;
else
  $tainted = """" ;


echo $tainted ;","```xml
<Issues>
  <Issue>
    <Type>Security</Type>
    <Weakness>CWE-79</Weakness>
    <Description>Improper Neutralization of Input During Web Page Generation ('Cross-site Scripting')</Description>
    <Severity>Medium</Severity>
    <File>File 1</File>
    <Code>$array = array();
$array[] = 'safe' ;
$array[] = $_GET['userData'] ;
$array[] = 'safe' ;
$tainted = $array[1] ;

$sanitized = filter_var($tainted, FILTER_SANITIZE_NUMBER_INT);
if (filter_var($sanitized, FILTER_VALIDATE_INT))
  $tainted = $sanitized ;
else
  $tainted = """" ;


echo $tainted ;</Code>
    <Justification>The code retrieves user input from $_GET['userData'] and attempts to sanitize it using FILTER_SANITIZE_NUMBER_INT and FILTER_VALIDATE_INT. However, even if the input is validated as an integer, it's directly echoed into the CSS style section of the HTML page. This can still lead to XSS if the validated integer is used in a way that can inject malicious CSS (e.g., in a style attribute value), or if the validation is bypassed due to encoding issues or other vulnerabilities.</Justification>
  </Issue>
</Issues>
```"
CWE-90,src/CWE_90__object-indexArray__func_FILTER-CLEANING-email_filter__not_name-sprintf_%s_simple_quote.php,"<?php







class Input{
  private $input;

  public function getInput(){
    return $this->input['realOne'];
  }

  public  function __construct(){
    $this->input = array();
    $this->input['test']= 'safe' ;
    $this->input['realOne']= $_GET['UserData'] ;
    $this->input['trap']= 'safe' ;
  }
}
$temp = new Input();
$tainted =  $temp->getInput();

$sanitized = filter_var($tainted, FILTER_SANITIZE_EMAIL);
if (filter_var($sanitized, FILTER_VALIDATE_EMAIL))
  $tainted = $sanitized ;
else
  $tainted = """" ;

$query = sprintf(""!name='%s'"", $tainted);


$ds=ldap_connect(""localhost""); 
$r=ldap_bind($ds);
$sr=ldap_search($ds,""o=My Company, c=US"", $query);  
ldap_close($ds);

?>","$ds=ldap_connect(""localhost"");",True,True,"$query = sprintf(""!name='%s'"", $tainted);


$ds=ldap_connect(""localhost""); 
$r=ldap_bind($ds);
$sr=ldap_search($ds,""o=My Company, c=US"", $query);  
ldap_close($ds);","```xml
<Issues>
  <Issue>
    <Type>Security</Type>
    <Weakness>CWE-90</Weakness>
    <Description>Improper Neutralization of Special Elements used in an LDAP Query ('LDAP Injection')</Description>
    <Severity>High</Severity>
    <File>File 1</File>
    <Code>$query = sprintf(""!name='%s'"", $tainted);


$ds=ldap_connect(""localhost""); 
$r=ldap_bind($ds);
$sr=ldap_search($ds,""o=My Company, c=US"", $query);  
ldap_close($ds);</Code>
    <Justification>The code constructs an LDAP query using user-controlled input (`$tainted`) without proper neutralization of special elements. This can lead to LDAP injection vulnerabilities where an attacker can modify the LDAP query to bypass security restrictions or extract sensitive information.</Justification>
  </Issue>
</Issues>
```"
CWE-91,src/CWE_91__object-directGet__func_FILTER-VALIDATION-email_filter__username-concatenation_simple_quote.php,"<?php







class Input{
  public function getInput(){
    return $_GET['UserData'] ;
  }
}

$temp = new Input();
$tainted =  $temp->getInput();

if (filter_var($sanitized, FILTER_VALIDATE_EMAIL))
  $tainted = $sanitized ;
else
  $tainted = """" ;

$query = ""user[username='"". $tainted . ""']"";


$xml = simplexml_load_file(""users.xml"");
echo ""query : "". $query .""<br /><br />"" ;

$res=$xml->xpath($query);
print_r($res);
echo ""<br />"" ;

?>","$xml = simplexml_load_file(""users.xml"");",False,False,,"```xml
<Issues>
  <Issue>
    <Type>Security</Type>
    <Weakness>CWE-643</Weakness>
    <Description>Improper Neutralization of Data within XPath Expressions ('XPath Injection')</Description>
    <Severity>High</Severity>
    <File>File 1</File>
    <Code>$query = ""user[username='"". $tainted . ""']"";</Code>
    <Justification>The code constructs an XPath query by directly embedding user-controlled input ($tainted) without proper sanitization. This allows an attacker to inject malicious XPath expressions, potentially extracting sensitive data or manipulating the XML structure.</Justification>
  </Issue>
  <Issue>
    <Type>Security</Type>
    <Weakness>CWE-252</Weakness>
    <Description>Unchecked Return Value</Description>
    <Severity>Low</Severity>
    <File>File 1</File>
    <Code>if (filter_var($sanitized, FILTER_VALIDATE_EMAIL))
  $tainted = $sanitized ;
else
  $tainted = """" ;</Code>
    <Justification>The code uses filter_var, but doesn't check the return value to see if the filtering operation was succesful. An error may occur while filtering, and the code will continue to execute with potentially tainted data.</Justification>
  </Issue>
  <Issue>
    <Type>Reliability</Type>
    <Weakness>CWE-252</Weakness>
    <Description>Unchecked Return Value</Description>
    <Severity>Low</Severity>
    <File>File 1</File>
    <Code>if (filter_var($sanitized, FILTER_VALIDATE_EMAIL))
  $tainted = $sanitized ;
else
  $tainted = """" ;</Code>
    <Justification>The code uses filter_var, but doesn't check the return value to see if the filtering operation was succesful. An error may occur while filtering, and the code will continue to execute with potentially tainted data.</Justification>
  </Issue>
</Issues>
```"
CWE-91,src/CWE_91__object-Array__func_preg_match-no_filtering__username-sprintf_%s_simple_quote.php,"<?php







class Input{
  private $input;

  public function getInput(){
    return $this->input[1];
  }

  public  function __construct(){
    $this->input = array();
    $this->input[0]= 'safe' ;
    $this->input[1]= $_GET['UserData'] ;
    $this->input[2]= 'safe' ;
  }
}
$temp = new Input();
$tainted =  $temp->getInput();

$re = ""/^.*$/"";
if(preg_match($re, $tainted) == 1){
  $tainted = $tainted;
}
else{
  $tainted = """";
}

$query = sprintf(""user[username='%s']"", $tainted);


$xml = simplexml_load_file(""users.xml"");
echo ""query : "". $query .""<br /><br />"" ;

$res=$xml->xpath($query);
print_r($res);
echo ""<br />"" ;

?>","$xml = simplexml_load_file(""users.xml"");",True,False,$this->input[1]= $_GET['UserData'] ;,"```xml
<Issues>
  <Issue>
    <Type>Security</Type>
    <Weakness>CWE-91</Weakness>
    <Description>XML Injection (aka Blind XPath Injection)</Description>
    <Severity>High</Severity>
    <File>File 1</File>
    <Code>$this->input[1]= $_GET['UserData'] ;</Code>
    <Justification>The code retrieves user input from $_GET['UserData'] and stores it in $this->input[1]. This user-controlled input is later used in an XPath query without proper sanitization, leading to XML injection vulnerability.</Justification>
  </Issue>
  <Issue>
    <Type>Security</Type>
    <Weakness>CWE-643</Weakness>
    <Description>Improper Neutralization of Data within XPath Expressions ('XPath Injection')</Description>
    <Severity>High</Severity>
    <File>File 1</File>
    <Code>$tainted =  $temp->getInput();

$re = ""/^.*$/"";
if(preg_match($re, $tainted) == 1){
  $tainted = $tainted;
}
else{
  $tainted = """";
}

$query = sprintf(""user[username='%s']"", $tainted);


$xml = simplexml_load_file(""users.xml"");</Code>
    <Justification>The code constructs an XPath query using sprintf with user-controlled input ($tainted). Although there is a regex check, it is too permissive (""/^.*$/"") and does not provide any effective sanitization against XPath injection attacks. This allows an attacker to control the structure of the query and potentially extract sensitive information or manipulate the XML data.</Justification>
  </Issue>
</Issues>
```"
CWE-91,src/CWE_91__backticks__func_FILTER-CLEANING-email_filter__username_at-interpretation_simple_quote.php,"<?php







$tainted = `cat /tmp/tainted.txt`;

$sanitized = filter_var($tainted, FILTER_SANITIZE_EMAIL);
if (filter_var($sanitized, FILTER_VALIDATE_EMAIL))
  $tainted = $sanitized ;
else
  $tainted = """" ;

$query = ""


$xml = simplexml_load_file(""users.xml"");
echo ""query : "". $query .""<br /><br />"" ;

$res=$xml->xpath($query);
print_r($res);
echo ""<br />"" ;

?>","$xml = simplexml_load_file(""users.xml"");",False,False,,"```xml
<Issues>
  <Issue>
    <Type>Security</Type>
    <Weakness>CWE-77</Weakness>
    <Description>Improper Neutralization of Special Elements used in a Command ('Command Injection')</Description>
    <Severity>High</Severity>
    <File>File 1</File>
    <Code>$tainted = `cat /tmp/tainted.txt`;</Code>
    <Justification>The code uses backticks to execute a system command based on user-controlled input. This constitutes a command injection vulnerability. Specifically, the content of `/tmp/tainted.txt` is being used as part of the command to be executed. An attacker could modify this file to inject arbitrary commands into the system.</Justification>
  </Issue>
  <Issue>
    <Type>Security</Type>
    <Weakness>CWE-643</Weakness>
    <Description>Improper Neutralization of Data within XPath Expressions ('XPath Injection')</Description>
    <Severity>High</Severity>
    <File>File 1</File>
    <Code>$query = ""</Code>
    <Justification>The code constructs an XPath query using a variable, $tainted, which is derived from external input (a file). Even after sanitization attempts, the $tainted variable could still contain malicious XPath syntax that, when incorporated into the XPath query, could allow an attacker to extract sensitive data or manipulate the XML structure. The filter_var function with FILTER_SANITIZE_EMAIL is not sufficient to prevent XPath injection.</Justification>
  </Issue>
</Issues>
```"
CWE-79,src/CWE_79__unserialize__func_mysql_real_escape_string__Use_untrusted_data-div.php,"<!-- 
Unsafe sample
input : Get a serialize string in POST and unserialize it
SANITIZE : use of mysql_real_escape string
File : use of untrusted data in a div tag
-->

<!--Copyright 2015 Bertrand STIVALET 

Permission is hereby granted, without written agreement or royalty fee, to

use, copy, modify, and distribute this software and its documentation for

any purpose, provided that the above copyright notice and the following

three paragraphs appear in all copies of this software.


IN NO EVENT SHALL AUTHORS BE LIABLE TO ANY PARTY FOR DIRECT,

INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES ARISING OUT OF THE 

USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF AUTHORS HAVE

BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.


AUTHORS SPECIFICALLY DISCLAIM ANY WARRANTIES INCLUDING, BUT NOT

LIMITED TO THE IMPLIED WARRANTIES OF MERCHANTABILITY, FITNESS FOR A

PARTICULAR PURPOSE, AND NON-INFRINGEMENT.


THE SOFTWARE IS PROVIDED ON AN ""AS-IS"" BASIS AND AUTHORS HAVE NO

OBLIGATION TO PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR

MODIFICATIONS.-->


<!DOCTYPE html>
<html>
<head/>
<body>
<div>
<?php
$string = $_POST['UserData'] ;
$tainted = unserialize($string);
    

$tainted = mysql_real_escape_string($tainted);


echo $tainted ;
?>
</div>
<h1>Hello World!</h1>
</body>
</html>",echo $tainted ;,True,True,"$tainted = mysql_real_escape_string($tainted);


echo $tainted ;
?>","```xml
<Issues>
  <Issue>
    <Type>Security</Type>
    <Weakness>CWE-502</Weakness>
    <Description>Deserialization of Untrusted Data</Description>
    <Severity>High</Severity>
    <File>File 1</File>
    <Code>$string = $_POST['UserData'] ;
$tainted = unserialize($string);</Code>
    <Justification>The code uses unserialize() on user-controlled input ($_POST['UserData']), which can lead to arbitrary code execution. Deserialization of untrusted data is a high-risk vulnerability.</Justification>
  </Issue>
  <Issue>
    <Type>Security</Type>
    <Weakness>CWE-79</Weakness>
    <Description>Improper Neutralization of Input During Web Page Generation ('Cross-site Scripting')</Description>
    <Severity>Medium</Severity>
    <File>File 1</File>
    <Code>
$tainted = mysql_real_escape_string($tainted);


echo $tainted ;
?>
</Code>
    <Justification>Even though mysql_real_escape_string is used, it is not sufficient to prevent XSS. This function escapes characters for use in SQL queries, not HTML. The output $tainted is directly echoed into the HTML, making it vulnerable to XSS.</Justification>
  </Issue>
  <Issue>
    <Type>Security</Type>
    <Weakness>CWE-477</Weakness>
    <Description>Use of Obsolete Function</Description>
    <Severity>Low</Severity>
    <File>File 1</File>
    <Code>$tainted = mysql_real_escape_string($tainted);</Code>
    <Justification>The code uses the mysql_real_escape_string function, which is deprecated. This suggests that the code has not been actively reviewed or maintained, and it should be updated to use a more secure and current alternative (e.g., using prepared statements with PDO or mysqli).</Justification>
  </Issue>
</Issues>
```"
CWE-79,src/CWE_79__popen__func_FILTER-VALIDATION-number_int_filter__Unsafe_use_untrusted_data-style.php,"<!-- 
Unsafe sample
input : Uses popen to read the file /tmp/tainted.txt using cat command
Flushes content of $sanitized if the filter number_int_filter is not applied
File : unsafe, use of untrusted data in CSS
-->

<!--Copyright 2015 Bertrand STIVALET 

Permission is hereby granted, without written agreement or royalty fee, to

use, copy, modify, and distribute this software and its documentation for

any purpose, provided that the above copyright notice and the following

three paragraphs appear in all copies of this software.


IN NO EVENT SHALL AUTHORS BE LIABLE TO ANY PARTY FOR DIRECT,

INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES ARISING OUT OF THE 

USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF AUTHORS HAVE

BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.


AUTHORS SPECIFICALLY DISCLAIM ANY WARRANTIES INCLUDING, BUT NOT

LIMITED TO THE IMPLIED WARRANTIES OF MERCHANTABILITY, FITNESS FOR A

PARTICULAR PURPOSE, AND NON-INFRINGEMENT.


THE SOFTWARE IS PROVIDED ON AN ""AS-IS"" BASIS AND AUTHORS HAVE NO

OBLIGATION TO PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR

MODIFICATIONS.-->


<!DOCTYPE html>
<html>
<head>
<style>
<?php
$handle = popen('/bin/cat /tmp/tainted.txt', 'r');
$tainted = fread($handle, 4096);
pclose($handle);

if (filter_var($sanitized, FILTER_VALIDATE_INT))
  $tainted = $sanitized ;
else
  $tainted = """" ;


echo $tainted ;
?>
</style>
</head>
<body>
<h1>Hello World!</h1>
</body>
</html>",echo $tainted ;,True,True,echo $tainted ;,"```xml
<Issues>
  <Issue>
    <Type>Security</Type>
    <Weakness>CWE-77</Weakness>
    <Description>Improper Neutralization of Special Elements used in a Command ('Command Injection')</Description>
    <Severity>High</Severity>
    <File>File 1</File>
    <Code>$handle = popen('/bin/cat /tmp/tainted.txt', 'r');</Code>
    <Justification>The code uses popen to execute a command. While the command itself ('/bin/cat /tmp/tainted.txt') is hardcoded and appears safe in this specific instance, popen() itself can be dangerous if the command is dynamically constructed or contains user-controlled data. Even though the file path is fixed, the popen function opens the possibility for command injection if ever the command is altered to include user input.</Justification>
  </Issue>
  <Issue>
    <Type>Security</Type>
    <Weakness>CWE-79</Weakness>
    <Description>Improper Neutralization of Input During Web Page Generation ('Cross-site Scripting')</Description>
    <Severity>Medium</Severity>
    <File>File 1</File>
    <Code>echo $tainted ;</Code>
    <Justification>The code echoes the value of $tainted directly into the &lt;style&gt; tag. If $tainted contains malicious CSS or JavaScript code, it will be executed by the browser, leading to a Cross-Site Scripting (XSS) vulnerability. Although there is an integer validation, if the validation fails, $tainted is assigned an empty string, but if it passes, the original tainted value is never sanitized, making it possible to introduce a vulnerability in the style tag.</Justification>
  </Issue>
  <Issue>
    <Type>Reliability</Type>
    <Weakness>CWE-252</Weakness>
    <Description>Unchecked Return Value</Description>
    <Severity>Medium</Severity>
    <File>File 1</File>
    <Code>$handle = popen('/bin/cat /tmp/tainted.txt', 'r');
$tainted = fread($handle, 4096);
pclose($handle);</Code>
    <Justification>The code does not check the return values of `popen()`, `fread()`, and `pclose()`. If any of these functions fail, the program may continue to execute with incorrect data or an invalid file handle, leading to unexpected behavior or a crash.</Justification>
  </Issue>
</Issues>
```"
CWE-79,src/CWE_79__exec__func_preg_replace__Use_untrusted_data_propertyValue_CSS-quoted_Property_Value.php,"<!-- 
Unsafe sample
input : use exec to execute the script /tmp/tainted.php and store the output in $tainted
SANITIZE : use of preg_replace
File : unsafe, use of untrusted data in a quoted property value (CSS)
-->

<!--Copyright 2015 Bertrand STIVALET 

Permission is hereby granted, without written agreement or royalty fee, to

use, copy, modify, and distribute this software and its documentation for

any purpose, provided that the above copyright notice and the following

three paragraphs appear in all copies of this software.


IN NO EVENT SHALL AUTHORS BE LIABLE TO ANY PARTY FOR DIRECT,

INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES ARISING OUT OF THE 

USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF AUTHORS HAVE

BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.


AUTHORS SPECIFICALLY DISCLAIM ANY WARRANTIES INCLUDING, BUT NOT

LIMITED TO THE IMPLIED WARRANTIES OF MERCHANTABILITY, FITNESS FOR A

PARTICULAR PURPOSE, AND NON-INFRINGEMENT.


THE SOFTWARE IS PROVIDED ON AN ""AS-IS"" BASIS AND AUTHORS HAVE NO

OBLIGATION TO PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR

MODIFICATIONS.-->


<!DOCTYPE html>
<html>
<head>
<style>
<?php
$script = ""/tmp/tainted.php"";
exec($script, $result, $return);

$tainted = $result[0];

$tainted = preg_replace('/\'/', '', $tainted);


echo ""body { color :\'"". $tainted .""\' ; }"" ;
?>
</style> 
</head>
<body>
<h1>Hello World!</h1>
</body>
</html>","echo ""body { color :\'"". $tainted .""\' ; }"" ;",True,True,"echo ""body { color :\'"". $tainted .""\' ; }"" ;","```xml
<Issues>
  <Issue>
    <Type>Security</Type>
    <Weakness>CWE-77</Weakness>
    <Description>Improper Neutralization of Special Elements used in a Command ('Command Injection')</Description>
    <Severity>High</Severity>
    <File>File 1</File>
    <Code>$script = ""/tmp/tainted.php"";
exec($script, $result, $return);</Code>
    <Justification>The code uses exec() to execute an external script. If the script path or its contents are influenced by an attacker, it could lead to command injection.</Justification>
  </Issue>
  <Issue>
    <Type>Security</Type>
    <Weakness>CWE-79</Weakness>
    <Description>Improper Neutralization of Input During Web Page Generation ('Cross-site Scripting')</Description>
    <Severity>Medium</Severity>
    <File>File 1</File>
    <Code>echo ""body { color :\'"". $tainted .""\' ; }"" ;</Code>
    <Justification>The code echoes user-controlled data ($tainted) into the CSS style. Although the code uses preg_replace to remove single quotes, it might be bypassable if other special characters are present in $tainted. This can lead to XSS if an attacker can inject malicious CSS code.</Justification>
  </Issue>
  <Issue>
    <Type>Security</Type>
    <Weakness>CWE-477</Weakness>
    <Description>Use of Obsolete Function</Description>
    <Severity>Low</Severity>
    <File>File 1</File>
    <Code>exec($script, $result, $return);</Code>
    <Justification>The `exec` function is considered an obsolete function because it can be used to inject commands into the operating system.</Justification>
  </Issue>
</Issues>
```"
CWE-79,src/CWE_79__popen__no_sanitizing__Unsafe_use_untrusted_data-tag_Name.php,"<!-- 
Unsafe sample
input : Uses popen to read the file /tmp/tainted.txt using cat command
sanitize : none
File : unsafe, use of untrusted data in an tag name
-->

<!--Copyright 2015 Bertrand STIVALET 

Permission is hereby granted, without written agreement or royalty fee, to

use, copy, modify, and distribute this software and its documentation for

any purpose, provided that the above copyright notice and the following

three paragraphs appear in all copies of this software.


IN NO EVENT SHALL AUTHORS BE LIABLE TO ANY PARTY FOR DIRECT,

INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES ARISING OUT OF THE 

USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF AUTHORS HAVE

BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.


AUTHORS SPECIFICALLY DISCLAIM ANY WARRANTIES INCLUDING, BUT NOT

LIMITED TO THE IMPLIED WARRANTIES OF MERCHANTABILITY, FITNESS FOR A

PARTICULAR PURPOSE, AND NON-INFRINGEMENT.


THE SOFTWARE IS PROVIDED ON AN ""AS-IS"" BASIS AND AUTHORS HAVE NO

OBLIGATION TO PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR

MODIFICATIONS.-->


<!DOCTYPE html>
<html>
<head/>
<body>
<?php
$handle = popen('/bin/cat /tmp/tainted.txt', 'r');
$tainted = fread($handle, 4096);
pclose($handle);




echo ""<"".  $tainted ."" href= \""/bob\"" />"" ;
?>
<h1>Hello World!</h1>
</body>
</html>","echo ""<"".  $tainted ."" href= \""/bob\"" />"" ;",True,True,"echo ""<"".  $tainted ."" href= \""/bob\"" />"" ;","```xml
<Issues>
  <Issue>
    <Type>Security</Type>
    <Weakness>CWE-79</Weakness>
    <Description>Improper Neutralization of Input During Web Page Generation ('Cross-site Scripting')</Description>
    <Severity>High</Severity>
    <File>File 1</File>
    <Code>echo ""&lt;"".  $tainted ."" href= \""/bob\"" /&gt;"" ;</Code>
    <Justification>The code uses external input $tainted directly in an HTML tag without proper sanitization, leading to a cross-site scripting (XSS) vulnerability.</Justification>
  </Issue>
  <Issue>
    <Type>Security</Type>
    <Weakness>CWE-22</Weakness>
    <Description>Improper Limitation of a Pathname to a Restricted Directory ('Path Traversal')</Description>
    <Severity>High</Severity>
    <File>File 1</File>
    <Code>$handle = popen('/bin/cat /tmp/tainted.txt', 'r');</Code>
    <Justification>The code uses popen to execute a command that reads the content of /tmp/tainted.txt. If an attacker can control the content of /tmp/tainted.txt, they can potentially execute arbitrary commands on the server.</Justification>
  </Issue>
  <Issue>
    <Type>Reliability</Type>
    <Weakness>CWE-252</Weakness>
    <Description>Unchecked Return Value</Description>
    <Severity>Medium</Severity>
    <File>File 1</File>
    <Code>$handle = popen('/bin/cat /tmp/tainted.txt', 'r');
$tainted = fread($handle, 4096);
pclose($handle);</Code>
    <Justification>The code does not check the return values of popen, fread, and pclose. If any of these functions fail, the program may proceed with incorrect data or in an unexpected state.</Justification>
  </Issue>
  <Issue>
    <Type>Performance Efficiency</Type>
    <Weakness>CWE-1050</Weakness>
    <Description>Excessive Platform Resource Consumption within a Loop</Description>
    <Severity>Low</Severity>
    <File>File 1</File>
    <Code>$handle = popen('/bin/cat /tmp/tainted.txt', 'r');
$tainted = fread($handle, 4096);
pclose($handle);</Code>
    <Justification>Using popen to read a file, even a small one, can be less efficient than using file_get_contents or similar functions directly in PHP. This is because popen creates a new process.</Justification>
  </Issue>
</Issues>
```"
CWE-79,src/CWE_79__object-classicGet__func_htmlspecialchars__Use_untrusted_data_script-window_SetInterval.php,"<!-- 
Unsafe sample
input : get the field userData from the variable $_GET via an object
sanitize : use of the function htmlspecialchars. Sanitizes the query but has a high chance to produce unexpected results
File : unsafe, use of untrusted data in the function setInterval
-->

<!--Copyright 2015 Bertrand STIVALET 

Permission is hereby granted, without written agreement or royalty fee, to

use, copy, modify, and distribute this software and its documentation for

any purpose, provided that the above copyright notice and the following

three paragraphs appear in all copies of this software.


IN NO EVENT SHALL AUTHORS BE LIABLE TO ANY PARTY FOR DIRECT,

INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES ARISING OUT OF THE 

USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF AUTHORS HAVE

BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.


AUTHORS SPECIFICALLY DISCLAIM ANY WARRANTIES INCLUDING, BUT NOT

LIMITED TO THE IMPLIED WARRANTIES OF MERCHANTABILITY, FITNESS FOR A

PARTICULAR PURPOSE, AND NON-INFRINGEMENT.


THE SOFTWARE IS PROVIDED ON AN ""AS-IS"" BASIS AND AUTHORS HAVE NO

OBLIGATION TO PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR

MODIFICATIONS.-->


<!DOCTYPE html>
<html>
<head>
<script>
<?php
class Input{
  private $input;

  public function getInput(){
    return $this->input;
  }

  public  function __construct(){
   $this->input = $_GET['UserData'] ;
  }
}
$temp = new Input();
$tainted =  $temp->getInput();

$tainted = htmlspecialchars($tainted, ENT_QUOTES);


echo ""window.setInterval('"". $tainted .""');"" ;
?>
 </script>
</head>
<body>
<h1>Hello World!</h1>
</body>
</html>","echo ""window.setInterval('"". $tainted .""');"" ;",True,True,"$tainted = htmlspecialchars($tainted, ENT_QUOTES);


echo ""window.setInterval('"". $tainted .""');"" ;
?>","```xml
<Issues>
  <Issue>
    <Type>Security</Type>
    <Weakness>CWE-79</Weakness>
    <Description>Improper Neutralization of Input During Web Page Generation ('Cross-site Scripting')</Description>
    <Severity>High</Severity>
    <File>File 1</File>
    <Code>
$tainted = htmlspecialchars($tainted, ENT_QUOTES);


echo ""window.setInterval('"". $tainted .""');"" ;
?>
    </Code>
    <Justification>The code uses htmlspecialchars to sanitize user input. However, this is insufficient to prevent XSS in this context because htmlspecialchars only encodes certain characters, and the remaining characters can still be used to break out of the string context and inject malicious JavaScript code within the setInterval function. The correct way to prevent XSS is to avoid using user input directly in JavaScript code.</Justification>
  </Issue>
</Issues>
```"
CWE-79,src/CWE_79__exec__ternary_white_list__Use_untrusted_data_script-doublequoted_Event_Handler.php,"<!-- 
Unsafe sample
input : use exec to execute the script /tmp/tainted.php and store the output in $tainted
sanitize : use of ternary condition
File : use of untrusted data in a double quoted event handler in a script
-->

<!--Copyright 2015 Bertrand STIVALET 

Permission is hereby granted, without written agreement or royalty fee, to

use, copy, modify, and distribute this software and its documentation for

any purpose, provided that the above copyright notice and the following

three paragraphs appear in all copies of this software.


IN NO EVENT SHALL AUTHORS BE LIABLE TO ANY PARTY FOR DIRECT,

INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES ARISING OUT OF THE 

USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF AUTHORS HAVE

BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.


AUTHORS SPECIFICALLY DISCLAIM ANY WARRANTIES INCLUDING, BUT NOT

LIMITED TO THE IMPLIED WARRANTIES OF MERCHANTABILITY, FITNESS FOR A

PARTICULAR PURPOSE, AND NON-INFRINGEMENT.


THE SOFTWARE IS PROVIDED ON AN ""AS-IS"" BASIS AND AUTHORS HAVE NO

OBLIGATION TO PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR

MODIFICATIONS.-->


<!DOCTYPE html>
<html>
<head/>
<body>
<?php
$script = ""/tmp/tainted.php"";
exec($script, $result, $return);

$tainted = $result[0];

$tainted = $tainted  == 'safe1' ? 'safe1' : 'safe2';


echo ""<div onmouseover=\""x=\"""". $tainted .""\""\>"";
?>
<h1>Hello World!</h1>
</div>
</body>
</html>","echo ""<div onmouseover=\""x=\"""". $tainted .""\""\>"";",True,True,"$script = ""/tmp/tainted.php"";
exec($script, $result, $return);

$tainted = $result[0];

$tainted = $tainted  == 'safe1' ? 'safe1' : 'safe2';


echo ""<div onmouseover=\""x=\"""". $tainted .""\"">"";","```xml
<Issues>
  <Issue>
    <Type>Security</Type>
    <Weakness>CWE-77</Weakness>
    <Description>Improper Neutralization of Special Elements used in a Command ('Command Injection')</Description>
    <Severity>High</Severity>
    <File>File 1</File>
    <Code>$script = ""/tmp/tainted.php"";
exec($script, $result, $return);

$tainted = $result[0];

$tainted = $tainted  == 'safe1' ? 'safe1' : 'safe2';


echo ""&lt;div onmouseover=\""x=\"""". $tainted .""\""&gt;"";</Code>
    <Justification>The code uses exec() to execute a PHP script, which can lead to command injection if the script's content is controlled by an attacker. Even if the script itself is not directly injectable, its output is used in a double-quoted event handler, which can lead to Cross-Site Scripting (XSS).</Justification>
  </Issue>
  <Issue>
    <Type>Security</Type>
    <Weakness>CWE-79</Weakness>
    <Description>Improper Neutralization of Input During Web Page Generation ('Cross-site Scripting')</Description>
    <Severity>Medium</Severity>
    <File>File 1</File>
    <Code>$script = ""/tmp/tainted.php"";
exec($script, $result, $return);

$tainted = $result[0];

$tainted = $tainted  == 'safe1' ? 'safe1' : 'safe2';


echo ""&lt;div onmouseover=\""x=\"""". $tainted .""\""&gt;"";</Code>
    <Justification>The code echoes user-controlled data ($tainted) into an HTML attribute (onmouseover). Even though a ternary operator is used to supposedly sanitize the data, it only allows 'safe1' or 'safe2'. An attacker might be able to inject malicious JavaScript code if the executed script produces unexpected output and if the application does not properly neutralize the output before using it in the HTML attribute.</Justification>
  </Issue>
</Issues>
```"
CWE-90,src/CWE_90__shell_exec__func_htmlentities__name-concatenation_simple_quote.php,"<?php







$tainted = shell_exec('cat /tmp/tainted.txt');

$tainted = htmlentities($tainted, ENT_QUOTES);

$query = ""name='"". $tainted . ""'"";


$ds=ldap_connect(""localhost""); 
$r=ldap_bind($ds);
$sr=ldap_search($ds,""o=My Company, c=US"", $query);  
ldap_close($ds);

?>","$ds=ldap_connect(""localhost"");",True,True,"$tainted = shell_exec('cat /tmp/tainted.txt');

$tainted = htmlentities($tainted, ENT_QUOTES);

$query = ""name='"". $tainted . ""'"";


$ds=ldap_connect(""localhost""); 
$r=ldap_bind($ds);
$sr=ldap_search($ds,""o=My Company, c=US"", $query);  
ldap_close($ds);","```xml
<Issues>
  <Issue>
    <Type>Security</Type>
    <Weakness>CWE-90</Weakness>
    <Description>Improper Neutralization of Special Elements used in an LDAP Query ('LDAP Injection')</Description>
    <Severity>High</Severity>
    <File>File 1</File>
    <Code>$tainted = shell_exec('cat /tmp/tainted.txt');

$tainted = htmlentities($tainted, ENT_QUOTES);

$query = ""name='"". $tainted . ""'"";


$ds=ldap_connect(""localhost""); 
$r=ldap_bind($ds);
$sr=ldap_search($ds,""o=My Company, c=US"", $query);  
ldap_close($ds);</Code>
    <Justification>The code constructs an LDAP query by directly embedding user-controlled data (obtained from the file /tmp/tainted.txt and sanitized using htmlentities) into the query string. Even with htmlentities, it does not prevent LDAP injection. An attacker could inject malicious LDAP syntax into the tainted data, potentially allowing them to bypass authentication, extract sensitive information, or modify the LDAP directory.</Justification>
  </Issue>
  <Issue>
    <Type>Security</Type>
    <Weakness>CWE-77</Weakness>
    <Description>Improper Neutralization of Special Elements used in a Command ('Command Injection')</Description>
    <Severity>High</Severity>
    <File>File 1</File>
    <Code>$tainted = shell_exec('cat /tmp/tainted.txt');</Code>
    <Justification>The code uses shell_exec to read the contents of /tmp/tainted.txt. If the file path is controllable by an attacker, it could lead to command injection. Although the file name is hardcoded, the contents of the file are read, and if this file is created or modified maliciously, arbitrary commands could be executed on the server.</Justification>
  </Issue>
</Issues>
```"
