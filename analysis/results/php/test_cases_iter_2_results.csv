Test Case Weakness,Test Case File,Test Case Code,Test Case Line,LLM Hit CWE,LLM Hit Code,LLM Code,LLM Complete Response
CWE-90,src/CWE_90__SESSION__func_preg_match-no_filtering__name-interpretation_simple_quote.php,"<?php







$tainted = $_SESSION['UserData'];

$re = ""/^.*$/"";
if(preg_match($re, $tainted) == 1){
  $tainted = $tainted;
}
else{
  $tainted = """";
}

$query = ""name=' $tainted '"";


$ds=ldap_connect(""localhost""); 
$r=ldap_bind($ds);
$sr=ldap_search($ds,""o=My Company, c=US"", $query);  
ldap_close($ds);

?>","$ds=ldap_connect(""localhost"");",True,True,"$tainted = $_SESSION['UserData'];

$re = ""/^.*$/"";
if(preg_match($re, $tainted) == 1){
  $tainted = $tainted;
}
else{
  $tainted = """";
}

$query = ""name=' $tainted '"";


$ds=ldap_connect(""localhost""); 
$r=ldap_bind($ds);
$sr=ldap_search($ds,""o=My Company, c=US"", $query);  
ldap_close($ds);","```xml
<Issues>
  <Issue>
    <Type>Security</Type>
    <Weakness>CWE-90</Weakness>
    <Description>Improper Neutralization of Special Elements used in an LDAP Query ('LDAP Injection')</Description>
    <Severity>High</Severity>
    <File>File 1</File>
    <Code>$tainted = $_SESSION['UserData'];

$re = ""/^.*$/"";
if(preg_match($re, $tainted) == 1){
  $tainted = $tainted;
}
else{
  $tainted = """";
}

$query = ""name=' $tainted '"";


$ds=ldap_connect(""localhost""); 
$r=ldap_bind($ds);
$sr=ldap_search($ds,""o=My Company, c=US"", $query);  
ldap_close($ds);</Code>
    <Justification>The code is vulnerable to LDAP injection because it directly incorporates user-controlled data ($tainted) into an LDAP query without proper sanitization. Although there is a regex to validate the input, the regex ""/^.*$/"" allows any character, so it is not effective.</Justification>
  </Issue>
</Issues>
```"
CWE-79,src/CWE_79__unserialize__func_FILTER-CLEANING-email_filter__Use_untrusted_data-div.php,"<!-- 
Unsafe sample
input : Get a serialize string in POST and unserialize it
Uses an email_filter via filter_var function
File : use of untrusted data in a div tag
-->

<!--Copyright 2015 Bertrand STIVALET 

Permission is hereby granted, without written agreement or royalty fee, to

use, copy, modify, and distribute this software and its documentation for

any purpose, provided that the above copyright notice and the following

three paragraphs appear in all copies of this software.


IN NO EVENT SHALL AUTHORS BE LIABLE TO ANY PARTY FOR DIRECT,

INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES ARISING OUT OF THE 

USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF AUTHORS HAVE

BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.


AUTHORS SPECIFICALLY DISCLAIM ANY WARRANTIES INCLUDING, BUT NOT

LIMITED TO THE IMPLIED WARRANTIES OF MERCHANTABILITY, FITNESS FOR A

PARTICULAR PURPOSE, AND NON-INFRINGEMENT.


THE SOFTWARE IS PROVIDED ON AN ""AS-IS"" BASIS AND AUTHORS HAVE NO

OBLIGATION TO PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR

MODIFICATIONS.-->


<!DOCTYPE html>
<html>
<head/>
<body>
<div>
<?php
$string = $_POST['UserData'] ;
$tainted = unserialize($string);
    

$sanitized = filter_var($tainted, FILTER_SANITIZE_EMAIL);
if (filter_var($sanitized, FILTER_VALIDATE_EMAIL))
  $tainted = $sanitized ;
else
  $tainted = """" ;


echo $tainted ;
?>
</div>
<h1>Hello World!</h1>
</body>
</html>",echo $tainted ;,True,True,echo $tainted ;,"```xml
<Issues>
  <Issue>
    <Type>Security</Type>
    <Weakness>CWE-502</Weakness>
    <Description>Deserialization of Untrusted Data</Description>
    <Severity>Critical</Severity>
    <File>File 1</File>
    <Code>$string = $_POST['UserData'] ;
$tainted = unserialize($string);</Code>
    <Justification>The code uses unserialize() on user-supplied data from $_POST['UserData']. This is highly dangerous as it allows arbitrary code execution if the serialized data is maliciously crafted. An attacker can inject arbitrary objects into the application, potentially leading to remote code execution.</Justification>
  </Issue>
  <Issue>
    <Type>Security</Type>
    <Weakness>CWE-79</Weakness>
    <Description>Improper Neutralization of Input During Web Page Generation ('Cross-site Scripting')</Description>
    <Severity>Medium</Severity>
    <File>File 1</File>
    <Code>echo $tainted ;</Code>
    <Justification>The code echoes the $tainted variable directly into the HTML output without proper encoding. Although there is an attempt to sanitize the input using FILTER_SANITIZE_EMAIL and FILTER_VALIDATE_EMAIL, this is insufficient to prevent XSS. If the input bypasses the email validation, it can contain malicious HTML or JavaScript code that will be executed in the user's browser.</Justification>
  </Issue>
</Issues>
```"
CWE-79,src/CWE_79__GET__func_FILTER-CLEANING-email_filter__Unsafe_use_untrusted_data-attribute_Name.php,"<!-- 
Unsafe sample
input : reads the field UserData from the variable $_GET
Uses an email_filter via filter_var function
File : unsafe, use of untrusted data in an attribute name
-->

<!--Copyright 2015 Bertrand STIVALET 

Permission is hereby granted, without written agreement or royalty fee, to

use, copy, modify, and distribute this software and its documentation for

any purpose, provided that the above copyright notice and the following

three paragraphs appear in all copies of this software.


IN NO EVENT SHALL AUTHORS BE LIABLE TO ANY PARTY FOR DIRECT,

INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES ARISING OUT OF THE 

USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF AUTHORS HAVE

BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.


AUTHORS SPECIFICALLY DISCLAIM ANY WARRANTIES INCLUDING, BUT NOT

LIMITED TO THE IMPLIED WARRANTIES OF MERCHANTABILITY, FITNESS FOR A

PARTICULAR PURPOSE, AND NON-INFRINGEMENT.


THE SOFTWARE IS PROVIDED ON AN ""AS-IS"" BASIS AND AUTHORS HAVE NO

OBLIGATION TO PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR

MODIFICATIONS.-->


<!DOCTYPE html>
<html>
<body>
<?php
$tainted = $_GET['UserData'];

$sanitized = filter_var($tainted, FILTER_SANITIZE_EMAIL);
if (filter_var($sanitized, FILTER_VALIDATE_EMAIL))
  $tainted = $sanitized ;
else
  $tainted = """" ;


echo ""<div "". $tainted .""= bob />"" ;
?>
<h1>Hello World!</h1>
</div>
</body>
</html>","echo ""<div "". $tainted .""= bob />"" ;",True,True,"echo ""<div "". $tainted .""= bob />"" ;","```xml
<Issues>
  <Issue>
    <Type>Security</Type>
    <Weakness>CWE-79</Weakness>
    <Description>Improper Neutralization of Input During Web Page Generation ('Cross-site Scripting')</Description>
    <Severity>High</Severity>
    <File>File 1</File>
    <Code>echo ""&lt;div "". $tainted .""= bob />"" ;</Code>
    <Justification>The code uses unsanitized user input ($tainted) directly within an HTML attribute name. This can lead to XSS vulnerabilities if the input contains malicious code, as the browser will interpret it as part of the HTML structure.</Justification>
  </Issue>
</Issues>
```"
CWE-79,src/CWE_79__exec__func_FILTER-CLEANING-number_float_filter__Use_untrusted_data_propertyValue_CSS-quoted_Property_Value.php,"<!-- 
Unsafe sample
input : use exec to execute the script /tmp/tainted.php and store the output in $tainted
Uses a number_float_filter via filter_var function
File : unsafe, use of untrusted data in a quoted property value (CSS)
-->

<!--Copyright 2015 Bertrand STIVALET 

Permission is hereby granted, without written agreement or royalty fee, to

use, copy, modify, and distribute this software and its documentation for

any purpose, provided that the above copyright notice and the following

three paragraphs appear in all copies of this software.


IN NO EVENT SHALL AUTHORS BE LIABLE TO ANY PARTY FOR DIRECT,

INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES ARISING OUT OF THE 

USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF AUTHORS HAVE

BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.


AUTHORS SPECIFICALLY DISCLAIM ANY WARRANTIES INCLUDING, BUT NOT

LIMITED TO THE IMPLIED WARRANTIES OF MERCHANTABILITY, FITNESS FOR A

PARTICULAR PURPOSE, AND NON-INFRINGEMENT.


THE SOFTWARE IS PROVIDED ON AN ""AS-IS"" BASIS AND AUTHORS HAVE NO

OBLIGATION TO PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR

MODIFICATIONS.-->


<!DOCTYPE html>
<html>
<head>
<style>
<?php
$script = ""/tmp/tainted.php"";
exec($script, $result, $return);

$tainted = $result[0];

$sanitized = filter_var($tainted, FILTER_SANITIZE_NUMBER_FLOAT);
if (filter_var($sanitized, FILTER_VALIDATE_FLOAT))
  $tainted = $sanitized ;
else
  $tainted = """" ;


echo ""body { color :\'"". $tainted .""\' ; }"" ;
?>
</style> 
</head>
<body>
<h1>Hello World!</h1>
</body>
</html>","echo ""body { color :\'"". $tainted .""\' ; }"" ;",True,True,"echo ""body { color :\'"". $tainted .""\' ; }"" ;
?>","```xml
<Issues>
  <Issue>
    <Type>Security</Type>
    <Weakness>CWE-78</Weakness>
    <Description>Improper Neutralization of Special Elements used in a Command ('Command Injection')</Description>
    <Severity>High</Severity>
    <File>File 1</File>
    <Code>$script = ""/tmp/tainted.php"";
exec($script, $result, $return);

$tainted = $result[0];</Code>
    <Justification>The code uses the `exec` function to execute a PHP script located at `/tmp/tainted.php`. Executing external commands, especially without proper sanitization or validation, introduces a command injection vulnerability. An attacker could potentially modify the contents of `/tmp/tainted.php` to execute arbitrary commands on the system. The output of the script is then stored in the `$tainted` variable.</Justification>
  </Issue>
  <Issue>
    <Type>Security</Type>
    <Weakness>CWE-79</Weakness>
    <Description>Improper Neutralization of Input During Web Page Generation ('Cross-site Scripting')</Description>
    <Severity>Medium</Severity>
    <File>File 1</File>
    <Code>

echo ""body { color :\'"". $tainted .""\' ; }"" ;
?&gt;
</Code>
    <Justification>The code echoes the `$tainted` variable directly into the CSS style attribute without proper output encoding. While the code attempts to sanitize `$tainted` using `filter_var`, this does not prevent all possible XSS attacks. If `$tainted` contains malicious code after sanitization, it will be executed by the browser in the context of the web page.</Justification>
  </Issue>
  <Issue>
    <Type>Security</Type>
    <Weakness>CWE-477</Weakness>
    <Description>Use of Obsolete Function</Description>
    <Severity>Low</Severity>
    <File>File 1</File>
    <Code>$script = ""/tmp/tainted.php"";
exec($script, $result, $return);</Code>
    <Justification>The `exec` function, while not strictly obsolete, is often discouraged in favor of more secure alternatives like `proc_open` when dealing with external commands, especially when the command or its arguments are derived from untrusted sources. Using `exec` can lead to security vulnerabilities if not handled carefully.</Justification>
  </Issue>
</Issues>
```"
CWE-79,src/CWE_79__SESSION__func_FILTER-CLEANING-email_filter__Use_untrusted_data_script-window_SetInterval.php,"<!-- 
Unsafe sample
input : get the UserData field of $_SESSION
Uses an email_filter via filter_var function
File : unsafe, use of untrusted data in the function setInterval
-->

<!--Copyright 2015 Bertrand STIVALET 

Permission is hereby granted, without written agreement or royalty fee, to

use, copy, modify, and distribute this software and its documentation for

any purpose, provided that the above copyright notice and the following

three paragraphs appear in all copies of this software.


IN NO EVENT SHALL AUTHORS BE LIABLE TO ANY PARTY FOR DIRECT,

INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES ARISING OUT OF THE 

USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF AUTHORS HAVE

BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.


AUTHORS SPECIFICALLY DISCLAIM ANY WARRANTIES INCLUDING, BUT NOT

LIMITED TO THE IMPLIED WARRANTIES OF MERCHANTABILITY, FITNESS FOR A

PARTICULAR PURPOSE, AND NON-INFRINGEMENT.


THE SOFTWARE IS PROVIDED ON AN ""AS-IS"" BASIS AND AUTHORS HAVE NO

OBLIGATION TO PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR

MODIFICATIONS.-->


<!DOCTYPE html>
<html>
<head>
<script>
<?php
$tainted = $_SESSION['UserData'];

$sanitized = filter_var($tainted, FILTER_SANITIZE_EMAIL);
if (filter_var($sanitized, FILTER_VALIDATE_EMAIL))
  $tainted = $sanitized ;
else
  $tainted = """" ;


echo ""window.setInterval('"". $tainted .""');"" ;
?>
 </script>
</head>
<body>
<h1>Hello World!</h1>
</body>
</html>","echo ""window.setInterval('"". $tainted .""');"" ;",True,True,"echo ""window.setInterval('"". $tainted .""');"" ;","```xml
<Issues>
  <Issue>
    <Type>Security</Type>
    <Weakness>CWE-79</Weakness>
    <Description>Improper Neutralization of Input During Web Page Generation ('Cross-site Scripting')</Description>
    <Severity>High</Severity>
    <File>File 1</File>
    <Code>echo ""window.setInterval('"". $tainted .""');"" ;</Code>
    <Justification>The code uses user-controlled data ($tainted) directly within a JavaScript setInterval function call without proper neutralization. Even though the input is sanitized using FILTER_SANITIZE_EMAIL, it's still possible to inject malicious code that could be executed by the browser. For example, an attacker could inject code that closes the setInterval call and executes arbitrary JavaScript code.</Justification>
  </Issue>
  <Issue>
    <Type>Reliability</Type>
    <Weakness>CWE-758</Weakness>
    <Description>Reliance on Undefined, Unspecified, or Implementation-Defined Behavior</Description>
    <Severity>Low</Severity>
    <File>File 1</File>
    <Code>echo ""window.setInterval('"". $tainted .""');"" ;</Code>
    <Justification>Using user-provided data directly within JavaScript's setInterval may result in undefined behavior if the data causes a syntax error or other unexpected issues. While the email filter is applied, it is still possible that the resulting string may not be a valid JavaScript expression, leading to potential runtime errors.</Justification>
  </Issue>
</Issues>
```"
CWE-90,src/CWE_90__shell_exec__func_preg_replace__name-concatenation_simple_quote.php,"<?php







$tainted = shell_exec('cat /tmp/tainted.txt');

$tainted = preg_replace('/\'/', '', $tainted);

$query = ""name='"". $tainted . ""'"";


$ds=ldap_connect(""localhost""); 
$r=ldap_bind($ds);
$sr=ldap_search($ds,""o=My Company, c=US"", $query);  
ldap_close($ds);

?>","$ds=ldap_connect(""localhost"");",True,True,"$tainted = shell_exec('cat /tmp/tainted.txt');

$tainted = preg_replace('/\'/', '', $tainted);

$query = ""name='"". $tainted . ""'"";


$ds=ldap_connect(""localhost""); 
$r=ldap_bind($ds);
$sr=ldap_search($ds,""o=My Company, c=US"", $query);  
ldap_close($ds);","```xml
<Issues>
  <Issue>
    <Type>Security</Type>
    <Weakness>CWE-90</Weakness>
    <Description>Improper Neutralization of Special Elements used in an LDAP Query ('LDAP Injection')</Description>
    <Severity>High</Severity>
    <File>File 1</File>
    <Code>$tainted = shell_exec('cat /tmp/tainted.txt');

$tainted = preg_replace('/\'/', '', $tainted);

$query = ""name='"". $tainted . ""'"";


$ds=ldap_connect(""localhost""); 
$r=ldap_bind($ds);
$sr=ldap_search($ds,""o=My Company, c=US"", $query);  
ldap_close($ds);</Code>
    <Justification>The code constructs an LDAP query by directly concatenating user-controlled input ($tainted) without proper sanitization. Although the code attempts to remove single quotes, this is insufficient to prevent LDAP injection attacks. An attacker could inject arbitrary LDAP code, potentially compromising the LDAP server.</Justification>
  </Issue>
  <Issue>
    <Type>Security</Type>
    <Weakness>CWE-77</Weakness>
    <Description>Improper Neutralization of Special Elements used in a Command ('Command Injection')</Description>
    <Severity>High</Severity>
    <File>File 1</File>
    <Code>$tainted = shell_exec('cat /tmp/tainted.txt');</Code>
    <Justification>The code uses shell_exec to read the content of /tmp/tainted.txt. If an attacker can control the content of this file, they can inject arbitrary OS commands that will be executed by the server.</Justification>
  </Issue>
</Issues>
```"
CWE-91,src/CWE_91__proc_open__func_FILTER-CLEANING-full_special_chars_filter__username_at-interpretation_simple_quote.php,"<?php







$descriptorspec = array(
  0 => array(""pipe"", ""r""),
  1 => array(""pipe"", ""w""),
  2 => array(""file"", ""/tmp/error-output.txt"", ""a"")
  );
$cwd = '/tmp';
$process = proc_open('more /tmp/tainted.txt', $descriptorspec, $pipes, $cwd, NULL);
if (is_resource($process)) {
  fclose($pipes[0]);
  $tainted = stream_get_contents($pipes[1]);
  fclose($pipes[1]);
  $return_value = proc_close($process);
}

$sanitized = filter_var($tainted, FILTER_SANITIZE_FULL_SPECIAL_CHARS);
  $tainted = $sanitized ;
     

$query = ""


$xml = simplexml_load_file(""users.xml"");
echo ""query : "". $query .""<br /><br />"" ;

$res=$xml->xpath($query);
print_r($res);
echo ""<br />"" ;

?>","$xml = simplexml_load_file(""users.xml"");",False,False,,"```xml
<Issues>
  <Issue>
    <Type>Security</Type>
    <Weakness>CWE-77</Weakness>
    <Description>Improper Neutralization of Special Elements used in a Command ('Command Injection')</Description>
    <Severity>High</Severity>
    <File>File 1</File>
    <Code>$process = proc_open('more /tmp/tainted.txt', $descriptorspec, $pipes, $cwd, NULL);</Code>
    <Justification>The proc_open function executes an external command, 'more /tmp/tainted.txt'.  If the contents of /tmp/tainted.txt are attacker-controlled, this could lead to command injection.  The attacker could insert shell commands into the file, which would then be executed by the 'more' command.</Justification>
  </Issue>
  <Issue>
    <Type>Security</Type>
    <Weakness>CWE-643</Weakness>
    <Description>Improper Neutralization of Data within XPath Expressions ('XPath Injection')</Description>
    <Severity>High</Severity>
    <File>File 1</File>
    <Code>$query = ""


$xml = simplexml_load_file(""users.xml"");
echo ""query : "". $query .""&lt;br /&gt;&lt;br /&gt;"" ;

$res=$xml->xpath($query);</Code>
    <Justification>The code uses simplexml_load_file() to load ""users.xml"" and then uses xpath() to execute a query. The $query variable is not initialized with any value, but it is used in the xpath() function. Even if it was initialized, if $query contains unsanitized user input, it is vulnerable to XPath injection. An attacker could manipulate the query to extract sensitive information or bypass security restrictions.</Justification>
  </Issue>
</Issues>
```"
CWE-79,src/CWE_79__popen__func_FILTER-CLEANING-email_filter__Use_untrusted_data_propertyValue_CSS-property_Value.php,"<!-- 
Unsafe sample
input : Uses popen to read the file /tmp/tainted.txt using cat command
Uses an email_filter via filter_var function
File : use of untrusted data in a property value (CSS)
-->

<!--Copyright 2015 Bertrand STIVALET 

Permission is hereby granted, without written agreement or royalty fee, to

use, copy, modify, and distribute this software and its documentation for

any purpose, provided that the above copyright notice and the following

three paragraphs appear in all copies of this software.


IN NO EVENT SHALL AUTHORS BE LIABLE TO ANY PARTY FOR DIRECT,

INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES ARISING OUT OF THE 

USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF AUTHORS HAVE

BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.


AUTHORS SPECIFICALLY DISCLAIM ANY WARRANTIES INCLUDING, BUT NOT

LIMITED TO THE IMPLIED WARRANTIES OF MERCHANTABILITY, FITNESS FOR A

PARTICULAR PURPOSE, AND NON-INFRINGEMENT.


THE SOFTWARE IS PROVIDED ON AN ""AS-IS"" BASIS AND AUTHORS HAVE NO

OBLIGATION TO PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR

MODIFICATIONS.-->


<!DOCTYPE html>
<html>
<head>
<style>
<?php
$handle = popen('/bin/cat /tmp/tainted.txt', 'r');
$tainted = fread($handle, 4096);
pclose($handle);

$sanitized = filter_var($tainted, FILTER_SANITIZE_EMAIL);
if (filter_var($sanitized, FILTER_VALIDATE_EMAIL))
  $tainted = $sanitized ;
else
  $tainted = """" ;


echo ""body { color :"". $tainted ."" ; }"" ;
?>
 </style> 
 </script>
</head>
<body>
<h1>Hello World!</h1>
</body>
</html>","echo ""body { color :"". $tainted ."" ; }"" ;",True,True,"echo ""body { color :"". $tainted ."" ; }"" ;","```xml
<Issues>
  <Issue>
    <Type>Security</Type>
    <Weakness>CWE-77</Weakness>
    <Description>Improper Neutralization of Special Elements used in a Command ('Command Injection')</Description>
    <Severity>Medium</Severity>
    <File>File 1</File>
    <Code>$handle = popen('/bin/cat /tmp/tainted.txt', 'r');</Code>
    <Justification>The code uses popen to execute a command. If the file path `/tmp/tainted.txt` is controllable by an attacker, they could inject arbitrary commands. Although the file path is hardcoded, there is still a risk if the system allows users to write to `/tmp/tainted.txt`.</Justification>
  </Issue>
  <Issue>
    <Type>Security</Type>
    <Weakness>CWE-79</Weakness>
    <Description>Improper Neutralization of Input During Web Page Generation ('Cross-site Scripting')</Description>
    <Severity>Medium</Severity>
    <File>File 1</File>
    <Code>echo ""body { color :"". $tainted ."" ; }"" ;</Code>
    <Justification>The code echoes unsanitized data directly into the CSS style, which can lead to CSS injection. Although the input is sanitized using `FILTER_SANITIZE_EMAIL`, CSS Injection is still possible.  For example, an attacker could inject `url(""javascript:alert(1)"")` to trigger JavaScript execution.</Justification>
  </Issue>
  <Issue>
    <Type>Reliability</Type>
    <Weakness>CWE-252</Weakness>
    <Description>Unchecked Return Value</Description>
    <Severity>Low</Severity>
    <File>File 1</File>
    <Code>$handle = popen('/bin/cat /tmp/tainted.txt', 'r');
$tainted = fread($handle, 4096);
pclose($handle);</Code>
    <Justification>The code does not check the return value of `popen`, `fread`, and `pclose`. If `popen` fails, `$handle` will be false and `fread` will error. Similarly, `fread` might return false or a short read, which is not handled. `pclose` may also fail. Failing to handle these potential errors can lead to unexpected behavior.</Justification>
  </Issue>
  <Issue>
    <Type>Security</Type>
    <Weakness>CWE-477</Weakness>
    <Description>Use of Obsolete Function</Description>
    <Severity>Low</Severity>
    <File>File 1</File>
    <Code>$handle = popen('/bin/cat /tmp/tainted.txt', 'r');</Code>
    <Justification>popen is considered an obsolete function because it is prone to command injection if the command string is not properly sanitized. While the command string is hardcoded in this case, using safer alternatives is recommended.</Justification>
  </Issue>
</Issues>
```"
CWE-78,src/CWE_78__unserialize__func_preg_match-no_filtering__ls-sprintf_%s_simple_quote.php,"<?php







$string = $_POST['UserData'] ;
$tainted = unserialize($string);
    

$re = ""/^.*$/"";
if(preg_match($re, $tainted) == 1){
  $tainted = $tainted;
}
else{
  $tainted = """";
}

$query = sprintf(""ls '%s'"", $tainted);


$ret = system($query);


?>",$ret = system($query);,False,False,,"```xml
<Issues>
  <Issue>
    <Type>Security</Type>
    <Weakness>CWE-77</Weakness>
    <Description>Improper Neutralization of Special Elements used in a Command ('Command Injection')</Description>
    <Severity>High</Severity>
    <File>File 1</File>
    <Code>$query = sprintf(""ls '%s'"", $tainted);


$ret = system($query);</Code>
    <Justification>The code uses sprintf to construct a shell command and then executes it using system(). The $tainted variable, which comes from user input, is incorporated into the command without proper sanitization. This can lead to command injection vulnerabilities.</Justification>
  </Issue>
  <Issue>
    <Type>Security</Type>
    <Weakness>CWE-502</Weakness>
    <Description>Deserialization of Untrusted Data</Description>
    <Severity>Critical</Severity>
    <File>File 1</File>
    <Code>$string = $_POST['UserData'] ;
$tainted = unserialize($string);</Code>
    <Justification>The code uses unserialize() on user-supplied data from $_POST['UserData']. This is extremely dangerous as it allows an attacker to inject arbitrary PHP objects into the application, potentially leading to remote code execution.</Justification>
  </Issue>
</Issues>
```"
CWE-90,src/CWE_90__shell_exec__func_preg_match-no_filtering__name-concatenation_simple_quote.php,"<?php







$tainted = shell_exec('cat /tmp/tainted.txt');

$re = ""/^.*$/"";
if(preg_match($re, $tainted) == 1){
  $tainted = $tainted;
}
else{
  $tainted = """";
}

$query = ""name='"". $tainted . ""'"";


$ds=ldap_connect(""localhost""); 
$r=ldap_bind($ds);
$sr=ldap_search($ds,""o=My Company, c=US"", $query);  
ldap_close($ds);

?>","$ds=ldap_connect(""localhost"");",True,True,"$query = ""name='"". $tainted . ""'"";


$ds=ldap_connect(""localhost""); 
$r=ldap_bind($ds);
$sr=ldap_search($ds,""o=My Company, c=US"", $query);","```xml
<Issues>
  <Issue>
    <Type>Security</Type>
    <Weakness>CWE-90</Weakness>
    <Description>Improper Neutralization of Special Elements used in an LDAP Query ('LDAP Injection')</Description>
    <Severity>High</Severity>
    <File>File 1</File>
    <Code>$query = ""name='"". $tainted . ""'"";


$ds=ldap_connect(""localhost""); 
$r=ldap_bind($ds);
$sr=ldap_search($ds,""o=My Company, c=US"", $query);  </Code>
    <Justification>The code constructs an LDAP query by directly concatenating user-controlled input ($tainted) without proper sanitization. This allows an attacker to inject malicious LDAP syntax into the query, potentially leading to unauthorized access or modification of data in the LDAP directory. Even though there's a regex check, it's too broad and doesn't prevent LDAP injection.</Justification>
  </Issue>
  <Issue>
    <Type>Security</Type>
    <Weakness>CWE-77</Weakness>
    <Description>Improper Neutralization of Special Elements used in a Command ('Command Injection')</Description>
    <Severity>High</Severity>
    <File>File 1</File>
    <Code>$tainted = shell_exec('cat /tmp/tainted.txt');</Code>
    <Justification>The code uses shell_exec to execute the command 'cat /tmp/tainted.txt'. If the contents of /tmp/tainted.txt are attacker-controlled, they can inject arbitrary commands to be executed by the shell. This constitutes a command injection vulnerability.</Justification>
  </Issue>
</Issues>
```"
CWE-79,src/CWE_79__POST__no_sanitizing__Use_untrusted_data_propertyValue_CSS-quoted_Property_Value.php,"<!-- 
Unsafe sample
input : get the field UserData from the variable $_POST
sanitize : none
File : unsafe, use of untrusted data in a quoted property value (CSS)
-->

<!--Copyright 2015 Bertrand STIVALET 

Permission is hereby granted, without written agreement or royalty fee, to

use, copy, modify, and distribute this software and its documentation for

any purpose, provided that the above copyright notice and the following

three paragraphs appear in all copies of this software.


IN NO EVENT SHALL AUTHORS BE LIABLE TO ANY PARTY FOR DIRECT,

INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES ARISING OUT OF THE 

USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF AUTHORS HAVE

BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.


AUTHORS SPECIFICALLY DISCLAIM ANY WARRANTIES INCLUDING, BUT NOT

LIMITED TO THE IMPLIED WARRANTIES OF MERCHANTABILITY, FITNESS FOR A

PARTICULAR PURPOSE, AND NON-INFRINGEMENT.


THE SOFTWARE IS PROVIDED ON AN ""AS-IS"" BASIS AND AUTHORS HAVE NO

OBLIGATION TO PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR

MODIFICATIONS.-->


<!DOCTYPE html>
<html>
<head>
<style>
<?php
$tainted = $_POST['UserData'];




echo ""body { color :\'"". $tainted .""\' ; }"" ;
?>
</style> 
</head>
<body>
<h1>Hello World!</h1>
</body>
</html>","echo ""body { color :\'"". $tainted .""\' ; }"" ;",True,True,"echo ""body { color :\'"". $tainted .""\' ; }"" ;","```xml
<Issues>
  <Issue>
    <Type>Security</Type>
    <Weakness>CWE-79</Weakness>
    <Description>Improper Neutralization of Input During Web Page Generation ('Cross-site Scripting')</Description>
    <Severity>High</Severity>
    <File>File 1</File>
    <Code>echo ""body { color :\'"". $tainted .""\' ; }"" ;</Code>
    <Justification>The code directly embeds untrusted user input into the CSS style, leading to a cross-site scripting (XSS) vulnerability. An attacker could inject malicious CSS code by manipulating the 'UserData' POST parameter, potentially allowing them to control the appearance of the web page or execute arbitrary JavaScript.</Justification>
  </Issue>
</Issues>
```"
CWE-79,src/CWE_79__object-classicGet__whitelist_using_array__Use_untrusted_data_attribute-Double_Quote_Attr.php,"<!-- 
Unsafe sample
input : get the field userData from the variable $_GET via an object
SANITIZE : use in_array to check if $tainted is in the white list
File : use of untrusted data in a doubled quote attribute
-->

<!--Copyright 2015 Bertrand STIVALET 

Permission is hereby granted, without written agreement or royalty fee, to

use, copy, modify, and distribute this software and its documentation for

any purpose, provided that the above copyright notice and the following

three paragraphs appear in all copies of this software.


IN NO EVENT SHALL AUTHORS BE LIABLE TO ANY PARTY FOR DIRECT,

INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES ARISING OUT OF THE 

USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF AUTHORS HAVE

BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.


AUTHORS SPECIFICALLY DISCLAIM ANY WARRANTIES INCLUDING, BUT NOT

LIMITED TO THE IMPLIED WARRANTIES OF MERCHANTABILITY, FITNESS FOR A

PARTICULAR PURPOSE, AND NON-INFRINGEMENT.


THE SOFTWARE IS PROVIDED ON AN ""AS-IS"" BASIS AND AUTHORS HAVE NO

OBLIGATION TO PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR

MODIFICATIONS.-->


<!DOCTYPE html>
<html>
<head/>
<body>
<?php
class Input{
  private $input;

  public function getInput(){
    return $this->input;
  }

  public  function __construct(){
   $this->input = $_GET['UserData'] ;
  }
}
$temp = new Input();
$tainted =  $temp->getInput();

$legal_table = array(""safe1"", ""safe2"");
if (in_array($tainted, $legal_table, true)) {
  $tainted = $tainted;
} else {
  $tainted = $legal_table[0];
}


echo ""<div id=\"""". $tainted .""\"">content</div>"" ;
?>
<h1>Hello World!</h1>
</body>
</html>","echo ""<div id=\"""". $tainted .""\"">content</div>"" ;",True,True,"$legal_table = array(""safe1"", ""safe2"");
if (in_array($tainted, $legal_table, true)) {
  $tainted = $tainted;
} else {
  $tainted = $legal_table[0];
}


echo ""<div id=\"""". $tainted .""\"">content</div>"" ;","```xml
<Issues>
  <Issue>
    <Type>Security</Type>
    <Weakness>CWE-79</Weakness>
    <Description>Improper Neutralization of Input During Web Page Generation ('Cross-site Scripting')</Description>
    <Severity>Medium</Severity>
    <File>File 1</File>
    <Code>
$legal_table = array(""safe1"", ""safe2"");
if (in_array($tainted, $legal_table, true)) {
  $tainted = $tainted;
} else {
  $tainted = $legal_table[0];
}


echo ""&lt;div id=\"""". $tainted .""\"">content&lt;/div>"" ;</Code>
    <Justification>Even though the code uses a whitelist (`in_array`), it's still vulnerable to XSS if the `$tainted` variable contains characters that are not properly encoded for HTML attribute context. For example, a value like `"" onclick=alert('XSS')""` would be allowed by the whitelist but would still result in XSS.</Justification>
  </Issue>
</Issues>
```"
CWE-79,src/CWE_79__object-Array__func_FILTER-VALIDATION-email_filter__Unsafe_use_untrusted_data-attribute_Name.php,"<!-- 
Unsafe sample
input : get the field userData from the variable $_GET via an object, which store it in a array
Flushes content of $sanitized if the filter email_filter is not applied
File : unsafe, use of untrusted data in an attribute name
-->

<!--Copyright 2015 Bertrand STIVALET 

Permission is hereby granted, without written agreement or royalty fee, to

use, copy, modify, and distribute this software and its documentation for

any purpose, provided that the above copyright notice and the following

three paragraphs appear in all copies of this software.


IN NO EVENT SHALL AUTHORS BE LIABLE TO ANY PARTY FOR DIRECT,

INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES ARISING OUT OF THE 

USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF AUTHORS HAVE

BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.


AUTHORS SPECIFICALLY DISCLAIM ANY WARRANTIES INCLUDING, BUT NOT

LIMITED TO THE IMPLIED WARRANTIES OF MERCHANTABILITY, FITNESS FOR A

PARTICULAR PURPOSE, AND NON-INFRINGEMENT.


THE SOFTWARE IS PROVIDED ON AN ""AS-IS"" BASIS AND AUTHORS HAVE NO

OBLIGATION TO PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR

MODIFICATIONS.-->


<!DOCTYPE html>
<html>
<body>
<?php
class Input{
  private $input;

  public function getInput(){
    return $this->input[1];
  }

  public  function __construct(){
    $this->input = array();
    $this->input[0]= 'safe' ;
    $this->input[1]= $_GET['UserData'] ;
    $this->input[2]= 'safe' ;
  }
}
$temp = new Input();
$tainted =  $temp->getInput();

if (filter_var($sanitized, FILTER_VALIDATE_EMAIL))
  $tainted = $sanitized ;
else
  $tainted = """" ;


echo ""<div "". $tainted .""= bob />"" ;
?>
<h1>Hello World!</h1>
</div>
</body>
</html>","echo ""<div "". $tainted .""= bob />"" ;",True,True,"$tainted =  $temp->getInput();

if (filter_var($sanitized, FILTER_VALIDATE_EMAIL))
  $tainted = $sanitized ;
else
  $tainted = """" ;


echo ""<div "". $tainted .""= bob />"" ;","```xml
<Issues>
  <Issue>
    <Type>Security</Type>
    <Weakness>CWE-79</Weakness>
    <Description>Improper Neutralization of Input During Web Page Generation ('Cross-site Scripting')</Description>
    <Severity>High</Severity>
    <File>File 1</File>
    <Code>$tainted =  $temp->getInput();

if (filter_var($sanitized, FILTER_VALIDATE_EMAIL))
  $tainted = $sanitized ;
else
  $tainted = """" ;


echo ""&lt;div "". $tainted .""= bob />"" ;</Code>
    <Justification>The code uses unsanitized user input ($tainted) directly within an HTML attribute name. While there is an attempt to filter the input using filter_var with FILTER_VALIDATE_EMAIL, the $sanitized variable is not initialized or populated with the user-provided data. Consequently, the filter is never applied to user-provided data. The `else` statement assigns an empty string to `$tainted` if the filter fails on `$sanitized`, but the filtering process is never applied to the actual tainted data. This allows an attacker to inject arbitrary HTML attributes, including malicious JavaScript, leading to a Cross-Site Scripting (XSS) vulnerability.</Justification>
  </Issue>
  <Issue>
    <Type>Reliability</Type>
    <Weakness>CWE-457</Weakness>
    <Description>Use of uninitialized variable</Description>
    <Severity>Medium</Severity>
    <File>File 1</File>
    <Code>if (filter_var($sanitized, FILTER_VALIDATE_EMAIL))
  $tainted = $sanitized ;
else
  $tainted = """" ;</Code>
    <Justification>The code uses the variable `$sanitized` without initializing it. This can lead to unpredictable behavior, as the variable may contain an unexpected value.</Justification>
  </Issue>
</Issues>
```"
CWE-89,src/CWE_89__popen__no_sanitizing__multiple_select-interpretation.php,"<?php







$handle = popen('/bin/cat /tmp/tainted.txt', 'r');
$tainted = fread($handle, 4096);
pclose($handle);



$query = ""SELECT * FROM COURSE c WHERE c.id IN (SELECT idcourse FROM REGISTRATION WHERE idstudent= $tainted )"";


$conn = mysql_connect('localhost', 'mysql_user', 'mysql_password'); 
mysql_select_db('dbname') ;
echo ""query : "". $query .""<br /><br />"" ;

$res = mysql_query($query); 

while($data =mysql_fetch_array($res)){
print_r($data) ;
echo ""<br />"" ;
} 
mysql_close($conn);

?>","$conn = mysql_connect('localhost', 'mysql_user', 'mysql_password'); ",True,True,"$handle = popen('/bin/cat /tmp/tainted.txt', 'r');
$tainted = fread($handle, 4096);
pclose($handle);



$query = ""SELECT * FROM COURSE c WHERE c.id IN (SELECT idcourse FROM REGISTRATION WHERE idstudent= $tainted )"";","```xml
<Issues>
  <Issue>
    <Type>Security</Type>
    <Weakness>CWE-89</Weakness>
    <Description>Improper Neutralization of Special Elements used in an SQL Command ('SQL Injection')</Description>
    <Severity>High</Severity>
    <File>File 1</File>
    <Code>$handle = popen('/bin/cat /tmp/tainted.txt', 'r');
$tainted = fread($handle, 4096);
pclose($handle);



$query = ""SELECT * FROM COURSE c WHERE c.id IN (SELECT idcourse FROM REGISTRATION WHERE idstudent= $tainted )"";</Code>
    <Justification>The code is vulnerable to SQL injection because it directly incorporates the value of $tainted (read from a file) into the SQL query without proper sanitization or validation. An attacker could manipulate the contents of /tmp/tainted.txt to inject malicious SQL code, potentially compromising the database.</Justification>
  </Issue>
  <Issue>
    <Type>Security</Type>
    <Weakness>CWE-78</Weakness>
    <Description>Improper Neutralization of Special Elements used in a Command ('Command Injection')</Description>
    <Severity>High</Severity>
    <File>File 1</File>
    <Code>$handle = popen('/bin/cat /tmp/tainted.txt', 'r');</Code>
    <Justification>The code uses popen to execute a command to read a file. While in this specific example, the command is hardcoded, if the first argument to popen were to accept user input, this could lead to command injection. Even with the hardcoded command, there's a risk if the file path '/tmp/tainted.txt' is modifiable via external means, potentially leading to arbitrary command execution.</Justification>
  </Issue>
  <Issue>
    <Type>Security</Type>
    <Weakness>CWE-477</Weakness>
    <Description>Use of Obsolete Function</Description>
    <Severity>Low</Severity>
    <File>File 1</File>
    <Code>$conn = mysql_connect('localhost', 'mysql_user', 'mysql_password'); 
mysql_select_db('dbname') ;
echo ""query : "". $query .""&lt;br /&gt;&lt;br /&gt;"" ;

$res = mysql_query($query); </Code>
    <Justification>The code uses the mysql_connect and mysql_query functions, which are deprecated. These functions are no longer maintained and have known security vulnerabilities. It is recommended to use MySQLi or PDO instead.</Justification>
  </Issue>
</Issues>
```"
CWE-91,src/CWE_91__SESSION__func_mysql_real_escape_string__ID_test-concatenation.php,"<?php







$tainted = $_SESSION['UserData'];

$tainted = mysql_real_escape_string($tainted);

$query = ""


$xml = simplexml_load_file(""users.xml"");
echo ""query : "". $query .""<br /><br />"" ;

$res=$xml->xpath($query);
print_r($res);
echo ""<br />"" ;

?>","$xml = simplexml_load_file(""users.xml"");",True,True,"$tainted = $_SESSION['UserData'];

$tainted = mysql_real_escape_string($tainted);

$query = ""","```xml
<Issues>
  <Issue>
    <Type>Security</Type>
    <Weakness>CWE-91</Weakness>
    <Description>XML Injection (aka Blind XPath Injection)</Description>
    <Severity>High</Severity>
    <File>File 1</File>
    <Code>$tainted = $_SESSION['UserData'];

$tainted = mysql_real_escape_string($tainted);

$query = ""</Code>
    <Justification>The code is vulnerable to XML Injection because it uses unsanitized user input ($_SESSION['UserData']) to construct an XPath query. Even though mysql_real_escape_string is used, it is intended for SQL, not XML, and therefore does not prevent XML injection. An attacker could manipulate the XPath query to extract sensitive information or cause denial of service.</Justification>
  </Issue>
</Issues>
```"
CWE-79,src/CWE_79__proc_open__func_rawurlencode__Unsafe_use_untrusted_data-attribute_Name.php,"<!-- 
Unsafe sample
input : use proc_open to read /tmp/tainted.txt
SANITIZE : use of rawurlencode
File : unsafe, use of untrusted data in an attribute name
-->

<!--Copyright 2015 Bertrand STIVALET 

Permission is hereby granted, without written agreement or royalty fee, to

use, copy, modify, and distribute this software and its documentation for

any purpose, provided that the above copyright notice and the following

three paragraphs appear in all copies of this software.


IN NO EVENT SHALL AUTHORS BE LIABLE TO ANY PARTY FOR DIRECT,

INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES ARISING OUT OF THE 

USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF AUTHORS HAVE

BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.


AUTHORS SPECIFICALLY DISCLAIM ANY WARRANTIES INCLUDING, BUT NOT

LIMITED TO THE IMPLIED WARRANTIES OF MERCHANTABILITY, FITNESS FOR A

PARTICULAR PURPOSE, AND NON-INFRINGEMENT.


THE SOFTWARE IS PROVIDED ON AN ""AS-IS"" BASIS AND AUTHORS HAVE NO

OBLIGATION TO PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR

MODIFICATIONS.-->


<!DOCTYPE html>
<html>
<body>
<?php
$descriptorspec = array(
  0 => array(""pipe"", ""r""),
  1 => array(""pipe"", ""w""),
  2 => array(""file"", ""/tmp/error-output.txt"", ""a"")
  );
$cwd = '/tmp';
$process = proc_open('more /tmp/tainted.txt', $descriptorspec, $pipes, $cwd, NULL);
if (is_resource($process)) {
  fclose($pipes[0]);
  $tainted = stream_get_contents($pipes[1]);
  fclose($pipes[1]);
  $return_value = proc_close($process);
}

$tainted = rawurlencode($tainted);


echo ""<div "". $tainted .""= bob />"" ;
?>
<h1>Hello World!</h1>
</div>
</body>
</html>","echo ""<div "". $tainted .""= bob />"" ;",True,True,"$tainted = rawurlencode($tainted);


echo ""<div "". $tainted .""= bob />"" ;
?>
<h1>Hello World!</h1>","```xml
<Issues>
  <Issue>
    <Type>Security</Type>
    <Weakness>CWE-79</Weakness>
    <Description>Improper Neutralization of Input During Web Page Generation ('Cross-site Scripting')</Description>
    <Severity>Medium</Severity>
    <File>File 1</File>
    <Code>
$tainted = rawurlencode($tainted);


echo ""&lt;div "". $tainted .""= bob />"" ;
?>
&lt;h1>Hello World!&lt;/h1>
</Code>
    <Justification>The code uses external input ($tainted) in an HTML attribute name. Although rawurlencode is used, it's insufficient to prevent XSS if the input contains characters that are still interpreted as part of the HTML structure.  Specifically, using untrusted data in an attribute name can lead to script execution if the attribute name is crafted to inject malicious JavaScript.</Justification>
  </Issue>
  <Issue>
    <Type>Security</Type>
    <Weakness>CWE-22</Weakness>
    <Description>Improper Limitation of a Pathname to a Restricted Directory ('Path Traversal')</Description>
    <Severity>High</Severity>
    <File>File 1</File>
    <Code>
$process = proc_open('more /tmp/tainted.txt', $descriptorspec, $pipes, $cwd, NULL);
if (is_resource($process)) {
  fclose($pipes[0]);
  $tainted = stream_get_contents($pipes[1]);
  fclose($pipes[1]);
  $return_value = proc_close($process);
}
</Code>
    <Justification>The code reads data from '/tmp/tainted.txt' using proc_open. While the code itself doesn't directly use user-supplied input to construct the path, the contents of this file are then used unsafely. If an attacker can control the contents of /tmp/tainted.txt, they can inject arbitrary data into the HTML, leading to cross-site scripting.</Justification>
  </Issue>
  <Issue>
    <Type>Reliability</Type>
    <Weakness>CWE-252</Weakness>
    <Description>Unchecked Return Value</Description>
    <Severity>Low</Severity>
    <File>File 1</File>
    <Code>
$process = proc_open('more /tmp/tainted.txt', $descriptorspec, $pipes, $cwd, NULL);
if (is_resource($process)) {
  fclose($pipes[0]);
  $tainted = stream_get_contents($pipes[1]);
  fclose($pipes[1]);
  $return_value = proc_close($process);
}
</Code>
    <Justification>The code does not check the return value of proc_open, stream_get_contents, or proc_close. If these functions fail, the program may continue execution with unexpected results.</Justification>
  </Issue>
</Issues>
```"
CWE-90,src/CWE_90__POST__func_FILTER-CLEANING-email_filter__not_name-sprintf_%s_simple_quote.php,"<?php







$tainted = $_POST['UserData'];

$sanitized = filter_var($tainted, FILTER_SANITIZE_EMAIL);
if (filter_var($sanitized, FILTER_VALIDATE_EMAIL))
  $tainted = $sanitized ;
else
  $tainted = """" ;

$query = sprintf(""!name='%s'"", $tainted);


$ds=ldap_connect(""localhost""); 
$r=ldap_bind($ds);
$sr=ldap_search($ds,""o=My Company, c=US"", $query);  
ldap_close($ds);

?>","$ds=ldap_connect(""localhost"");",True,False,"$query = sprintf(""!name='%s'"", $tainted);","```xml
<Issues>
  <Issue>
    <Type>Security</Type>
    <Weakness>CWE-90</Weakness>
    <Description>Improper Neutralization of Special Elements used in an LDAP Query ('LDAP Injection')</Description>
    <Severity>High</Severity>
    <File>File 1</File>
    <Code>$query = sprintf(""!name='%s'"", $tainted);</Code>
    <Justification>The code constructs an LDAP query using unsanitized user input, making it vulnerable to LDAP injection attacks.  Even though the email is validated, it doesn't prevent LDAP injection.</Justification>
  </Issue>
  <Issue>
    <Type>Reliability</Type>
    <Weakness>CWE-252</Weakness>
    <Description>Unchecked Return Value</Description>
    <Severity>Medium</Severity>
    <File>File 1</File>
    <Code>$ds=ldap_connect(""localhost""); 
$r=ldap_bind($ds);
$sr=ldap_search($ds,""o=My Company, c=US"", $query);</Code>
    <Justification>The code does not check the return values of ldap_connect, ldap_bind, and ldap_search. Failure of any of these functions could lead to unexpected behavior or security vulnerabilities.</Justification>
  </Issue>
</Issues>
```"
CWE-89,src/CWE_89__object-classicGet__func_FILTER-CLEANING-special_chars_filter__select_from-concatenation_simple_quote.php,"<?php







class Input{
  private $input;

  public function getInput(){
    return $this->input;
  }

  public  function __construct(){
   $this->input = $_GET['UserData'] ;
  }
}
$temp = new Input();
$tainted =  $temp->getInput();

$sanitized = filter_var($tainted, FILTER_SANITIZE_SPECIAL_CHARS);
  $tainted = $sanitized ;
      

$query = ""SELECT * FROM '"". $tainted . ""'"";


$conn = mysql_connect('localhost', 'mysql_user', 'mysql_password'); 
mysql_select_db('dbname') ;
echo ""query : "". $query .""<br /><br />"" ;

$res = mysql_query($query); 

while($data =mysql_fetch_array($res)){
print_r($data) ;
echo ""<br />"" ;
} 
mysql_close($conn);

?>","$conn = mysql_connect('localhost', 'mysql_user', 'mysql_password'); ",True,False,"$query = ""SELECT * FROM '"". $tainted . ""'"";","```xml
<Issues>
  <Issue>
    <Type>Security</Type>
    <Weakness>CWE-89</Weakness>
    <Description>Improper Neutralization of Special Elements used in an SQL Command ('SQL Injection')</Description>
    <Severity>Critical</Severity>
    <File>File 1</File>
    <Code>$query = ""SELECT * FROM '"". $tainted . ""'"";</Code>
    <Justification>The code constructs an SQL query by directly concatenating user-supplied input ($tainted) without proper sanitization or parameterization. This allows an attacker to inject arbitrary SQL code, potentially compromising the database.</Justification>
  </Issue>
  <Issue>
    <Type>Security</Type>
    <Weakness>CWE-477</Weakness>
    <Description>Use of Obsolete Function</Description>
    <Severity>High</Severity>
    <File>File 1</File>
    <Code>$conn = mysql_connect('localhost', 'mysql_user', 'mysql_password'); 
mysql_select_db('dbname') ;
echo ""query : "". $query .""&lt;br /&gt;&lt;br /&gt;"" ;

$res = mysql_query($query); </Code>
    <Justification>The code uses the 'mysql_connect' and 'mysql_query' functions, which are deprecated. These functions are known to have security vulnerabilities and lack modern security features.  It is recommended to use MySQLi or PDO instead.</Justification>
  </Issue>
  <Issue>
    <Type>Security</Type>
    <Weakness>CWE-252</Weakness>
    <Description>Unchecked Return Value</Description>
    <Severity>Medium</Severity>
    <File>File 1</File>
    <Code>$conn = mysql_connect('localhost', 'mysql_user', 'mysql_password'); 
mysql_select_db('dbname') ;
echo ""query : "". $query .""&lt;br /&gt;&lt;br /&gt;"" ;

$res = mysql_query($query); </Code>
    <Justification>The code does not check the return values of 'mysql_connect', 'mysql_select_db', and 'mysql_query'. If any of these functions fail, the script will continue execution, potentially leading to unexpected behavior or security vulnerabilities. For example, a failed database connection could result in subsequent queries operating on an invalid connection.</Justification>
  </Issue>
  <Issue>
    <Type>Security</Type>
    <Weakness>CWE-798</Weakness>
    <Description>Use of Hard-coded Credentials</Description>
    <Severity>Critical</Severity>
    <File>File 1</File>
    <Code>$conn = mysql_connect('localhost', 'mysql_user', 'mysql_password'); </Code>
    <Justification>The code uses hard-coded credentials ('mysql_user', 'mysql_password') for connecting to the database. This is a security risk because if the code is compromised, the attacker will have direct access to the database credentials.</Justification>
  </Issue>
  <Issue>
    <Type>Security</Type>
    <Weakness>CWE-22</Weakness>
    <Description>Improper Limitation of a Pathname to a Restricted Directory ('Path Traversal')</Description>
    <Severity>High</Severity>
    <File>File 1</File>
    <Code>$this->input = $_GET['UserData'] ;</Code>
    <Justification>The code retrieves user input from $_GET['UserData'] without proper validation or sanitization before using it in a SQL query. Although `filter_var` is used, it's used incorrectly. The `FILTER_SANITIZE_SPECIAL_CHARS` filter does not prevent SQL injection, as it only encodes some characters and does not prevent malicious SQL code from being executed.  An attacker can still manipulate the input to potentially access or modify restricted parts of the database.</Justification>
  </Issue>
</Issues>
```"
CWE-79,src/CWE_79__object-directGet__no_sanitizing__Use_untrusted_data_script-side_Quoted_Expr.php,"<!-- 
Unsafe sample
input : get the field userData from the variable $_GET via an object
sanitize : none
File : use of untrusted data in one side of a quoted expression in a script
-->

<!--Copyright 2015 Bertrand STIVALET 

Permission is hereby granted, without written agreement or royalty fee, to

use, copy, modify, and distribute this software and its documentation for

any purpose, provided that the above copyright notice and the following

three paragraphs appear in all copies of this software.


IN NO EVENT SHALL AUTHORS BE LIABLE TO ANY PARTY FOR DIRECT,

INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES ARISING OUT OF THE 

USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF AUTHORS HAVE

BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.


AUTHORS SPECIFICALLY DISCLAIM ANY WARRANTIES INCLUDING, BUT NOT

LIMITED TO THE IMPLIED WARRANTIES OF MERCHANTABILITY, FITNESS FOR A

PARTICULAR PURPOSE, AND NON-INFRINGEMENT.


THE SOFTWARE IS PROVIDED ON AN ""AS-IS"" BASIS AND AUTHORS HAVE NO

OBLIGATION TO PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR

MODIFICATIONS.-->


<!DOCTYPE html>
<html>
<head>
<script>
<?php
class Input{
  public function getInput(){
    return $_GET['UserData'] ;
  }
}

$temp = new Input();
$tainted =  $temp->getInput();




echo ""x='"". $tainted .""'"" ;
?>
</script>
</head>
<body>
<h1>Hello World!</h1>
</body>
</html>","echo ""x='"". $tainted .""'"" ;",True,True,"echo ""x='"". $tainted .""'"" ;","```xml
<Issues>
  <Issue>
    <Type>Security</Type>
    <Weakness>CWE-79</Weakness>
    <Description>Improper Neutralization of Input During Web Page Generation ('Cross-site Scripting')</Description>
    <Severity>High</Severity>
    <File>File 1</File>
    <Code>echo ""x='"". $tainted .""'"" ;</Code>
    <Justification>The code echoes user-controlled input ($tainted) directly into the output without proper neutralization, leading to a cross-site scripting (XSS) vulnerability. An attacker can inject malicious script into the output, which will be executed by the victim's browser.</Justification>
  </Issue>
</Issues>
```"
CWE-79,src/CWE_79__fopen__func_FILTER-CLEANING-magic_quotes_filter__Use_untrusted_data_attribute-unquoted_Attr.php,"<!-- 
Unsafe sample
input : use fopen to read /tmp/tainted.txt and put the first line in $tainted
Uses a magic_quotes_filter via filter_var function
File : use of untrusted data in a unquoted attribute
-->

<!--Copyright 2015 Bertrand STIVALET 

Permission is hereby granted, without written agreement or royalty fee, to

use, copy, modify, and distribute this software and its documentation for

any purpose, provided that the above copyright notice and the following

three paragraphs appear in all copies of this software.


IN NO EVENT SHALL AUTHORS BE LIABLE TO ANY PARTY FOR DIRECT,

INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES ARISING OUT OF THE 

USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF AUTHORS HAVE

BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.


AUTHORS SPECIFICALLY DISCLAIM ANY WARRANTIES INCLUDING, BUT NOT

LIMITED TO THE IMPLIED WARRANTIES OF MERCHANTABILITY, FITNESS FOR A

PARTICULAR PURPOSE, AND NON-INFRINGEMENT.


THE SOFTWARE IS PROVIDED ON AN ""AS-IS"" BASIS AND AUTHORS HAVE NO

OBLIGATION TO PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR

MODIFICATIONS.-->


<!DOCTYPE html>
<html>
<head/>
<body>
<?php
$handle = @fopen(""/tmp/tainted.txt"", ""r"");

if ($handle) {
  if(($tainted = fgets($handle, 4096)) == false) {
    $tainted = """";
  }
  fclose($handle);
} else {
  $tainted = """";
}

$sanitized = filter_var($tainted, FILTER_SANITIZE_MAGIC_QUOTES);
  $tainted = $sanitized ;
      


echo ""<div id="". $tainted ."">content</div>"" ;
?>
<h1>Hello World!</h1>
</body>
</html>","echo ""<div id="". $tainted ."">content</div>"" ;",True,True,"echo ""<div id="". $tainted ."">content</div>"" ;","```xml
<Issues>
  <Issue>
    <Type>Security</Type>
    <Weakness>CWE-79</Weakness>
    <Description>Improper Neutralization of Input During Web Page Generation ('Cross-site Scripting')</Description>
    <Severity>Medium</Severity>
    <File>File 1</File>
    <Code>echo ""&lt;div id="". $tainted ."">content&lt;/div>"" ;</Code>
    <Justification>The code uses external input ($tainted) to construct part of a web page without proper neutralization. An attacker could inject malicious script into the 'id' attribute, leading to Cross-Site Scripting (XSS).</Justification>
  </Issue>
</Issues>
```"
CWE-89,src/CWE_89__object-Array__func_FILTER-CLEANING-email_filter__join-sprintf_%s_simple_quote.php,"<?php







class Input{
  private $input;

  public function getInput(){
    return $this->input[1];
  }

  public  function __construct(){
    $this->input = array();
    $this->input[0]= 'safe' ;
    $this->input[1]= $_GET['UserData'] ;
    $this->input[2]= 'safe' ;
  }
}
$temp = new Input();
$tainted =  $temp->getInput();

$sanitized = filter_var($tainted, FILTER_SANITIZE_EMAIL);
if (filter_var($sanitized, FILTER_VALIDATE_EMAIL))
  $tainted = $sanitized ;
else
  $tainted = """" ;

$query = sprintf(""SELECT lastname, firstname FROM drivers, vehicles WHERE drivers.id = vehicles.ownerid AND vehicles.tag='%s'"", $tainted);


$conn = mysql_connect('localhost', 'mysql_user', 'mysql_password'); 
mysql_select_db('dbname') ;
echo ""query : "". $query .""<br /><br />"" ;

$res = mysql_query($query); 

while($data =mysql_fetch_array($res)){
print_r($data) ;
echo ""<br />"" ;
} 
mysql_close($conn);

?>","$conn = mysql_connect('localhost', 'mysql_user', 'mysql_password'); ",True,False,"$query = sprintf(""SELECT lastname, firstname FROM drivers, vehicles WHERE drivers.id = vehicles.ownerid AND vehicles.tag='%s'"", $tainted);","```xml
<Issues>
  <Issue>
    <Type>Security</Type>
    <Weakness>CWE-89</Weakness>
    <Description>Improper Neutralization of Special Elements used in an SQL Command ('SQL Injection')</Description>
    <Severity>High</Severity>
    <File>File 1</File>
    <Code>$query = sprintf(""SELECT lastname, firstname FROM drivers, vehicles WHERE drivers.id = vehicles.ownerid AND vehicles.tag='%s'"", $tainted);</Code>
    <Justification>The code uses sprintf to construct a SQL query with user-provided data ($tainted) without proper sanitization, leading to SQL injection vulnerability.</Justification>
  </Issue>
  <Issue>
    <Type>Security</Type>
    <Weakness>CWE-477</Weakness>
    <Description>Use of Obsolete Function</Description>
    <Severity>Medium</Severity>
    <File>File 1</File>
    <Code>$conn = mysql_connect('localhost', 'mysql_user', 'mysql_password'); 
mysql_select_db('dbname') ;
echo ""query : "". $query .""&lt;br /&gt;&lt;br /&gt;"" ;

$res = mysql_query($query); </Code>
    <Justification>The code uses the mysql_connect and mysql_query functions, which are deprecated. This suggests the code has not been actively maintained and could be using other outdated and potentially insecure practices.</Justification>
  </Issue>
  <Issue>
    <Type>Reliability</Type>
    <Weakness>CWE-252</Weakness>
    <Description>Unchecked Return Value</Description>
    <Severity>Medium</Severity>
    <File>File 1</File>
    <Code>$conn = mysql_connect('localhost', 'mysql_user', 'mysql_password'); 
mysql_select_db('dbname') ;
echo ""query : "". $query .""&lt;br /&gt;&lt;br /&gt;"" ;

$res = mysql_query($query); </Code>
    <Justification>The code does not check the return values of mysql_connect, mysql_select_db, and mysql_query. If any of these functions fail, the script will continue to execute, potentially leading to unexpected behavior or errors.</Justification>
  </Issue>
  <Issue>
    <Type>Security</Type>
    <Weakness>CWE-798</Weakness>
    <Description>Use of Hard-coded Credentials</Description>
    <Severity>Critical</Severity>
    <File>File 1</File>
    <Code>$conn = mysql_connect('localhost', 'mysql_user', 'mysql_password');</Code>
    <Justification>The code uses hard-coded database credentials ('mysql_user', 'mysql_password'), which poses a significant security risk. If the code is compromised, the database credentials will be exposed.</Justification>
  </Issue>
  <Issue>
    <Type>Maintainability</Type>
    <Weakness>CWE-1052</Weakness>
    <Description>Excessive Use of Hard-Coded Literals in Initialization</Description>
    <Severity>Low</Severity>
    <File>File 1</File>
    <Code>    $this->input = array();
    $this->input[0]= 'safe' ;
    $this->input[1]= $_GET['UserData'] ;
    $this->input[2]= 'safe' ;</Code>
    <Justification>The code initializes the $input array with hard-coded literal values ('safe'). While not inherently a security risk, excessive use of hard-coded literals reduces maintainability and makes it harder to update or change the application's behavior.</Justification>
  </Issue>
  <Issue>
    <Type>Security</Type>
    <Weakness>CWE-665</Weakness>
    <Description>Improper Initialization</Description>
    <Severity>Medium</Severity>
    <File>File 1</File>
    <Code>  private $input;

  public function getInput(){
    return $this->input[1];
  }

  public  function __construct(){
    $this->input = array();
    $this->input[0]= 'safe' ;
    $this->input[1]= $_GET['UserData'] ;
    $this->input[2]= 'safe' ;
  }</Code>
    <Justification>The private member $input is not initialized to null. If the constructor is never called or if there is a logic error where the array assignment doesn't happen it could cause issues elsewhere</Justification>
  </Issue>
</Issues>
```"
CWE-79,src/CWE_79__fopen__func_FILTER-CLEANING-number_float_filter__Use_untrusted_data_propertyValue_CSS-quoted_Property_Value.php,"<!-- 
Unsafe sample
input : use fopen to read /tmp/tainted.txt and put the first line in $tainted
Uses a number_float_filter via filter_var function
File : unsafe, use of untrusted data in a quoted property value (CSS)
-->

<!--Copyright 2015 Bertrand STIVALET 

Permission is hereby granted, without written agreement or royalty fee, to

use, copy, modify, and distribute this software and its documentation for

any purpose, provided that the above copyright notice and the following

three paragraphs appear in all copies of this software.


IN NO EVENT SHALL AUTHORS BE LIABLE TO ANY PARTY FOR DIRECT,

INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES ARISING OUT OF THE 

USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF AUTHORS HAVE

BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.


AUTHORS SPECIFICALLY DISCLAIM ANY WARRANTIES INCLUDING, BUT NOT

LIMITED TO THE IMPLIED WARRANTIES OF MERCHANTABILITY, FITNESS FOR A

PARTICULAR PURPOSE, AND NON-INFRINGEMENT.


THE SOFTWARE IS PROVIDED ON AN ""AS-IS"" BASIS AND AUTHORS HAVE NO

OBLIGATION TO PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR

MODIFICATIONS.-->


<!DOCTYPE html>
<html>
<head>
<style>
<?php
$handle = @fopen(""/tmp/tainted.txt"", ""r"");

if ($handle) {
  if(($tainted = fgets($handle, 4096)) == false) {
    $tainted = """";
  }
  fclose($handle);
} else {
  $tainted = """";
}

$sanitized = filter_var($tainted, FILTER_SANITIZE_NUMBER_FLOAT);
if (filter_var($sanitized, FILTER_VALIDATE_FLOAT))
  $tainted = $sanitized ;
else
  $tainted = """" ;


echo ""body { color :\'"". $tainted .""\' ; }"" ;
?>
</style> 
</head>
<body>
<h1>Hello World!</h1>
</body>
</html>","echo ""body { color :\'"". $tainted .""\' ; }"" ;",True,True,"echo ""body { color :\'"". $tainted .""\' ; }"" ;","```xml
<Issues>
  <Issue>
    <Type>Security</Type>
    <Weakness>CWE-79</Weakness>
    <Description>Improper Neutralization of Input During Web Page Generation ('Cross-site Scripting')</Description>
    <Severity>Medium</Severity>
    <File>File 1</File>
    <Code>echo ""body { color :\'"". $tainted .""\' ; }"" ;</Code>
    <Justification>The code echoes unsanitized input `$tainted` directly into the CSS style, which can lead to XSS vulnerabilities if the input contains malicious code. Although the code attempts to sanitize the input using `filter_var`, it only allows floating-point numbers. An attacker could still inject valid CSS properties that could alter the appearance of the page or potentially leak information.</Justification>
  </Issue>
  <Issue>
    <Type>Reliability</Type>
    <Weakness>CWE-252</Weakness>
    <Description>Unchecked Return Value</Description>
    <Severity>Low</Severity>
    <File>File 1</File>
    <Code>  if(($tainted = fgets($handle, 4096)) == false) {
    $tainted = """";
  }
  fclose($handle);</Code>
    <Justification>The code does not check the return value of `fclose()`. Although rare, `fclose()` can fail, and not checking for this failure can lead to resource leaks or other unexpected behavior.</Justification>
  </Issue>
  <Issue>
    <Type>Security</Type>
    <Weakness>CWE-424</Weakness>
    <Description>Improper Protection of Alternate Path</Description>
    <Severity>Low</Severity>
    <File>File 1</File>
    <Code>if ($handle) {
  if(($tainted = fgets($handle, 4096)) == false) {
    $tainted = """";
  }
  fclose($handle);
} else {
  $tainted = """";
}</Code>
    <Justification>The code attempts to read from `/tmp/tainted.txt`. If the file does not exist or is not readable, the `$handle` will be false, and `$tainted` is set to an empty string. However, if the file exists but contains malicious content, the sanitization may be insufficient, potentially leading to security issues. The alternate path of not being able to read the file is handled, but the contents of a successfully read file may still be harmful.</Justification>
  </Issue>
  <Issue>
    <Type>Reliability</Type>
    <Weakness>CWE-703</Weakness>
    <Description>Improper Check or Handling of Exceptional Conditions</Description>
    <Severity>Low</Severity>
    <File>File 1</File>
    <Code>if ($handle) {
  if(($tainted = fgets($handle, 4096)) == false) {
    $tainted = """";
  }
  fclose($handle);
} else {
  $tainted = """";
}</Code>
    <Justification>The code checks if `$handle` is valid after attempting to open the file, but it does not handle potential errors that might occur during the `fgets()` operation (e.g., if the file is unexpectedly closed or if there's a read error other than reaching the end of the file). While it sets `$tainted` to an empty string if `fgets()` returns `false`, it doesn't log or otherwise report the error, potentially masking issues that might need attention.</Justification>
  </Issue>
</Issues>
```"
CWE-89,src/CWE_89__GET__func_FILTER-VALIDATION-email_filter__select_from-interpretation_simple_quote.php,"<?php







$tainted = $_GET['UserData'];

if (filter_var($sanitized, FILTER_VALIDATE_EMAIL))
  $tainted = $sanitized ;
else
  $tainted = """" ;

$query = ""SELECT * FROM ' $tainted '"";


$conn = mysql_connect('localhost', 'mysql_user', 'mysql_password'); 
mysql_select_db('dbname') ;
echo ""query : "". $query .""<br /><br />"" ;

$res = mysql_query($query); 

while($data =mysql_fetch_array($res)){
print_r($data) ;
echo ""<br />"" ;
} 
mysql_close($conn);

?>","$conn = mysql_connect('localhost', 'mysql_user', 'mysql_password'); ",True,True,"$tainted = $_GET['UserData'];

if (filter_var($sanitized, FILTER_VALIDATE_EMAIL))
  $tainted = $sanitized ;
else
  $tainted = """" ;

$query = ""SELECT * FROM ' $tainted '"";


$conn = mysql_connect('localhost', 'mysql_user', 'mysql_password'); 
mysql_select_db('dbname') ;
echo ""query : "". $query .""<br /><br />"" ;

$res = mysql_query($query);","```xml
<Issues>
  <Issue>
    <Type>Security</Type>
    <Weakness>CWE-89</Weakness>
    <Description>Improper Neutralization of Special Elements used in an SQL Command ('SQL Injection')</Description>
    <Severity>Critical</Severity>
    <File>File 1</File>
    <Code>$tainted = $_GET['UserData'];

if (filter_var($sanitized, FILTER_VALIDATE_EMAIL))
  $tainted = $sanitized ;
else
  $tainted = """" ;

$query = ""SELECT * FROM ' $tainted '"";


$conn = mysql_connect('localhost', 'mysql_user', 'mysql_password'); 
mysql_select_db('dbname') ;
echo ""query : "". $query .""&lt;br /&gt;&lt;br /&gt;"" ;

$res = mysql_query($query); </Code>
    <Justification>The code is vulnerable to SQL injection because it directly incorporates user-supplied data ($tainted) into the SQL query without proper sanitization or escaping. An attacker could manipulate the $tainted variable to inject malicious SQL code, potentially compromising the database.</Justification>
  </Issue>
  <Issue>
    <Type>Security</Type>
    <Weakness>CWE-477</Weakness>
    <Description>Use of Obsolete Function</Description>
    <Severity>High</Severity>
    <File>File 1</File>
    <Code>$conn = mysql_connect('localhost', 'mysql_user', 'mysql_password'); 
mysql_select_db('dbname') ;
echo ""query : "". $query .""&lt;br /&gt;&lt;br /&gt;"" ;

$res = mysql_query($query); </Code>
    <Justification>The code uses the `mysql_connect` and `mysql_query` functions, which are deprecated. Using deprecated functions can lead to security vulnerabilities as they may not receive security updates or have known weaknesses.</Justification>
  </Issue>
  <Issue>
    <Type>Reliability</Type>
    <Weakness>CWE-252</Weakness>
    <Description>Unchecked Return Value</Description>
    <Severity>Medium</Severity>
    <File>File 1</File>
    <Code>$conn = mysql_connect('localhost', 'mysql_user', 'mysql_password'); 
mysql_select_db('dbname') ;
echo ""query : "". $query .""&lt;br /&gt;&lt;br /&gt;"" ;

$res = mysql_query($query); </Code>
    <Justification>The code does not check the return value of `mysql_connect` and `mysql_query`. If these functions fail, they will return FALSE, and the script will continue to execute, potentially leading to errors or unexpected behavior.</Justification>
  </Issue>
  <Issue>
    <Type>Security</Type>
    <Weakness>CWE-798</Weakness>
    <Description>Use of Hard-coded Credentials</Description>
    <Severity>Critical</Severity>
    <File>File 1</File>
    <Code>$conn = mysql_connect('localhost', 'mysql_user', 'mysql_password'); </Code>
    <Justification>The code uses hard-coded database credentials (`mysql_user`, `mysql_password`). This is a major security risk because if the code is compromised, the database credentials will be exposed.</Justification>
  </Issue>
  <Issue>
    <Type>Reliability</Type>
    <Weakness>CWE-390</Weakness>
    <Description>Detection of Error Condition Without Action</Description>
    <Severity>Low</Severity>
    <File>File 1</File>
    <Code>if (filter_var($sanitized, FILTER_VALIDATE_EMAIL))
  $tainted = $sanitized ;
else
  $tainted = """" ;</Code>
    <Justification>The code validates email but if it is an invalid email, it assigns an empty string to $tainted, which could result in an unexpected query, but does not report that an error has occurred.</Justification>
  </Issue>
</Issues>
```"
CWE-90,src/CWE_90__SESSION__func_htmlentities__not_name-concatenation_simple_quote.php,"<?php







$tainted = $_SESSION['UserData'];

$tainted = htmlentities($tainted, ENT_QUOTES);

$query = ""!name='"". $tainted . ""'"";


$ds=ldap_connect(""localhost""); 
$r=ldap_bind($ds);
$sr=ldap_search($ds,""o=My Company, c=US"", $query);  
ldap_close($ds);

?>","$ds=ldap_connect(""localhost"");",True,True,"$tainted = $_SESSION['UserData'];

$tainted = htmlentities($tainted, ENT_QUOTES);

$query = ""!name='"". $tainted . ""'"";


$ds=ldap_connect(""localhost""); 
$r=ldap_bind($ds);
$sr=ldap_search($ds,""o=My Company, c=US"", $query);  
ldap_close($ds);","```xml
<Issues>
  <Issue>
    <Type>Security</Type>
    <Weakness>CWE-90</Weakness>
    <Description>Improper Neutralization of Special Elements used in an LDAP Query ('LDAP Injection')</Description>
    <Severity>High</Severity>
    <File>File 1</File>
    <Code>$tainted = $_SESSION['UserData'];

$tainted = htmlentities($tainted, ENT_QUOTES);

$query = ""!name='"". $tainted . ""'"";


$ds=ldap_connect(""localhost""); 
$r=ldap_bind($ds);
$sr=ldap_search($ds,""o=My Company, c=US"", $query);  
ldap_close($ds);</Code>
    <Justification>The code constructs an LDAP query by directly embedding user-controlled data ($tainted) into the query string. Even though htmlentities is used, it might not be sufficient to prevent LDAP injection, as certain characters relevant to LDAP syntax might not be properly neutralized. An attacker could manipulate the input to inject arbitrary LDAP commands, potentially gaining unauthorized access to or control over the LDAP directory.</Justification>
  </Issue>
</Issues>
```"
CWE-79,src/CWE_79__fopen__func_http_build_query__Unsafe_use_untrusted_data-tag_Name.php,"<!-- 
Unsafe sample
input : use fopen to read /tmp/tainted.txt and put the first line in $tainted
SANITIZE : use of http_build_query
File : unsafe, use of untrusted data in an tag name
-->

<!--Copyright 2015 Bertrand STIVALET 

Permission is hereby granted, without written agreement or royalty fee, to

use, copy, modify, and distribute this software and its documentation for

any purpose, provided that the above copyright notice and the following

three paragraphs appear in all copies of this software.


IN NO EVENT SHALL AUTHORS BE LIABLE TO ANY PARTY FOR DIRECT,

INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES ARISING OUT OF THE 

USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF AUTHORS HAVE

BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.


AUTHORS SPECIFICALLY DISCLAIM ANY WARRANTIES INCLUDING, BUT NOT

LIMITED TO THE IMPLIED WARRANTIES OF MERCHANTABILITY, FITNESS FOR A

PARTICULAR PURPOSE, AND NON-INFRINGEMENT.


THE SOFTWARE IS PROVIDED ON AN ""AS-IS"" BASIS AND AUTHORS HAVE NO

OBLIGATION TO PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR

MODIFICATIONS.-->


<!DOCTYPE html>
<html>
<head/>
<body>
<?php
$handle = @fopen(""/tmp/tainted.txt"", ""r"");

if ($handle) {
  if(($tainted = fgets($handle, 4096)) == false) {
    $tainted = """";
  }
  fclose($handle);
} else {
  $tainted = """";
}

$tainted = http_build_query($tainted);


echo ""<"".  $tainted ."" href= \""/bob\"" />"" ;
?>
<h1>Hello World!</h1>
</body>
</html>","echo ""<"".  $tainted ."" href= \""/bob\"" />"" ;",True,True,"echo ""<"".  $tainted ."" href= \""/bob\"" />"" ;","```xml
<Issues>
  <Issue>
    <Type>Security</Type>
    <Weakness>CWE-79</Weakness>
    <Description>Improper Neutralization of Input During Web Page Generation ('Cross-site Scripting')</Description>
    <Severity>High</Severity>
    <File>File 1</File>
    <Code>echo ""&lt;"".  $tainted ."" href= \""/bob\"" /&gt;"" ;</Code>
    <Justification>The code uses external input $tainted to construct an HTML tag name without proper neutralization, leading to a cross-site scripting (XSS) vulnerability. Even though http_build_query is used, it's not sufficient to prevent XSS in this context because it's designed for URL encoding, not HTML sanitization.</Justification>
  </Issue>
  <Issue>
    <Type>Reliability</Type>
    <Weakness>CWE-252</Weakness>
    <Description>Unchecked Return Value</Description>
    <Severity>Low</Severity>
    <File>File 1</File>
    <Code>if(($tainted = fgets($handle, 4096)) == false) {
    $tainted = """";
  }</Code>
    <Justification>The code checks if fgets returns false, but it doesn't handle the case where fgets returns a string that's legitimately empty (""""). If fgets fails due to an error (and not EOF), the error could be missed. Although a default value for $tainted is set, more robust error handling could improve reliability.</Justification>
  </Issue>
  <Issue>
    <Type>Security</Type>
    <Weakness>CWE-477</Weakness>
    <Description>Use of Obsolete Function</Description>
    <Severity>Low</Severity>
    <File>File 1</File>
    <Code>$handle = @fopen(""/tmp/tainted.txt"", ""r"");</Code>
    <Justification>Using the error suppression operator ""@"" can hide potential issues and is considered bad practice. It prevents proper error handling and debugging, potentially masking security vulnerabilities or reliability issues.</Justification>
  </Issue>
</Issues>
```"
CWE-79,src/CWE_79__object-classicGet__func_FILTER-VALIDATION-email_filter__Use_untrusted_data_propertyValue_CSS-span_Style_Property_Value.php,"<!-- 
Unsafe sample
input : get the field userData from the variable $_GET via an object
Flushes content of $sanitized if the filter email_filter is not applied
File : unsafe, use of untrusted data in a property value in a span tag(CSS)
-->

<!--Copyright 2015 Bertrand STIVALET 

Permission is hereby granted, without written agreement or royalty fee, to

use, copy, modify, and distribute this software and its documentation for

any purpose, provided that the above copyright notice and the following

three paragraphs appear in all copies of this software.


IN NO EVENT SHALL AUTHORS BE LIABLE TO ANY PARTY FOR DIRECT,

INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES ARISING OUT OF THE 

USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF AUTHORS HAVE

BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.


AUTHORS SPECIFICALLY DISCLAIM ANY WARRANTIES INCLUDING, BUT NOT

LIMITED TO THE IMPLIED WARRANTIES OF MERCHANTABILITY, FITNESS FOR A

PARTICULAR PURPOSE, AND NON-INFRINGEMENT.


THE SOFTWARE IS PROVIDED ON AN ""AS-IS"" BASIS AND AUTHORS HAVE NO

OBLIGATION TO PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR

MODIFICATIONS.-->


<!DOCTYPE html>
<html>
<head/>
<body>
<?php
class Input{
  private $input;

  public function getInput(){
    return $this->input;
  }

  public  function __construct(){
   $this->input = $_GET['UserData'] ;
  }
}
$temp = new Input();
$tainted =  $temp->getInput();

if (filter_var($sanitized, FILTER_VALIDATE_EMAIL))
  $tainted = $sanitized ;
else
  $tainted = """" ;


echo ""<span style=\""color :"". checked_data .""\"">Hey</span>"" ;
?>
<h1>Hello World!</h1>
</body>
</html>","echo ""<span style=\""color :"". checked_data .""\"">Hey</span>"" ;",True,True,"if (filter_var($sanitized, FILTER_VALIDATE_EMAIL))
  $tainted = $sanitized ;
else
  $tainted = """" ;


echo ""<span style=\""color :"". checked_data .""\"">Hey</span>"" ;","```xml
<Issues>
  <Issue>
    <Type>Security</Type>
    <Weakness>CWE-79</Weakness>
    <Description>Improper Neutralization of Input During Web Page Generation ('Cross-site Scripting')</Description>
    <Severity>Medium</Severity>
    <File>File 1</File>
    <Code>if (filter_var($sanitized, FILTER_VALIDATE_EMAIL))
  $tainted = $sanitized ;
else
  $tainted = """" ;


echo ""&lt;span style=\""color :"". checked_data .""\""&gt;Hey&lt;/span&gt;"" ;</Code>
    <Justification>The code uses unfiltered data (checked_data) directly in the HTML output within a style attribute, which can lead to CSS injection and potentially XSS if an attacker can control the value of checked_data.</Justification>
  </Issue>
  <Issue>
    <Type>Security</Type>
    <Weakness>CWE-79</Weakness>
    <Description>Improper Neutralization of Input During Web Page Generation ('Cross-site Scripting')</Description>
    <Severity>High</Severity>
    <File>File 1</File>
    <Code> $this->input = $_GET['UserData'] ;
  }
}
$temp = new Input();
$tainted =  $temp->getInput();

if (filter_var($sanitized, FILTER_VALIDATE_EMAIL))
  $tainted = $sanitized ;
else
  $tainted = """" ;</Code>
    <Justification>The code retrieves user input from $_GET['UserData'] without proper sanitization and validation. Although there's an attempt to filter using filter_var with FILTER_VALIDATE_EMAIL, the variable $sanitized is used which is not initialized or related to $tainted. This makes the input vulnerable to XSS attacks if the user provides malicious data as UserData.</Justification>
  </Issue>
</Issues>
```"
CWE-91,src/CWE_91__popen__func_preg_match-no_filtering__username-sprintf_%s_simple_quote.php,"<?php







$handle = popen('/bin/cat /tmp/tainted.txt', 'r');
$tainted = fread($handle, 4096);
pclose($handle);

$re = ""/^.*$/"";
if(preg_match($re, $tainted) == 1){
  $tainted = $tainted;
}
else{
  $tainted = """";
}

$query = sprintf(""user[username='%s']"", $tainted);


$xml = simplexml_load_file(""users.xml"");
echo ""query : "". $query .""<br /><br />"" ;

$res=$xml->xpath($query);
print_r($res);
echo ""<br />"" ;

?>","$xml = simplexml_load_file(""users.xml"");",False,False,,"```xml
<Issues>
  <Issue>
    <Type>Security</Type>
    <Weakness>CWE-643</Weakness>
    <Description>Improper Neutralization of Data within XPath Expressions ('XPath Injection')</Description>
    <Severity>High</Severity>
    <File>File 1</File>
    <Code>$query = sprintf(""user[username='%s']"", $tainted);


$xml = simplexml_load_file(""users.xml"");
echo ""query : "". $query .""&lt;br /&gt;&lt;br /&gt;"" ;

$res=$xml->xpath($query);</Code>
    <Justification>The code uses tainted data from a file to construct an XPath query without proper sanitization. This can lead to XPath injection vulnerabilities if the file contains malicious characters that modify the query's meaning.</Justification>
  </Issue>
  <Issue>
    <Type>Reliability</Type>
    <Weakness>CWE-252</Weakness>
    <Description>Unchecked Return Value</Description>
    <Severity>Low</Severity>
    <File>File 1</File>
    <Code>$handle = popen('/bin/cat /tmp/tainted.txt', 'r');
$tainted = fread($handle, 4096);
pclose($handle);</Code>
    <Justification>The code does not check the return value of `popen`, `fread` and `pclose`. If any of these functions fail, the program might continue with uninitialized or incorrect data, leading to unexpected behavior.</Justification>
  </Issue>
  <Issue>
    <Type>Security</Type>
    <Weakness>CWE-424</Weakness>
    <Description>Improper Protection of Alternate Path</Description>
    <Severity>Medium</Severity>
    <File>File 1</File>
    <Code>$handle = popen('/bin/cat /tmp/tainted.txt', 'r');
$tainted = fread($handle, 4096);
pclose($handle);</Code>
    <Justification>The code reads from '/tmp/tainted.txt' without validating that the file exists and is accessible. An attacker could potentially create a file at this path with malicious content, leading to code execution via XPath injection.</Justification>
  </Issue>
</Issues>
```"
CWE-89,src/CWE_89__shell_exec__func_FILTER-CLEANING-email_filter__join-concatenation_simple_quote.php,"<?php







$tainted = shell_exec('cat /tmp/tainted.txt');

$sanitized = filter_var($tainted, FILTER_SANITIZE_EMAIL);
if (filter_var($sanitized, FILTER_VALIDATE_EMAIL))
  $tainted = $sanitized ;
else
  $tainted = """" ;

$query = ""SELECT lastname, firstname FROM drivers, vehicles WHERE drivers.id = vehicles.ownerid AND vehicles.tag='"". $tainted . ""'"";


$conn = mysql_connect('localhost', 'mysql_user', 'mysql_password'); 
mysql_select_db('dbname') ;
echo ""query : "". $query .""<br /><br />"" ;

$res = mysql_query($query); 

while($data =mysql_fetch_array($res)){
print_r($data) ;
echo ""<br />"" ;
} 
mysql_close($conn);

?>","$conn = mysql_connect('localhost', 'mysql_user', 'mysql_password'); ",True,False,"$query = ""SELECT lastname, firstname FROM drivers, vehicles WHERE drivers.id = vehicles.ownerid AND vehicles.tag='"". $tainted . ""'"";","```xml
<Issues>
  <Issue>
    <Type>Security</Type>
    <Weakness>CWE-78</Weakness>
    <Description>Improper Neutralization of Special Elements used in a Command ('Command Injection')</Description>
    <Severity>High</Severity>
    <File>File 1</File>
    <Code>$tainted = shell_exec('cat /tmp/tainted.txt');</Code>
    <Justification>The code uses shell_exec to execute a command with a hardcoded path. If an attacker can modify the contents of /tmp/tainted.txt, they can inject arbitrary commands.</Justification>
  </Issue>
  <Issue>
    <Type>Security</Type>
    <Weakness>CWE-89</Weakness>
    <Description>Improper Neutralization of Special Elements used in an SQL Command ('SQL Injection')</Description>
    <Severity>High</Severity>
    <File>File 1</File>
    <Code>$query = ""SELECT lastname, firstname FROM drivers, vehicles WHERE drivers.id = vehicles.ownerid AND vehicles.tag='"". $tainted . ""'"";</Code>
    <Justification>The code directly concatenates the `$tainted` variable into the SQL query without proper sanitization, leading to SQL injection vulnerability.</Justification>
  </Issue>
  <Issue>
    <Type>Security</Type>
    <Weakness>CWE-477</Weakness>
    <Description>Use of Obsolete Function</Description>
    <Severity>Low</Severity>
    <File>File 1</File>
    <Code>$conn = mysql_connect('localhost', 'mysql_user', 'mysql_password');</Code>
    <Justification>The code uses the `mysql_connect` function, which is deprecated and considered insecure. It should be replaced with `mysqli_connect` or PDO.</Justification>
  </Issue>
  <Issue>
    <Type>Security</Type>
    <Weakness>CWE-477</Weakness>
    <Description>Use of Obsolete Function</Description>
    <Severity>Low</Severity>
    <File>File 1</File>
    <Code>$res = mysql_query($query);</Code>
    <Justification>The code uses the `mysql_query` function, which is deprecated and considered insecure. It should be replaced with `mysqli_query` or PDO.</Justification>
  </Issue>
  <Issue>
    <Type>Security</Type>
    <Weakness>CWE-477</Weakness>
    <Description>Use of Obsolete Function</Description>
    <Severity>Low</Severity>
    <File>File 1</File>
    <Code>mysql_select_db('dbname') ;</Code>
    <Justification>The code uses the `mysql_select_db` function, which is deprecated and considered insecure. It should be replaced with `mysqli_select_db` or PDO.</Justification>
  </Issue>
  <Issue>
    <Type>Security</Type>
    <Weakness>CWE-477</Weakness>
    <Description>Use of Obsolete Function</Description>
    <Severity>Low</Severity>
    <File>File 1</File>
    <Code>while($data =mysql_fetch_array($res)){</Code>
    <Justification>The code uses the `mysql_fetch_array` function, which is deprecated and considered insecure. It should be replaced with `mysqli_fetch_array` or PDO.</Justification>
  </Issue>
  <Issue>
    <Type>Security</Type>
    <Weakness>CWE-477</Weakness>
    <Description>Use of Obsolete Function</Description>
    <Severity>Low</Severity>
    <File>File 1</File>
    <Code>mysql_close($conn);</Code>
    <Justification>The code uses the `mysql_close` function, which is deprecated and considered insecure. It should be replaced with `mysqli_close` or PDO.</Justification>
  </Issue>
  <Issue>
    <Type>Reliability</Type>
    <Weakness>CWE-252</Weakness>
    <Description>Unchecked Return Value</Description>
    <Severity>Medium</Severity>
    <File>File 1</File>
    <Code>$conn = mysql_connect('localhost', 'mysql_user', 'mysql_password');</Code>
    <Justification>The code does not check the return value of `mysql_connect`. If the connection fails, the script will continue to execute, potentially leading to errors.</Justification>
  </Issue>
  <Issue>
    <Type>Reliability</Type>
    <Weakness>CWE-252</Weakness>
    <Description>Unchecked Return Value</Description>
    <Severity>Medium</Severity>
    <File>File 1</File>
    <Code>$res = mysql_query($query);</Code>
    <Justification>The code does not check the return value of `mysql_query`. If the query fails, the script will continue to execute, potentially leading to errors.</Justification>
  </Issue>
  <Issue>
    <Type>Reliability</Type>
    <Weakness>CWE-252</Weakness>
    <Description>Unchecked Return Value</Description>
    <Severity>Low</Severity>
    <File>File 1</File>
    <Code>mysql_close($conn);</Code>
    <Justification>The code does not check the return value of `mysql_close`. While less critical, it's good practice to ensure the connection is properly closed.</Justification>
  </Issue>
  <Issue>
    <Type>Maintainability</Type>
    <Weakness>CWE-1051</Weakness>
    <Description>Initialization with Hard-Coded Network Resource Configuration Data</Description>
    <Severity>Low</Severity>
    <File>File 1</File>
    <Code>$conn = mysql_connect('localhost', 'mysql_user', 'mysql_password');</Code>
    <Justification>The code uses hard-coded credentials ('mysql_user', 'mysql_password') and the database host ('localhost'). This makes it difficult to change the database configuration without modifying the code.</Justification>
  </Issue>
</Issues>
```"
CWE-90,src/CWE_90__proc_open__func_FILTER-VALIDATION-email_filter__name-sprintf_%s_simple_quote.php,"<?php







$descriptorspec = array(
  0 => array(""pipe"", ""r""),
  1 => array(""pipe"", ""w""),
  2 => array(""file"", ""/tmp/error-output.txt"", ""a"")
  );
$cwd = '/tmp';
$process = proc_open('more /tmp/tainted.txt', $descriptorspec, $pipes, $cwd, NULL);
if (is_resource($process)) {
  fclose($pipes[0]);
  $tainted = stream_get_contents($pipes[1]);
  fclose($pipes[1]);
  $return_value = proc_close($process);
}

if (filter_var($sanitized, FILTER_VALIDATE_EMAIL))
  $tainted = $sanitized ;
else
  $tainted = """" ;

$query = sprintf(""name='%s'"", $tainted);


$ds=ldap_connect(""localhost""); 
$r=ldap_bind($ds);
$sr=ldap_search($ds,""o=My Company, c=US"", $query);  
ldap_close($ds);

?>","$ds=ldap_connect(""localhost"");",True,True,"$query = sprintf(""name='%s'"", $tainted);


$ds=ldap_connect(""localhost""); 
$r=ldap_bind($ds);
$sr=ldap_search($ds,""o=My Company, c=US"", $query);  
ldap_close($ds);","```xml
<Issues>
  <Issue>
    <Type>Security</Type>
    <Weakness>CWE-90</Weakness>
    <Description>Improper Neutralization of Special Elements used in an LDAP Query ('LDAP Injection')</Description>
    <Severity>High</Severity>
    <File>File 1</File>
    <Code>$query = sprintf(""name='%s'"", $tainted);


$ds=ldap_connect(""localhost""); 
$r=ldap_bind($ds);
$sr=ldap_search($ds,""o=My Company, c=US"", $query);  
ldap_close($ds);</Code>
    <Justification>The code constructs an LDAP query using sprintf with unsanitized input ($tainted). This allows an attacker to inject arbitrary LDAP code, potentially bypassing authentication or accessing sensitive information.</Justification>
  </Issue>
  <Issue>
    <Type>Reliability</Type>
    <Weakness>CWE-252</Weakness>
    <Description>Unchecked Return Value</Description>
    <Severity>Medium</Severity>
    <File>File 1</File>
    <Code>$ds=ldap_connect(""localhost""); 
$r=ldap_bind($ds);
$sr=ldap_search($ds,""o=My Company, c=US"", $query);  
ldap_close($ds);</Code>
    <Justification>The code does not check the return values of ldap_connect, ldap_bind, and ldap_search. If any of these functions fail, the subsequent code may operate on an invalid resource or produce incorrect results.</Justification>
  </Issue>
  <Issue>
    <Type>Security</Type>
    <Weakness>CWE-772</Weakness>
    <Description>Missing Release of Resource after Effective Lifetime</Description>
    <Severity>Low</Severity>
    <File>File 1</File>
    <Code>$ds=ldap_connect(""localhost""); 
$r=ldap_bind($ds);
$sr=ldap_search($ds,""o=My Company, c=US"", $query);  
ldap_close($ds);</Code>
    <Justification>Although the code calls ldap_close to release the LDAP resource, this is only done in the ""happy path"". If ldap_connect, ldap_bind or ldap_search fail, the resource will not be released, potentially leading to resource exhaustion.</Justification>
  </Issue>
  <Issue>
    <Type>Reliability</Type>
    <Weakness>CWE-772</Weakness>
    <Description>Missing Release of Resource after Effective Lifetime</Description>
    <Severity>Low</Severity>
    <File>File 1</File>
    <Code>$process = proc_open('more /tmp/tainted.txt', $descriptorspec, $pipes, $cwd, NULL);
if (is_resource($process)) {
  fclose($pipes[0]);
  $tainted = stream_get_contents($pipes[1]);
  fclose($pipes[1]);
  $return_value = proc_close($process);
}</Code>
    <Justification>The code attempts to release resources used by proc_open. However, in case of an exception, the resources may not be released.</Justification>
  </Issue>
</Issues>
```"
CWE-79,src/CWE_79__backticks__func_FILTER-VALIDATION-number_float_filter__Unsafe_use_untrusted_data-attribute_Name.php,"<!-- 
Unsafe sample
input : backticks interpretation, reading the file /tmp/tainted.txt
Flushes content of $sanitized if the filter number_float_filter is not applied
File : unsafe, use of untrusted data in an attribute name
-->

<!--Copyright 2015 Bertrand STIVALET 

Permission is hereby granted, without written agreement or royalty fee, to

use, copy, modify, and distribute this software and its documentation for

any purpose, provided that the above copyright notice and the following

three paragraphs appear in all copies of this software.


IN NO EVENT SHALL AUTHORS BE LIABLE TO ANY PARTY FOR DIRECT,

INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES ARISING OUT OF THE 

USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF AUTHORS HAVE

BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.


AUTHORS SPECIFICALLY DISCLAIM ANY WARRANTIES INCLUDING, BUT NOT

LIMITED TO THE IMPLIED WARRANTIES OF MERCHANTABILITY, FITNESS FOR A

PARTICULAR PURPOSE, AND NON-INFRINGEMENT.


THE SOFTWARE IS PROVIDED ON AN ""AS-IS"" BASIS AND AUTHORS HAVE NO

OBLIGATION TO PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR

MODIFICATIONS.-->


<!DOCTYPE html>
<html>
<body>
<?php
$tainted = `cat /tmp/tainted.txt`;

if (filter_var($sanitized, FILTER_VALIDATE_FLOAT))
  $tainted = $sanitized ;
else
  $tainted = """" ;


echo ""<div "". $tainted .""= bob />"" ;
?>
<h1>Hello World!</h1>
</div>
</body>
</html>","echo ""<div "". $tainted .""= bob />"" ;",True,True,"echo ""<div "". $tainted .""= bob />"" ;","```xml
<Issues>
  <Issue>
    <Type>Security</Type>
    <Weakness>CWE-77</Weakness>
    <Description>Improper Neutralization of Special Elements used in a Command ('Command Injection')</Description>
    <Severity>High</Severity>
    <File>File 1</File>
    <Code>$tainted = `cat /tmp/tainted.txt`;</Code>
    <Justification>The code uses backticks to execute a shell command (`cat /tmp/tainted.txt`) to read the contents of a file. This constitutes a command injection vulnerability because an attacker could potentially modify the command executed by manipulating the contents of the /tmp/tainted.txt file to inject arbitrary commands.</Justification>
  </Issue>
  <Issue>
    <Type>Security</Type>
    <Weakness>CWE-79</Weakness>
    <Description>Improper Neutralization of Input During Web Page Generation ('Cross-site Scripting')</Description>
    <Severity>Medium</Severity>
    <File>File 1</File>
    <Code>echo ""&lt;div "". $tainted .""= bob />"" ;</Code>
    <Justification>The code uses a variable `$tainted` to construct an HTML attribute name.  If the value of `$tainted` comes from an untrusted source (in this case, a file), it might contain malicious code (e.g., JavaScript).  This could lead to a Cross-Site Scripting (XSS) vulnerability. Even though a filter is used, if the filter is not applied or if the validation fails, the tainted data is directly used in the HTML output.</Justification>
  </Issue>
  <Issue>
    <Type>Reliability</Type>
    <Weakness>CWE-252</Weakness>
    <Description>Unchecked Return Value</Description>
    <Severity>Low</Severity>
    <File>File 1</File>
    <Code>$tainted = `cat /tmp/tainted.txt`;</Code>
    <Justification>The code executes a shell command using backticks, but does not check the return value or error status of the command. If the command fails (e.g., due to file not found or permission issues), the `$tainted` variable will contain an empty string or an error message, and the script will continue execution without handling the error.  This can lead to unexpected behavior or incorrect results.</Justification>
  </Issue>
  <Issue>
    <Type>Security</Type>
    <Weakness>CWE-424</Weakness>
    <Description>Improper Protection of Alternate Path</Description>
    <Severity>Medium</Severity>
    <File>File 1</File>
    <Code>if (filter_var($sanitized, FILTER_VALIDATE_FLOAT))
  $tainted = $sanitized ;
else
  $tainted = """" ;</Code>
    <Justification>The code attempts to sanitize the input using `filter_var` with `FILTER_VALIDATE_FLOAT`. However, if the validation fails (i.e., the input is not a valid float), the `$tainted` variable is set to an empty string.  This creates an alternate execution path where the `$tainted` variable might not contain the expected data, potentially leading to unexpected behavior or vulnerabilities if the rest of the code relies on `$tainted` always containing sanitized data, or not sanitizing the tainted input from the /tmp/tainted.txt file.</Justification>
  </Issue>
</Issues>
```"
CWE-79,src/CWE_79__object-classicGet__func_http_build_query__Use_untrusted_data_propertyValue_CSS-property_Value.php,"<!-- 
Unsafe sample
input : get the field userData from the variable $_GET via an object
SANITIZE : use of http_build_query
File : use of untrusted data in a property value (CSS)
-->

<!--Copyright 2015 Bertrand STIVALET 

Permission is hereby granted, without written agreement or royalty fee, to

use, copy, modify, and distribute this software and its documentation for

any purpose, provided that the above copyright notice and the following

three paragraphs appear in all copies of this software.


IN NO EVENT SHALL AUTHORS BE LIABLE TO ANY PARTY FOR DIRECT,

INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES ARISING OUT OF THE 

USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF AUTHORS HAVE

BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.


AUTHORS SPECIFICALLY DISCLAIM ANY WARRANTIES INCLUDING, BUT NOT

LIMITED TO THE IMPLIED WARRANTIES OF MERCHANTABILITY, FITNESS FOR A

PARTICULAR PURPOSE, AND NON-INFRINGEMENT.


THE SOFTWARE IS PROVIDED ON AN ""AS-IS"" BASIS AND AUTHORS HAVE NO

OBLIGATION TO PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR

MODIFICATIONS.-->


<!DOCTYPE html>
<html>
<head>
<style>
<?php
class Input{
  private $input;

  public function getInput(){
    return $this->input;
  }

  public  function __construct(){
   $this->input = $_GET['UserData'] ;
  }
}
$temp = new Input();
$tainted =  $temp->getInput();

$tainted = http_build_query($tainted);


echo ""body { color :"". $tainted ."" ; }"" ;
?>
 </style> 
 </script>
</head>
<body>
<h1>Hello World!</h1>
</body>
</html>","echo ""body { color :"". $tainted ."" ; }"" ;",True,True,"echo ""body { color :"". $tainted ."" ; }"" ;","```xml
<Issues>
  <Issue>
    <Type>Security</Type>
    <Weakness>CWE-79</Weakness>
    <Description>Improper Neutralization of Input During Web Page Generation ('Cross-site Scripting')</Description>
    <Severity>Medium</Severity>
    <File>File 1</File>
    <Code>echo ""body { color :"". $tainted ."" ; }"" ;</Code>
    <Justification>The code uses external input $tainted in CSS property without proper neutralization, leading to potential XSS vulnerabilities.</Justification>
  </Issue>
</Issues>
```"
CWE-91,src/CWE_91__POST__func_FILTER-CLEANING-email_filter__username_at-interpretation_simple_quote.php,"<?php







$tainted = $_POST['UserData'];

$sanitized = filter_var($tainted, FILTER_SANITIZE_EMAIL);
if (filter_var($sanitized, FILTER_VALIDATE_EMAIL))
  $tainted = $sanitized ;
else
  $tainted = """" ;

$query = ""


$xml = simplexml_load_file(""users.xml"");
echo ""query : "". $query .""<br /><br />"" ;

$res=$xml->xpath($query);
print_r($res);
echo ""<br />"" ;

?>","$xml = simplexml_load_file(""users.xml"");",True,True,"$tainted = $_POST['UserData'];

$sanitized = filter_var($tainted, FILTER_SANITIZE_EMAIL);
if (filter_var($sanitized, FILTER_VALIDATE_EMAIL))
  $tainted = $sanitized ;
else
  $tainted = """" ;

$query = ""","```xml
<Issues>
  <Issue>
    <Type>Security</Type>
    <Weakness>CWE-91</Weakness>
    <Description>XML Injection (aka Blind XPath Injection)</Description>
    <Severity>High</Severity>
    <File>File 1</File>
    <Code>$tainted = $_POST['UserData'];

$sanitized = filter_var($tainted, FILTER_SANITIZE_EMAIL);
if (filter_var($sanitized, FILTER_VALIDATE_EMAIL))
  $tainted = $sanitized ;
else
  $tainted = """" ;

$query = ""</Code>
    <Justification>The code takes user-controlled data from $_POST['UserData'] and, after attempting to sanitize it as an email address, uses it in an XPath query without proper neutralization of special elements.  Even after sanitization, the resulting string is directly embedded in the XPath query. Although FILTER_SANITIZE_EMAIL removes potentially harmful characters from an email address, it does not prevent injection of XPath syntax, which can lead to XPath injection vulnerabilities. An attacker can manipulate the XPath query to extract sensitive information or perform other malicious actions on the XML data.</Justification>
  </Issue>
</Issues>
```"
CWE-79,src/CWE_79__object-classicGet__no_sanitizing__Use_untrusted_data-body.php,"<!-- 
Unsafe sample
input : get the field userData from the variable $_GET via an object
sanitize : none
File : use of untrusted data in the body
-->

<!--Copyright 2015 Bertrand STIVALET 

Permission is hereby granted, without written agreement or royalty fee, to

use, copy, modify, and distribute this software and its documentation for

any purpose, provided that the above copyright notice and the following

three paragraphs appear in all copies of this software.


IN NO EVENT SHALL AUTHORS BE LIABLE TO ANY PARTY FOR DIRECT,

INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES ARISING OUT OF THE 

USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF AUTHORS HAVE

BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.


AUTHORS SPECIFICALLY DISCLAIM ANY WARRANTIES INCLUDING, BUT NOT

LIMITED TO THE IMPLIED WARRANTIES OF MERCHANTABILITY, FITNESS FOR A

PARTICULAR PURPOSE, AND NON-INFRINGEMENT.


THE SOFTWARE IS PROVIDED ON AN ""AS-IS"" BASIS AND AUTHORS HAVE NO

OBLIGATION TO PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR

MODIFICATIONS.-->


<!DOCTYPE html>
<html>
<head/>
<body>
<?php
class Input{
  private $input;

  public function getInput(){
    return $this->input;
  }

  public  function __construct(){
   $this->input = $_GET['UserData'] ;
  }
}
$temp = new Input();
$tainted =  $temp->getInput();




echo $tainted ;
?>
<h1>Hello World!</h1>
</body>
</html>
",echo $tainted ;,True,True,echo $tainted ;,"```xml
<Issues>
  <Issue>
    <Type>Security</Type>
    <Weakness>CWE-79</Weakness>
    <Description>Improper Neutralization of Input During Web Page Generation ('Cross-site Scripting')</Description>
    <Severity>Medium</Severity>
    <File>File 1</File>
    <Code>echo $tainted ;</Code>
    <Justification>The code directly echoes user input ($tainted) to the web page without any sanitization or encoding. This allows an attacker to inject malicious scripts into the page, leading to Cross-Site Scripting (XSS).</Justification>
  </Issue>
</Issues>
```"
CWE-89,src/CWE_89__backticks__no_sanitizing__multiple_select-concatenation.php,"<?php







$tainted = `cat /tmp/tainted.txt`;



$query = ""SELECT * FROM COURSE c WHERE c.id IN (SELECT idcourse FROM REGISTRATION WHERE idstudent="". $tainted . "")"";


$conn = mysql_connect('localhost', 'mysql_user', 'mysql_password'); 
mysql_select_db('dbname') ;
echo ""query : "". $query .""<br /><br />"" ;

$res = mysql_query($query); 

while($data =mysql_fetch_array($res)){
print_r($data) ;
echo ""<br />"" ;
} 
mysql_close($conn);

?>","$conn = mysql_connect('localhost', 'mysql_user', 'mysql_password'); ",True,False,"$query = ""SELECT * FROM COURSE c WHERE c.id IN (SELECT idcourse FROM REGISTRATION WHERE idstudent="". $tainted . "")"";","```xml
<Issues>
  <Issue>
    <Type>Security</Type>
    <Weakness>CWE-78</Weakness>
    <Description>Improper Neutralization of Special Elements used in a Command ('Command Injection')</Description>
    <Severity>High</Severity>
    <File>File 1</File>
    <Code>$tainted = `cat /tmp/tainted.txt`;</Code>
    <Justification>The code uses backticks to execute a shell command (`cat /tmp/tainted.txt`) and assigns the output to the `$tainted` variable. This is vulnerable to command injection if the contents of `/tmp/tainted.txt` are attacker-controlled.</Justification>
  </Issue>
  <Issue>
    <Type>Security</Type>
    <Weakness>CWE-89</Weakness>
    <Description>Improper Neutralization of Special Elements used in an SQL Command ('SQL Injection')</Description>
    <Severity>High</Severity>
    <File>File 1</File>
    <Code>$query = ""SELECT * FROM COURSE c WHERE c.id IN (SELECT idcourse FROM REGISTRATION WHERE idstudent="". $tainted . "")"";</Code>
    <Justification>The code directly incorporates the `$tainted` variable into an SQL query without proper sanitization or escaping. This creates a SQL injection vulnerability, allowing an attacker to manipulate the query and potentially gain unauthorized access to the database.</Justification>
  </Issue>
  <Issue>
    <Type>Reliability</Type>
    <Weakness>CWE-252</Weakness>
    <Description>Unchecked Return Value</Description>
    <Severity>Medium</Severity>
    <File>File 1</File>
    <Code>$conn = mysql_connect('localhost', 'mysql_user', 'mysql_password');</Code>
    <Justification>The code does not check the return value of `mysql_connect`. If the connection fails, `$conn` will be false, and subsequent operations will likely cause errors.</Justification>
  </Issue>
  <Issue>
    <Type>Reliability</Type>
    <Weakness>CWE-252</Weakness>
    <Description>Unchecked Return Value</Description>
    <Severity>Medium</Severity>
    <File>File 1</File>
    <Code>$res = mysql_query($query);</Code>
    <Justification>The code does not check the return value of `mysql_query`. If the query fails, `$res` will be false, and the subsequent `mysql_fetch_array` call will cause an error.</Justification>
  </Issue>
  <Issue>
    <Type>Maintainability</Type>
    <Weakness>CWE-477</Weakness>
    <Description>Use of Obsolete Function</Description>
    <Severity>Low</Severity>
    <File>File 1</File>
    <Code>$conn = mysql_connect('localhost', 'mysql_user', 'mysql_password');</Code>
    <Justification>The code uses the `mysql_connect` function, which is deprecated. Using deprecated functions makes the code harder to maintain and potentially insecure.</Justification>
  </Issue>
  <Issue>
    <Type>Maintainability</Type>
    <Weakness>CWE-477</Weakness>
    <Description>Use of Obsolete Function</Description>
    <Severity>Low</Severity>
    <File>File 1</File>
    <Code>mysql_select_db('dbname') ;</Code>
    <Justification>The code uses the `mysql_select_db` function, which is deprecated. Using deprecated functions makes the code harder to maintain and potentially insecure.</Justification>
  </Issue>
  <Issue>
    <Type>Maintainability</Type>
    <Weakness>CWE-477</Weakness>
    <Description>Use of Obsolete Function</Description>
    <Severity>Low</Severity>
    <File>File 1</File>
    <Code>$res = mysql_query($query);</Code>
    <Justification>The code uses the `mysql_query` function, which is deprecated. Using deprecated functions makes the code harder to maintain and potentially insecure.</Justification>
  </Issue>
  <Issue>
    <Type>Maintainability</Type>
    <Weakness>CWE-477</Weakness>
    <Description>Use of Obsolete Function</Description>
    <Severity>Low</Severity>
    <File>File 1</File>
    <Code>while($data =mysql_fetch_array($res)){</Code>
    <Justification>The code uses the `mysql_fetch_array` function, which is deprecated. Using deprecated functions makes the code harder to maintain and potentially insecure.</Justification>
  </Issue>
  <Issue>
    <Type>Maintainability</Type>
    <Weakness>CWE-477</Weakness>
    <Description>Use of Obsolete Function</Description>
    <Severity>Low</Severity>
    <File>File 1</File>
    <Code>mysql_close($conn);</Code>
    <Justification>The code uses the `mysql_close` function, which is deprecated. Using deprecated functions makes the code harder to maintain and potentially insecure.</Justification>
  </Issue>
</Issues>
```"
CWE-90,src/CWE_90__shell_exec__func_htmlentities__name-sprintf_%s_simple_quote.php,"<?php







$tainted = shell_exec('cat /tmp/tainted.txt');

$tainted = htmlentities($tainted, ENT_QUOTES);

$query = sprintf(""name='%s'"", $tainted);


$ds=ldap_connect(""localhost""); 
$r=ldap_bind($ds);
$sr=ldap_search($ds,""o=My Company, c=US"", $query);  
ldap_close($ds);

?>","$ds=ldap_connect(""localhost"");",True,True,"$tainted = shell_exec('cat /tmp/tainted.txt');

$tainted = htmlentities($tainted, ENT_QUOTES);

$query = sprintf(""name='%s'"", $tainted);


$ds=ldap_connect(""localhost""); 
$r=ldap_bind($ds);
$sr=ldap_search($ds,""o=My Company, c=US"", $query);  
ldap_close($ds);","```xml
<Issues>
  <Issue>
    <Type>Security</Type>
    <Weakness>CWE-90</Weakness>
    <Description>Improper Neutralization of Special Elements used in an LDAP Query ('LDAP Injection')</Description>
    <Severity>High</Severity>
    <File>File 1</File>
    <Code>$tainted = shell_exec('cat /tmp/tainted.txt');

$tainted = htmlentities($tainted, ENT_QUOTES);

$query = sprintf(""name='%s'"", $tainted);


$ds=ldap_connect(""localhost""); 
$r=ldap_bind($ds);
$sr=ldap_search($ds,""o=My Company, c=US"", $query);  
ldap_close($ds);</Code>
    <Justification>The code constructs an LDAP query using unsanitized input from the $tainted variable. Although htmlentities is used, it might not be sufficient to prevent LDAP injection attacks, as specific LDAP control characters might not be properly neutralized.  The sprintf function is then used to directly insert this potentially malicious input into the query string. This can allow an attacker to inject arbitrary LDAP commands, potentially leading to unauthorized access or modification of data within the LDAP directory.</Justification>
  </Issue>
  <Issue>
    <Type>Security</Type>
    <Weakness>CWE-77</Weakness>
    <Description>Improper Neutralization of Special Elements used in a Command ('Command Injection')</Description>
    <Severity>High</Severity>
    <File>File 1</File>
    <Code>$tainted = shell_exec('cat /tmp/tainted.txt');</Code>
    <Justification>The code uses shell_exec to read a file. If the filename `/tmp/tainted.txt` is controllable by an attacker (e.g. via a symlink), they could read arbitrary files on the system. Additionally, the contents of the file are treated as trusted data, but this is not guaranteed, potentially leading to command injection if the file contains malicious commands.</Justification>
  </Issue>
</Issues>
```"
CWE-90,src/CWE_90__fopen__func_preg_replace__not_name-concatenation_simple_quote.php,"<?php







$handle = @fopen(""/tmp/tainted.txt"", ""r"");

if ($handle) {
  if(($tainted = fgets($handle, 4096)) == false) {
    $tainted = """";
  }
  fclose($handle);
} else {
  $tainted = """";
}

$tainted = preg_replace('/\'/', '', $tainted);

$query = ""!name='"". $tainted . ""'"";


$ds=ldap_connect(""localhost""); 
$r=ldap_bind($ds);
$sr=ldap_search($ds,""o=My Company, c=US"", $query);  
ldap_close($ds);

?>","$ds=ldap_connect(""localhost"");",True,True,"$query = ""!name='"". $tainted . ""'"";


$ds=ldap_connect(""localhost""); 
$r=ldap_bind($ds);
$sr=ldap_search($ds,""o=My Company, c=US"", $query);  
ldap_close($ds);","```xml
<Issues>
  <Issue>
    <Type>Security</Type>
    <Weakness>CWE-90</Weakness>
    <Description>Improper Neutralization of Special Elements used in an LDAP Query ('LDAP Injection')</Description>
    <Severity>High</Severity>
    <File>File 1</File>
    <Code>$query = ""!name='"". $tainted . ""'"";


$ds=ldap_connect(""localhost""); 
$r=ldap_bind($ds);
$sr=ldap_search($ds,""o=My Company, c=US"", $query);  
ldap_close($ds);</Code>
    <Justification>The code constructs an LDAP query by concatenating a string with the `$tainted` variable, which is derived from a file and has only had single quotes removed. This allows an attacker to inject arbitrary LDAP code by crafting the content of `/tmp/tainted.txt`, potentially bypassing authentication or accessing sensitive information.</Justification>
  </Issue>
  <Issue>
    <Type>Reliability</Type>
    <Weakness>CWE-252</Weakness>
    <Description>Unchecked Return Value</Description>
    <Severity>Medium</Severity>
    <File>File 1</File>
    <Code>$handle = @fopen(""/tmp/tainted.txt"", ""r"");

if ($handle) {
  if(($tainted = fgets($handle, 4096)) == false) {
    $tainted = """";
  }
  fclose($handle);
} else {
  $tainted = """";
}</Code>
    <Justification>The code uses @fopen to suppress errors, but it doesn't explicitly check if fopen actually succeeds by verifying that $handle is not false before proceeding. If fopen fails (e.g., due to permission issues or the file not existing), $handle will be false, and the subsequent code will attempt to use a boolean value as a file handle, leading to a potential error and program disruption.</Justification>
  </Issue>
  <Issue>
    <Type>Reliability</Type>
    <Weakness>CWE-252</Weakness>
    <Description>Unchecked Return Value</Description>
    <Severity>Medium</Severity>
    <File>File 1</File>
    <Code>$r=ldap_bind($ds);
$sr=ldap_search($ds,""o=My Company, c=US"", $query);  
ldap_close($ds);</Code>
    <Justification>The code does not check the return values of `ldap_bind` and `ldap_search`. If these functions fail, the script will continue to execute, potentially leading to unexpected behavior or security vulnerabilities. For instance, if `ldap_bind` fails, the subsequent `ldap_search` might operate on an unauthenticated connection, yielding incorrect or unauthorized results.</Justification>
  </Issue>
</Issues>
```"
CWE-79,src/CWE_79__proc_open__func_htmlspecialchars__Unsafe_use_untrusted_data-attribute_Name.php,"<!-- 
Unsafe sample
input : use proc_open to read /tmp/tainted.txt
sanitize : use of the function htmlspecialchars. Sanitizes the query but has a high chance to produce unexpected results
File : unsafe, use of untrusted data in an attribute name
-->

<!--Copyright 2015 Bertrand STIVALET 

Permission is hereby granted, without written agreement or royalty fee, to

use, copy, modify, and distribute this software and its documentation for

any purpose, provided that the above copyright notice and the following

three paragraphs appear in all copies of this software.


IN NO EVENT SHALL AUTHORS BE LIABLE TO ANY PARTY FOR DIRECT,

INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES ARISING OUT OF THE 

USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF AUTHORS HAVE

BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.


AUTHORS SPECIFICALLY DISCLAIM ANY WARRANTIES INCLUDING, BUT NOT

LIMITED TO THE IMPLIED WARRANTIES OF MERCHANTABILITY, FITNESS FOR A

PARTICULAR PURPOSE, AND NON-INFRINGEMENT.


THE SOFTWARE IS PROVIDED ON AN ""AS-IS"" BASIS AND AUTHORS HAVE NO

OBLIGATION TO PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR

MODIFICATIONS.-->


<!DOCTYPE html>
<html>
<body>
<?php
$descriptorspec = array(
  0 => array(""pipe"", ""r""),
  1 => array(""pipe"", ""w""),
  2 => array(""file"", ""/tmp/error-output.txt"", ""a"")
  );
$cwd = '/tmp';
$process = proc_open('more /tmp/tainted.txt', $descriptorspec, $pipes, $cwd, NULL);
if (is_resource($process)) {
  fclose($pipes[0]);
  $tainted = stream_get_contents($pipes[1]);
  fclose($pipes[1]);
  $return_value = proc_close($process);
}

$tainted = htmlspecialchars($tainted, ENT_QUOTES);


echo ""<div "". $tainted .""= bob />"" ;
?>
<h1>Hello World!</h1>
</div>
</body>
</html>","echo ""<div "". $tainted .""= bob />"" ;",True,True,"$tainted = htmlspecialchars($tainted, ENT_QUOTES);


echo ""<div "". $tainted .""= bob />"" ;","```xml
<Issues>
  <Issue>
    <Type>Security</Type>
    <Weakness>CWE-79</Weakness>
    <Description>Improper Neutralization of Input During Web Page Generation ('Cross-site Scripting')</Description>
    <Severity>High</Severity>
    <File>File 1</File>
    <Code>
$tainted = htmlspecialchars($tainted, ENT_QUOTES);


echo ""&lt;div "". $tainted .""= bob />"" ;</Code>
    <Justification>The code sanitizes the input using htmlspecialchars, but it's used in an attribute name. This can lead to XSS because attribute names can still execute javascript in some contexts (e.g., event handlers like onload, onerror).  Sanitizing for attribute *values* is different than sanitizing attribute names.</Justification>
  </Issue>
  <Issue>
    <Type>Security</Type>
    <Weakness>CWE-22</Weakness>
    <Description>Improper Limitation of a Pathname to a Restricted Directory ('Path Traversal')</Description>
    <Severity>Medium</Severity>
    <File>File 1</File>
    <Code>
$process = proc_open('more /tmp/tainted.txt', $descriptorspec, $pipes, $cwd, NULL);
if (is_resource($process)) {
  fclose($pipes[0]);
  $tainted = stream_get_contents($pipes[1]);
  fclose($pipes[1]);
  $return_value = proc_close($process);
}</Code>
    <Justification>The code reads the file `/tmp/tainted.txt` without validating if this file is safe. An attacker could potentially modify or replace this file with malicious content that will be included in the HTML output.</Justification>
  </Issue>
  <Issue>
    <Type>Reliability</Type>
    <Weakness>CWE-252</Weakness>
    <Description>Unchecked Return Value</Description>
    <Severity>Low</Severity>
    <File>File 1</File>
    <Code>
  $tainted = stream_get_contents($pipes[1]);
  fclose($pipes[1]);
  $return_value = proc_close($process);
}</Code>
    <Justification>The return value of `proc_close` is not checked. If `proc_close` fails, the script continues without knowing, potentially leading to issues if subsequent operations depend on the process being properly closed.</Justification>
  </Issue>
  <Issue>
    <Type>Reliability</Type>
    <Weakness>CWE-252</Weakness>
    <Description>Unchecked Return Value</Description>
    <Severity>Low</Severity>
    <File>File 1</File>
    <Code>
  $tainted = stream_get_contents($pipes[1]);
  fclose($pipes[1]);
  $return_value = proc_close($process);
}</Code>
    <Justification>The return value of `fclose($pipes[1])` is not checked. If `fclose` fails, the script continues without knowing, potentially leading to issues if subsequent operations depend on the file being properly closed.</Justification>
  </Issue>
</Issues>
```"
CWE-89,src/CWE_89__object-indexArray__func_preg_match-no_filtering__select_from-sprintf_%s_simple_quote.php,"<?php







class Input{
  private $input;

  public function getInput(){
    return $this->input['realOne'];
  }

  public  function __construct(){
    $this->input = array();
    $this->input['test']= 'safe' ;
    $this->input['realOne']= $_GET['UserData'] ;
    $this->input['trap']= 'safe' ;
  }
}
$temp = new Input();
$tainted =  $temp->getInput();

$re = ""/^.*$/"";
if(preg_match($re, $tainted) == 1){
  $tainted = $tainted;
}
else{
  $tainted = """";
}

$query = sprintf(""SELECT * FROM '%s'"", $tainted);


$conn = mysql_connect('localhost', 'mysql_user', 'mysql_password'); 
mysql_select_db('dbname') ;
echo ""query : "". $query .""<br /><br />"" ;

$res = mysql_query($query); 

while($data =mysql_fetch_array($res)){
print_r($data) ;
echo ""<br />"" ;
} 
mysql_close($conn);

?>","$conn = mysql_connect('localhost', 'mysql_user', 'mysql_password'); ",True,False,"$query = sprintf(""SELECT * FROM '%s'"", $tainted);","```xml
<Issues>
  <Issue>
    <Type>Security</Type>
    <Weakness>CWE-89</Weakness>
    <Description>Improper Neutralization of Special Elements used in an SQL Command ('SQL Injection')</Description>
    <Severity>High</Severity>
    <File>File 1</File>
    <Code>$query = sprintf(""SELECT * FROM '%s'"", $tainted);</Code>
    <Justification>The code uses sprintf to construct a SQL query with user-controlled input ($tainted). This allows an attacker to inject arbitrary SQL code, potentially leading to data breaches or unauthorized access.</Justification>
  </Issue>
  <Issue>
    <Type>Security</Type>
    <Weakness>CWE-477</Weakness>
    <Description>Use of Obsolete Function</Description>
    <Severity>Medium</Severity>
    <File>File 1</File>
    <Code>$conn = mysql_connect('localhost', 'mysql_user', 'mysql_password'); 
mysql_select_db('dbname') ;
echo ""query : "". $query .""&lt;br /&gt;&lt;br /&gt;"" ;

$res = mysql_query($query); </Code>
    <Justification>The code uses the `mysql_connect` and `mysql_query` functions, which are deprecated. These functions are known to have security vulnerabilities and should be replaced with `mysqli` or `PDO`.</Justification>
  </Issue>
</Issues>
```"
CWE-79,src/CWE_79__object-classicGet__func_FILTER-CLEANING-special_chars_filter__Use_untrusted_data_script-window_SetInterval.php,"<!-- 
Unsafe sample
input : get the field userData from the variable $_GET via an object
Uses a special_chars_filter via filter_var function
File : unsafe, use of untrusted data in the function setInterval
-->

<!--Copyright 2015 Bertrand STIVALET 

Permission is hereby granted, without written agreement or royalty fee, to

use, copy, modify, and distribute this software and its documentation for

any purpose, provided that the above copyright notice and the following

three paragraphs appear in all copies of this software.


IN NO EVENT SHALL AUTHORS BE LIABLE TO ANY PARTY FOR DIRECT,

INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES ARISING OUT OF THE 

USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF AUTHORS HAVE

BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.


AUTHORS SPECIFICALLY DISCLAIM ANY WARRANTIES INCLUDING, BUT NOT

LIMITED TO THE IMPLIED WARRANTIES OF MERCHANTABILITY, FITNESS FOR A

PARTICULAR PURPOSE, AND NON-INFRINGEMENT.


THE SOFTWARE IS PROVIDED ON AN ""AS-IS"" BASIS AND AUTHORS HAVE NO

OBLIGATION TO PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR

MODIFICATIONS.-->


<!DOCTYPE html>
<html>
<head>
<script>
<?php
class Input{
  private $input;

  public function getInput(){
    return $this->input;
  }

  public  function __construct(){
   $this->input = $_GET['UserData'] ;
  }
}
$temp = new Input();
$tainted =  $temp->getInput();

$sanitized = filter_var($tainted, FILTER_SANITIZE_SPECIAL_CHARS);
  $tainted = $sanitized ;
      


echo ""window.setInterval('"". $tainted .""');"" ;
?>
 </script>
</head>
<body>
<h1>Hello World!</h1>
</body>
</html>","echo ""window.setInterval('"". $tainted .""');"" ;",True,True,"echo ""window.setInterval('"". $tainted .""');""","```xml
<Issues>
  <Issue>
    <Type>Security</Type>
    <Weakness>CWE-79</Weakness>
    <Description>Improper Neutralization of Input During Web Page Generation ('Cross-site Scripting')</Description>
    <Severity>High</Severity>
    <File>File 1</File>
    <Code>echo ""window.setInterval('"". $tainted .""');""</Code>
    <Justification>The code takes user-controlled input from $_GET['UserData'], sanitizes it using FILTER_SANITIZE_SPECIAL_CHARS, and then directly embeds it into a JavaScript setInterval function. While the sanitization attempts to prevent HTML injection, it does not prevent JavaScript injection. An attacker could still craft input that, after sanitization, results in malicious JavaScript code being executed within the setInterval, leading to XSS.</Justification>
  </Issue>
</Issues>
```"
CWE-79,src/CWE_79__object-directGet__func_FILTER-VALIDATION-email_filter__Use_untrusted_data_propertyValue_CSS-property_Value.php,"<!-- 
Unsafe sample
input : get the field userData from the variable $_GET via an object
Flushes content of $sanitized if the filter email_filter is not applied
File : use of untrusted data in a property value (CSS)
-->

<!--Copyright 2015 Bertrand STIVALET 

Permission is hereby granted, without written agreement or royalty fee, to

use, copy, modify, and distribute this software and its documentation for

any purpose, provided that the above copyright notice and the following

three paragraphs appear in all copies of this software.


IN NO EVENT SHALL AUTHORS BE LIABLE TO ANY PARTY FOR DIRECT,

INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES ARISING OUT OF THE 

USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF AUTHORS HAVE

BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.


AUTHORS SPECIFICALLY DISCLAIM ANY WARRANTIES INCLUDING, BUT NOT

LIMITED TO THE IMPLIED WARRANTIES OF MERCHANTABILITY, FITNESS FOR A

PARTICULAR PURPOSE, AND NON-INFRINGEMENT.


THE SOFTWARE IS PROVIDED ON AN ""AS-IS"" BASIS AND AUTHORS HAVE NO

OBLIGATION TO PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR

MODIFICATIONS.-->


<!DOCTYPE html>
<html>
<head>
<style>
<?php
class Input{
  public function getInput(){
    return $_GET['UserData'] ;
  }
}

$temp = new Input();
$tainted =  $temp->getInput();

if (filter_var($sanitized, FILTER_VALIDATE_EMAIL))
  $tainted = $sanitized ;
else
  $tainted = """" ;


echo ""body { color :"". $tainted ."" ; }"" ;
?>
 </style> 
 </script>
</head>
<body>
<h1>Hello World!</h1>
</body>
</html>","echo ""body { color :"". $tainted ."" ; }"" ;",True,True,"echo ""body { color :"". $tainted ."" ; }"" ;","```xml
<Issues>
  <Issue>
    <Type>Security</Type>
    <Weakness>CWE-79</Weakness>
    <Description>Improper Neutralization of Input During Web Page Generation ('Cross-site Scripting')</Description>
    <Severity>Medium</Severity>
    <File>File 1</File>
    <Code>echo ""body { color :"". $tainted ."" ; }"" ;</Code>
    <Justification>The code directly outputs user-controlled data ($tainted) into a CSS style attribute without proper sanitization. This can lead to CSS injection or XSS if the user input contains malicious CSS or JavaScript code. While the code attempts to filter for emails, if that fails, it assigns an empty string, however, it does not prevent CSS injection.</Justification>
  </Issue>
  <Issue>
    <Type>Maintainability</Type>
    <Weakness>CWE-480</Weakness>
    <Description>Use of Incorrect Operator</Description>
    <Severity>Low</Severity>
    <File>File 1</File>
    <Code>if (filter_var($sanitized, FILTER_VALIDATE_EMAIL))
  $tainted = $sanitized ;
else
  $tainted = """" ;</Code>
    <Justification>The variable `$sanitized` is used in `filter_var` but it is never initialized. The intended behavior is unclear and may introduce unexpected results. This can make the code harder to understand and maintain.</Justification>
  </Issue>
</Issues>
```"
CWE-90,src/CWE_90__proc_open__no_sanitizing__userByMail-concatenation_simple_quote.php,"<?php







$descriptorspec = array(
  0 => array(""pipe"", ""r""),
  1 => array(""pipe"", ""w""),
  2 => array(""file"", ""/tmp/error-output.txt"", ""a"")
  );
$cwd = '/tmp';
$process = proc_open('more /tmp/tainted.txt', $descriptorspec, $pipes, $cwd, NULL);
if (is_resource($process)) {
  fclose($pipes[0]);
  $tainted = stream_get_contents($pipes[1]);
  fclose($pipes[1]);
  $return_value = proc_close($process);
}



$query = ""(&(objectCategory=person)(objectClass=user)(mail='"". $tainted . ""'))"";


$ds=ldap_connect(""localhost""); 
$r=ldap_bind($ds);
$sr=ldap_search($ds,""o=My Company, c=US"", $query);  
ldap_close($ds);

?>","$ds=ldap_connect(""localhost"");",True,True,"$query = ""(&(objectCategory=person)(objectClass=user)(mail='"". $tainted . ""'))"";


$ds=ldap_connect(""localhost""); 
$r=ldap_bind($ds);
$sr=ldap_search($ds,""o=My Company, c=US"", $query);  
ldap_close($ds);","```xml
<Issues>
  <Issue>
    <Type>Security</Type>
    <Weakness>CWE-90</Weakness>
    <Description>Improper Neutralization of Special Elements used in an LDAP Query ('LDAP Injection')</Description>
    <Severity>High</Severity>
    <File>File 1</File>
    <Code>$query = ""(&(objectCategory=person)(objectClass=user)(mail='"". $tainted . ""'))"";


$ds=ldap_connect(""localhost""); 
$r=ldap_bind($ds);
$sr=ldap_search($ds,""o=My Company, c=US"", $query);  
ldap_close($ds);</Code>
    <Justification>The code constructs an LDAP query by directly embedding the `$tainted` variable, which is derived from a file, without proper sanitization. This allows an attacker to inject arbitrary LDAP code, potentially bypassing authentication or accessing sensitive information.  The lack of input validation and sanitization on the `$tainted` variable makes the application vulnerable to LDAP injection attacks.</Justification>
  </Issue>
  <Issue>
    <Type>Reliability</Type>
    <Weakness>CWE-252</Weakness>
    <Description>Unchecked Return Value</Description>
    <Severity>Medium</Severity>
    <File>File 1</File>
    <Code>$ds=ldap_connect(""localhost""); 
$r=ldap_bind($ds);
$sr=ldap_search($ds,""o=My Company, c=US"", $query);  
ldap_close($ds);</Code>
    <Justification>The code does not check the return values of `ldap_connect`, `ldap_bind`, and `ldap_search`. If any of these functions fail, they will return FALSE, and the script will continue to execute, potentially leading to unexpected behavior or security vulnerabilities. For example, if `ldap_connect` fails, `$ds` will be FALSE, and subsequent calls to `ldap_bind` and `ldap_search` will result in errors.</Justification>
  </Issue>
  <Issue>
    <Type>Security</Type>
    <Weakness>CWE-424</Weakness>
    <Description>Improper Protection of Alternate Path</Description>
    <Severity>Medium</Severity>
    <File>File 1</File>
    <Code>$process = proc_open('more /tmp/tainted.txt', $descriptorspec, $pipes, $cwd, NULL);
if (is_resource($process)) {
  fclose($pipes[0]);
  $tainted = stream_get_contents($pipes[1]);
  fclose($pipes[1]);
  $return_value = proc_close($process);
}

$query = ""(&(objectCategory=person)(objectClass=user)(mail='"". $tainted . ""'))"";</Code>
    <Justification>The code reads data from `/tmp/tainted.txt`. If an attacker can control the contents of this file, they can influence the value of the `$tainted` variable and potentially inject malicious data into the LDAP query or other parts of the application. The application does not sufficiently protect the path used to access the file, allowing an attacker to potentially manipulate the data read from the file.</Justification>
  </Issue>
</Issues>
```"
CWE-79,src/CWE_79__proc_open__func_preg_replace__Use_untrusted_data_script-window_SetInterval.php,"<!-- 
Unsafe sample
input : use proc_open to read /tmp/tainted.txt
SANITIZE : use of preg_replace
File : unsafe, use of untrusted data in the function setInterval
-->

<!--Copyright 2015 Bertrand STIVALET 

Permission is hereby granted, without written agreement or royalty fee, to

use, copy, modify, and distribute this software and its documentation for

any purpose, provided that the above copyright notice and the following

three paragraphs appear in all copies of this software.


IN NO EVENT SHALL AUTHORS BE LIABLE TO ANY PARTY FOR DIRECT,

INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES ARISING OUT OF THE 

USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF AUTHORS HAVE

BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.


AUTHORS SPECIFICALLY DISCLAIM ANY WARRANTIES INCLUDING, BUT NOT

LIMITED TO THE IMPLIED WARRANTIES OF MERCHANTABILITY, FITNESS FOR A

PARTICULAR PURPOSE, AND NON-INFRINGEMENT.


THE SOFTWARE IS PROVIDED ON AN ""AS-IS"" BASIS AND AUTHORS HAVE NO

OBLIGATION TO PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR

MODIFICATIONS.-->


<!DOCTYPE html>
<html>
<head>
<script>
<?php
$descriptorspec = array(
  0 => array(""pipe"", ""r""),
  1 => array(""pipe"", ""w""),
  2 => array(""file"", ""/tmp/error-output.txt"", ""a"")
  );
$cwd = '/tmp';
$process = proc_open('more /tmp/tainted.txt', $descriptorspec, $pipes, $cwd, NULL);
if (is_resource($process)) {
  fclose($pipes[0]);
  $tainted = stream_get_contents($pipes[1]);
  fclose($pipes[1]);
  $return_value = proc_close($process);
}

$tainted = preg_replace('/\'/', '', $tainted);


echo ""window.setInterval('"". $tainted .""');"" ;
?>
 </script>
</head>
<body>
<h1>Hello World!</h1>
</body>
</html>","echo ""window.setInterval('"". $tainted .""');"" ;",True,True,"$tainted = preg_replace('/\'/', '', $tainted);


echo ""window.setInterval('"". $tainted .""');"" ;","```xml
<Issues>
  <Issue>
    <Type>Security</Type>
    <Weakness>CWE-77</Weakness>
    <Description>Improper Neutralization of Special Elements used in a Command ('Command Injection')</Description>
    <Severity>High</Severity>
    <File>File 1</File>
    <Code>$descriptorspec = array(
  0 => array(""pipe"", ""r""),
  1 => array(""pipe"", ""w""),
  2 => array(""file"", ""/tmp/error-output.txt"", ""a"")
  );
$cwd = '/tmp';
$process = proc_open('more /tmp/tainted.txt', $descriptorspec, $pipes, $cwd, NULL);</Code>
    <Justification>The code uses proc_open to execute a command with a hardcoded path, but the content of the file /tmp/tainted.txt is potentially attacker-controlled. While the 'more' command itself might not be directly exploitable for command injection, the attacker could potentially influence the system state through the contents of the file, leading to unexpected behavior or vulnerabilities.</Justification>
  </Issue>
  <Issue>
    <Type>Security</Type>
    <Weakness>CWE-79</Weakness>
    <Description>Improper Neutralization of Input During Web Page Generation ('Cross-site Scripting')</Description>
    <Severity>High</Severity>
    <File>File 1</File>
    <Code>$tainted = preg_replace('/\'/', '', $tainted);


echo ""window.setInterval('"". $tainted .""');"" ;</Code>
    <Justification>The code reads data from a file, sanitizes it by removing single quotes, and then embeds it directly into JavaScript code within the setInterval function.  Even with the removal of single quotes, this is still vulnerable to XSS. An attacker could craft the contents of /tmp/tainted.txt to include malicious JavaScript code that would be executed in the victim's browser when the page is loaded. For example, an attacker can inject javascript code without single quotes.</Justification>
  </Issue>
</Issues>
```"
CWE-91,src/CWE_91__popen__func_FILTER-VALIDATION-email_filter__username-sprintf_%s_simple_quote.php,"<?php







$handle = popen('/bin/cat /tmp/tainted.txt', 'r');
$tainted = fread($handle, 4096);
pclose($handle);

if (filter_var($sanitized, FILTER_VALIDATE_EMAIL))
  $tainted = $sanitized ;
else
  $tainted = """" ;

$query = sprintf(""user[username='%s']"", $tainted);


$xml = simplexml_load_file(""users.xml"");
echo ""query : "". $query .""<br /><br />"" ;

$res=$xml->xpath($query);
print_r($res);
echo ""<br />"" ;

?>","$xml = simplexml_load_file(""users.xml"");",True,True,"$query = sprintf(""user[username='%s']"", $tainted);

$xml = simplexml_load_file(""users.xml"");
echo ""query : "". $query .""<br /><br />"" ;

$res=$xml->xpath($query);","```xml
<Issues>
  <Issue>
    <Type>Security</Type>
    <Weakness>CWE-78</Weakness>
    <Description>Improper Neutralization of Special Elements used in a Command ('Command Injection')</Description>
    <Severity>High</Severity>
    <File>File 1</File>
    <Code>$handle = popen('/bin/cat /tmp/tainted.txt', 'r');</Code>
    <Justification>The code uses popen to execute a command. The command includes a hardcoded path to a file, but popen itself can be dangerous if the first argument is derived from external input (which it is not here). However, the file '/tmp/tainted.txt' could be modified by an attacker to contain malicious commands.</Justification>
  </Issue>
  <Issue>
    <Type>Security</Type>
    <Weakness>CWE-91</Weakness>
    <Description>XML Injection (aka Blind XPath Injection)</Description>
    <Severity>High</Severity>
    <File>File 1</File>
    <Code>$query = sprintf(""user[username='%s']"", $tainted);

$xml = simplexml_load_file(""users.xml"");
echo ""query : "". $query .""&lt;br /&gt;&lt;br /&gt;"" ;

$res=$xml->xpath($query);</Code>
    <Justification>The code constructs an XPath query using unsanitized input from the '$tainted' variable. An attacker could inject malicious XPath syntax into the input, potentially allowing them to bypass authentication, extract sensitive information, or manipulate the XML data.</Justification>
  </Issue>
  <Issue>
    <Type>Reliability</Type>
    <Weakness>CWE-252</Weakness>
    <Description>Unchecked Return Value</Description>
    <Severity>Medium</Severity>
    <File>File 1</File>
    <Code>$handle = popen('/bin/cat /tmp/tainted.txt', 'r');
$tainted = fread($handle, 4096);
pclose($handle);</Code>
    <Justification>The code does not check the return values of popen, fread and pclose. If any of these functions fail, the program might continue with an invalid handle or without properly closing the pipe, leading to unexpected behavior or resource leaks. The fread function may also return a value less than 4096, which needs to be checked to see if the entire file has been read.</Justification>
  </Issue>
  <Issue>
    <Type>Security</Type>
    <Weakness>CWE-732</Weakness>
    <Description>Incorrect Permission Assignment for Critical Resource</Description>
    <Severity>Medium</Severity>
    <File>File 1</File>
    <Code>$handle = popen('/bin/cat /tmp/tainted.txt', 'r');
$tainted = fread($handle, 4096);
pclose($handle);</Code>
    <Justification>The code reads from '/tmp/tainted.txt'. If the permissions on this file are incorrectly set, an attacker could modify the file to inject malicious data, leading to vulnerabilities such as code injection or information disclosure.</Justification>
  </Issue>
</Issues>
```"
CWE-90,src/CWE_90__object-indexArray__func_htmlentities__userByMail-sprintf_%s_simple_quote.php,"<?php







class Input{
  private $input;

  public function getInput(){
    return $this->input['realOne'];
  }

  public  function __construct(){
    $this->input = array();
    $this->input['test']= 'safe' ;
    $this->input['realOne']= $_GET['UserData'] ;
    $this->input['trap']= 'safe' ;
  }
}
$temp = new Input();
$tainted =  $temp->getInput();

$tainted = htmlentities($tainted, ENT_QUOTES);

$query = sprintf(""(&(objectCategory=person)(objectClass=user)(mail='%s'))"", $tainted);


$ds=ldap_connect(""localhost""); 
$r=ldap_bind($ds);
$sr=ldap_search($ds,""o=My Company, c=US"", $query);  
ldap_close($ds);

?>","$ds=ldap_connect(""localhost"");",True,True,"$tainted = htmlentities($tainted, ENT_QUOTES);

$query = sprintf(""(&(objectCategory=person)(objectClass=user)(mail='%s'))"", $tainted);


$ds=ldap_connect(""localhost"");","```xml
<Issues>
  <Issue>
    <Type>Security</Type>
    <Weakness>CWE-90</Weakness>
    <Description>Improper Neutralization of Special Elements used in an LDAP Query ('LDAP Injection')</Description>
    <Severity>High</Severity>
    <File>File 1</File>
    <Code>$tainted = htmlentities($tainted, ENT_QUOTES);

$query = sprintf(""(&(objectCategory=person)(objectClass=user)(mail='%s'))"", $tainted);


$ds=ldap_connect(""localhost"");</Code>
    <Justification>The code constructs an LDAP query using user-controlled input ($tainted) without proper sanitization. Although htmlentities is used, it may not be sufficient to prevent LDAP injection attacks as it primarily focuses on HTML entities, not LDAP-specific special characters. An attacker could manipulate the $tainted variable to inject arbitrary LDAP commands, potentially bypassing authentication or accessing sensitive information.</Justification>
  </Issue>
  <Issue>
    <Type>Reliability</Type>
    <Weakness>CWE-252</Weakness>
    <Description>Unchecked Return Value</Description>
    <Severity>Medium</Severity>
    <File>File 1</File>
    <Code>$ds=ldap_connect(""localhost""); 
$r=ldap_bind($ds);
$sr=ldap_search($ds,""o=My Company, c=US"", $query);  
ldap_close($ds);</Code>
    <Justification>The code does not check the return values of ldap_connect, ldap_bind, and ldap_search. If any of these functions fail, they will return false, and the script will continue to execute, potentially leading to errors or unexpected behavior. For example, if ldap_connect fails, $ds will be false, and subsequent calls to ldap_bind and ldap_search will result in errors.</Justification>
  </Issue>
</Issues>
```"
CWE-79,src/CWE_79__unserialize__func_mysql_real_escape_string__Unsafe_use_untrusted_data-comment.php,"<!-- 
Unsafe sample
input : Get a serialize string in POST and unserialize it
SANITIZE : use of mysql_real_escape string
File : unsafe, use of untrusted data in a comment
-->

<!--Copyright 2015 Bertrand STIVALET 

Permission is hereby granted, without written agreement or royalty fee, to

use, copy, modify, and distribute this software and its documentation for

any purpose, provided that the above copyright notice and the following

three paragraphs appear in all copies of this software.


IN NO EVENT SHALL AUTHORS BE LIABLE TO ANY PARTY FOR DIRECT,

INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES ARISING OUT OF THE 

USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF AUTHORS HAVE

BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.


AUTHORS SPECIFICALLY DISCLAIM ANY WARRANTIES INCLUDING, BUT NOT

LIMITED TO THE IMPLIED WARRANTIES OF MERCHANTABILITY, FITNESS FOR A

PARTICULAR PURPOSE, AND NON-INFRINGEMENT.


THE SOFTWARE IS PROVIDED ON AN ""AS-IS"" BASIS AND AUTHORS HAVE NO

OBLIGATION TO PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR

MODIFICATIONS.-->


<!DOCTYPE html>
<html>
<head>
<!--
<?php
$string = $_POST['UserData'] ;
$tainted = unserialize($string);
    

$tainted = mysql_real_escape_string($tainted);


echo $tainted ;
?>
-->
</head>
<body>
<h1>Hello World!</h1>
</body>
</html>",echo $tainted ;,False,False,,"```xml
<Issues>
  <Issue>
    <Type>Security</Type>
    <Weakness>CWE-502</Weakness>
    <Description>Deserialization of Untrusted Data</Description>
    <Severity>High</Severity>
    <File>File 1</File>
    <Code>$string = $_POST['UserData'] ;
$tainted = unserialize($string);</Code>
    <Justification>The code uses unserialize() on user-supplied data ($_POST['UserData']), which allows for arbitrary code execution. Deserialization of untrusted data can lead to serious vulnerabilities.</Justification>
  </Issue>
  <Issue>
    <Type>Security</Type>
    <Weakness>CWE-477</Weakness>
    <Description>Use of Obsolete Function</Description>
    <Severity>Low</Severity>
    <File>File 1</File>
    <Code>$tainted = mysql_real_escape_string($tainted);</Code>
    <Justification>The code uses the 'mysql_real_escape_string' function, which is deprecated. This function is part of the old 'mysql' extension, which is no longer maintained and has been removed in newer PHP versions. This suggests the code has not been actively reviewed or maintained.</Justification>
  </Issue>
  <Issue>
    <Type>Security</Type>
    <Weakness>CWE-77</Weakness>
    <Description>Improper Neutralization of Special Elements used in a Command ('Command Injection')</Description>
    <Severity>Medium</Severity>
    <File>File 1</File>
    <Code>echo $tainted ;</Code>
    <Justification>The code echoes the tainted data, which might lead to command injection if the data contains special elements.</Justification>
  </Issue>
</Issues>
```"
CWE-89,src/CWE_89__object-classicGet__func_preg_match-no_filtering__select_from-interpretation_simple_quote.php,"<?php







class Input{
  private $input;

  public function getInput(){
    return $this->input;
  }

  public  function __construct(){
   $this->input = $_GET['UserData'] ;
  }
}
$temp = new Input();
$tainted =  $temp->getInput();

$re = ""/^.*$/"";
if(preg_match($re, $tainted) == 1){
  $tainted = $tainted;
}
else{
  $tainted = """";
}

$query = ""SELECT * FROM ' $tainted '"";


$conn = mysql_connect('localhost', 'mysql_user', 'mysql_password'); 
mysql_select_db('dbname') ;
echo ""query : "". $query .""<br /><br />"" ;

$res = mysql_query($query); 

while($data =mysql_fetch_array($res)){
print_r($data) ;
echo ""<br />"" ;
} 
mysql_close($conn);

?>","$conn = mysql_connect('localhost', 'mysql_user', 'mysql_password'); ",True,False,"$query = ""SELECT * FROM ' $tainted '"";","```xml
<Issues>
  <Issue>
    <Type>Security</Type>
    <Weakness>CWE-89</Weakness>
    <Description>Improper Neutralization of Special Elements used in an SQL Command ('SQL Injection')</Description>
    <Severity>Critical</Severity>
    <File>File 1</File>
    <Code>$query = ""SELECT * FROM ' $tainted '"";</Code>
    <Justification>The code is vulnerable to SQL injection because it directly incorporates user-provided input ($tainted) into the SQL query without proper sanitization or parameterization. An attacker could manipulate the input to inject malicious SQL code, potentially compromising the database.</Justification>
  </Issue>
  <Issue>
    <Type>Security</Type>
    <Weakness>CWE-477</Weakness>
    <Description>Use of Obsolete Function</Description>
    <Severity>Medium</Severity>
    <File>File 1</File>
    <Code>$conn = mysql_connect('localhost', 'mysql_user', 'mysql_password'); 
mysql_select_db('dbname') ;
$res = mysql_query($query); </Code>
    <Justification>The code uses the `mysql_connect`, `mysql_select_db`, and `mysql_query` functions, which are deprecated and insecure. These functions are vulnerable to SQL injection and other security issues and should be replaced with the more secure `mysqli` or `PDO` alternatives.</Justification>
  </Issue>
</Issues>
```"
CWE-79,src/CWE_79__object-Array__whitelist_using_array__Use_untrusted_data_script-window_SetInterval.php,"<!-- 
Unsafe sample
input : get the field userData from the variable $_GET via an object, which store it in a array
SANITIZE : use in_array to check if $tainted is in the white list
File : unsafe, use of untrusted data in the function setInterval
-->

<!--Copyright 2015 Bertrand STIVALET 

Permission is hereby granted, without written agreement or royalty fee, to

use, copy, modify, and distribute this software and its documentation for

any purpose, provided that the above copyright notice and the following

three paragraphs appear in all copies of this software.


IN NO EVENT SHALL AUTHORS BE LIABLE TO ANY PARTY FOR DIRECT,

INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES ARISING OUT OF THE 

USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF AUTHORS HAVE

BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.


AUTHORS SPECIFICALLY DISCLAIM ANY WARRANTIES INCLUDING, BUT NOT

LIMITED TO THE IMPLIED WARRANTIES OF MERCHANTABILITY, FITNESS FOR A

PARTICULAR PURPOSE, AND NON-INFRINGEMENT.


THE SOFTWARE IS PROVIDED ON AN ""AS-IS"" BASIS AND AUTHORS HAVE NO

OBLIGATION TO PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR

MODIFICATIONS.-->


<!DOCTYPE html>
<html>
<head>
<script>
<?php
class Input{
  private $input;

  public function getInput(){
    return $this->input[1];
  }

  public  function __construct(){
    $this->input = array();
    $this->input[0]= 'safe' ;
    $this->input[1]= $_GET['UserData'] ;
    $this->input[2]= 'safe' ;
  }
}
$temp = new Input();
$tainted =  $temp->getInput();

$legal_table = array(""safe1"", ""safe2"");
if (in_array($tainted, $legal_table, true)) {
  $tainted = $tainted;
} else {
  $tainted = $legal_table[0];
}


echo ""window.setInterval('"". $tainted .""');"" ;
?>
 </script>
</head>
<body>
<h1>Hello World!</h1>
</body>
</html>","echo ""window.setInterval('"". $tainted .""');"" ;",True,True,"echo ""window.setInterval('"". $tainted .""');"" ;","```xml
<Issues>
  <Issue>
    <Type>Security</Type>
    <Weakness>CWE-79</Weakness>
    <Description>Improper Neutralization of Input During Web Page Generation ('Cross-site Scripting')</Description>
    <Severity>Medium</Severity>
    <File>File 1</File>
    <Code>echo ""window.setInterval('"". $tainted .""');"" ;</Code>
    <Justification>The code uses untrusted data ($tainted) directly within the JavaScript setInterval function. Even though the $tainted variable is sanitized using in_array, the setInterval function can still execute arbitrary JavaScript code if the input contains a valid JavaScript expression. This constitutes a Cross-Site Scripting (XSS) vulnerability.</Justification>
  </Issue>
</Issues>
```"
CWE-90,src/CWE_90__object-classicGet__no_sanitizing__userByCN-interpretation_simple_quote.php,"<?php







class Input{
  private $input;

  public function getInput(){
    return $this->input;
  }

  public  function __construct(){
   $this->input = $_GET['UserData'] ;
  }
}
$temp = new Input();
$tainted =  $temp->getInput();



$query = ""(&(objectCategory=person)(objectClass=user)(cn=' $tainted '))"";


$ds=ldap_connect(""localhost""); 
$r=ldap_bind($ds);
$sr=ldap_search($ds,""o=My Company, c=US"", $query);  
ldap_close($ds);

?>","$ds=ldap_connect(""localhost"");",True,False,"$query = ""(&(objectCategory=person)(objectClass=user)(cn=' $tainted '))"";","```xml
<Issues>
  <Issue>
    <Type>Security</Type>
    <Weakness>CWE-90</Weakness>
    <Description>Improper Neutralization of Special Elements used in an LDAP Query ('LDAP Injection')</Description>
    <Severity>High</Severity>
    <File>File 1</File>
    <Code>$query = ""(&(objectCategory=person)(objectClass=user)(cn=' $tainted '))"";</Code>
    <Justification>The code constructs an LDAP query by directly embedding user-controlled input ($tainted) without proper sanitization. This can lead to LDAP injection vulnerabilities, allowing attackers to modify the query and potentially access or manipulate sensitive information.</Justification>
  </Issue>
  <Issue>
    <Type>Reliability</Type>
    <Weakness>CWE-252</Weakness>
    <Description>Unchecked Return Value</Description>
    <Severity>Medium</Severity>
    <File>File 1</File>
    <Code>$r=ldap_bind($ds);</Code>
    <Justification>The code does not check the return value of ldap_bind(). If the bind operation fails, $r will be false, but the code continues to use $ds in ldap_search(), which could lead to errors or unexpected behavior.</Justification>
  </Issue>
  <Issue>
    <Type>Reliability</Type>
    <Weakness>CWE-252</Weakness>
    <Description>Unchecked Return Value</Description>
    <Severity>Medium</Severity>
    <File>File 1</File>
    <Code>$sr=ldap_search($ds,""o=My Company, c=US"", $query);</Code>
    <Justification>The code does not check the return value of ldap_search(). If the search operation fails, $sr will be false, but the code continues without handling the error. This could lead to incorrect results or further errors in the application.</Justification>
  </Issue>
</Issues>
```"
CWE-79,src/CWE_79__object-directGet__func_FILTER-CLEANING-number_int_filter__Use_untrusted_data_propertyValue_CSS-property_Value.php,"<!-- 
Unsafe sample
input : get the field userData from the variable $_GET via an object
Uses a number_int_filter via filter_var function
File : use of untrusted data in a property value (CSS)
-->

<!--Copyright 2015 Bertrand STIVALET 

Permission is hereby granted, without written agreement or royalty fee, to

use, copy, modify, and distribute this software and its documentation for

any purpose, provided that the above copyright notice and the following

three paragraphs appear in all copies of this software.


IN NO EVENT SHALL AUTHORS BE LIABLE TO ANY PARTY FOR DIRECT,

INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES ARISING OUT OF THE 

USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF AUTHORS HAVE

BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.


AUTHORS SPECIFICALLY DISCLAIM ANY WARRANTIES INCLUDING, BUT NOT

LIMITED TO THE IMPLIED WARRANTIES OF MERCHANTABILITY, FITNESS FOR A

PARTICULAR PURPOSE, AND NON-INFRINGEMENT.


THE SOFTWARE IS PROVIDED ON AN ""AS-IS"" BASIS AND AUTHORS HAVE NO

OBLIGATION TO PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR

MODIFICATIONS.-->


<!DOCTYPE html>
<html>
<head>
<style>
<?php
class Input{
  public function getInput(){
    return $_GET['UserData'] ;
  }
}

$temp = new Input();
$tainted =  $temp->getInput();

$sanitized = filter_var($tainted, FILTER_SANITIZE_NUMBER_INT);
if (filter_var($sanitized, FILTER_VALIDATE_INT))
  $tainted = $sanitized ;
else
  $tainted = """" ;


echo ""body { color :"". $tainted ."" ; }"" ;
?>
 </style> 
 </script>
</head>
<body>
<h1>Hello World!</h1>
</body>
</html>","echo ""body { color :"". $tainted ."" ; }"" ;",True,True,"echo ""body { color :"". $tainted ."" ; }"" ;","```xml
<Issues>
  <Issue>
    <Type>Security</Type>
    <Weakness>CWE-79</Weakness>
    <Description>Improper Neutralization of Input During Web Page Generation ('Cross-site Scripting')</Description>
    <Severity>Medium</Severity>
    <File>File 1</File>
    <Code>echo ""body { color :"". $tainted ."" ; }"" ;</Code>
    <Justification>The code uses unfiltered input `$tainted` in CSS, which can allow an attacker to inject arbitrary CSS code and potentially perform XSS attacks, especially if the input is not strictly a color value but contains other CSS properties or JavaScript expressions (through `expression()` in older IE versions).</Justification>
  </Issue>
</Issues>
```"
CWE-90,src/CWE_90__fopen__func_preg_match-no_filtering__not_name-concatenation_simple_quote.php,"<?php







$handle = @fopen(""/tmp/tainted.txt"", ""r"");

if ($handle) {
  if(($tainted = fgets($handle, 4096)) == false) {
    $tainted = """";
  }
  fclose($handle);
} else {
  $tainted = """";
}

$re = ""/^.*$/"";
if(preg_match($re, $tainted) == 1){
  $tainted = $tainted;
}
else{
  $tainted = """";
}

$query = ""!name='"". $tainted . ""'"";


$ds=ldap_connect(""localhost""); 
$r=ldap_bind($ds);
$sr=ldap_search($ds,""o=My Company, c=US"", $query);  
ldap_close($ds);

?>","$ds=ldap_connect(""localhost"");",True,False,"$query = ""!name='"". $tainted . ""'"";","```xml
<Issues>
  <Issue>
    <Type>Security</Type>
    <Weakness>CWE-90</Weakness>
    <Description>Improper Neutralization of Special Elements used in an LDAP Query ('LDAP Injection')</Description>
    <Severity>High</Severity>
    <File>File 1</File>
    <Code>$query = ""!name='"". $tainted . ""'"";</Code>
    <Justification>The code constructs an LDAP query by directly embedding user-controlled input ($tainted) without proper sanitization. This allows an attacker to inject arbitrary LDAP code, potentially leading to unauthorized data access or modification.</Justification>
  </Issue>
  <Issue>
    <Type>Reliability</Type>
    <Weakness>CWE-252</Weakness>
    <Description>Unchecked Return Value</Description>
    <Severity>Medium</Severity>
    <File>File 1</File>
    <Code>$handle = @fopen(""/tmp/tainted.txt"", ""r"");</Code>
    <Justification>The code uses the @ operator to suppress errors from fopen. This means that if fopen fails (e.g., due to permissions), the $handle variable will be false, but the code will continue without checking for this error. This could lead to unexpected behavior or errors later in the script when trying to use $handle.</Justification>
  </Issue>
  <Issue>
    <Type>Reliability</Type>
    <Weakness>CWE-252</Weakness>
    <Description>Unchecked Return Value</Description>
    <Severity>Medium</Severity>
    <File>File 1</File>
    <Code>$r=ldap_bind($ds);</Code>
    <Justification>The code does not check the return value of ldap_bind. If the bind operation fails, the script will continue execution without handling the error, potentially leading to further issues when subsequent LDAP operations are performed.</Justification>
  </Issue>
  <Issue>
    <Type>Reliability</Type>
    <Weakness>CWE-252</Weakness>
    <Description>Unchecked Return Value</Description>
    <Severity>Medium</Severity>
    <File>File 1</File>
    <Code>$sr=ldap_search($ds,""o=My Company, c=US"", $query);</Code>
    <Justification>The code does not check the return value of ldap_search. If the search operation fails, the script will continue execution without handling the error, potentially leading to further issues if the search result is expected to be valid.</Justification>
  </Issue>
  <Issue>
    <Type>Security</Type>
    <Weakness>CWE-424</Weakness>
    <Description>Improper Protection of Alternate Path</Description>
    <Severity>Low</Severity>
    <File>File 1</File>
    <Code>$handle = @fopen(""/tmp/tainted.txt"", ""r"");</Code>
    <Justification>The code reads from a file located at `/tmp/tainted.txt`. If an attacker can control the contents of this file, they could potentially influence the application's behavior. While the application attempts to sanitize the input, the initial vulnerability lies in relying on an external, potentially untrusted, data source. The @ operator suppresses errors, which can hide issues related to file access.</Justification>
  </Issue>
  <Issue>
    <Type>Security</Type>
    <Weakness>CWE-571</Weakness>
    <Description>Expression is Always True</Description>
    <Severity>Low</Severity>
    <File>File 1</File>
    <Code>if(preg_match($re, $tainted) == 1){
  $tainted = $tainted;
}
else{
  $tainted = """";
}</Code>
    <Justification>The regular expression `/^.*$/` will always match any string, including an empty string. Therefore, the `if` condition will always evaluate to true, and the `else` block will never be executed. This makes the input validation ineffective, as the $tainted variable is always assigned its original value, regardless of its content. This can allow malicious input to pass through and potentially lead to LDAP injection.</Justification>
  </Issue>
</Issues>
```"
CWE-89,src/CWE_89__object-indexArray__no_sanitizing__select_from_where-concatenation.php,"<?php







class Input{
  private $input;

  public function getInput(){
    return $this->input['realOne'];
  }

  public  function __construct(){
    $this->input = array();
    $this->input['test']= 'safe' ;
    $this->input['realOne']= $_GET['UserData'] ;
    $this->input['trap']= 'safe' ;
  }
}
$temp = new Input();
$tainted =  $temp->getInput();



$query = ""SELECT * FROM student where id="". $tainted . """";


$conn = mysql_connect('localhost', 'mysql_user', 'mysql_password'); 
mysql_select_db('dbname') ;
echo ""query : "". $query .""<br /><br />"" ;

$res = mysql_query($query); 

while($data =mysql_fetch_array($res)){
print_r($data) ;
echo ""<br />"" ;
} 
mysql_close($conn);

?>","$conn = mysql_connect('localhost', 'mysql_user', 'mysql_password'); ",True,False,"$query = ""SELECT * FROM student where id="". $tainted . """";","```xml
<Issues>
  <Issue>
    <Type>Security</Type>
    <Weakness>CWE-89</Weakness>
    <Description>Improper Neutralization of Special Elements used in an SQL Command ('SQL Injection')</Description>
    <Severity>High</Severity>
    <File>File 1</File>
    <Code>$query = ""SELECT * FROM student where id="". $tainted . """";</Code>
    <Justification>The code directly concatenates user-controlled input ($tainted) into an SQL query. This allows an attacker to inject arbitrary SQL code, potentially compromising the database.</Justification>
  </Issue>
  <Issue>
    <Type>Security</Type>
    <Weakness>CWE-477</Weakness>
    <Description>Use of Obsolete Function</Description>
    <Severity>Medium</Severity>
    <File>File 1</File>
    <Code>$conn = mysql_connect('localhost', 'mysql_user', 'mysql_password');</Code>
    <Justification>The code uses the `mysql_connect` function, which is deprecated and insecure. It is recommended to use MySQLi or PDO instead.</Justification>
  </Issue>
  <Issue>
    <Type>Security</Type>
    <Weakness>CWE-477</Weakness>
    <Description>Use of Obsolete Function</Description>
    <Severity>Medium</Severity>
    <File>File 1</File>
    <Code>mysql_select_db('dbname') ;</Code>
    <Justification>The code uses the `mysql_select_db` function, which is deprecated and insecure. It is recommended to use MySQLi or PDO instead.</Justification>
  </Issue>
  <Issue>
    <Type>Security</Type>
    <Weakness>CWE-477</Weakness>
    <Description>Use of Obsolete Function</Description>
    <Severity>Medium</Severity>
    <File>File 1</File>
    <Code>$res = mysql_query($query);</Code>
    <Justification>The code uses the `mysql_query` function, which is deprecated and insecure. It is recommended to use MySQLi or PDO instead.</Justification>
  </Issue>
  <Issue>
    <Type>Security</Type>
    <Weakness>CWE-477</Weakness>
    <Description>Use of Obsolete Function</Description>
    <Severity>Medium</Severity>
    <File>File 1</File>
    <Code>while($data =mysql_fetch_array($res)){
print_r($data) ;
echo ""&lt;br /&gt;"" ;
}</Code>
    <Justification>The code uses the `mysql_fetch_array` function, which is deprecated and insecure. It is recommended to use MySQLi or PDO instead.</Justification>
  </Issue>
  <Issue>
    <Type>Security</Type>
    <Weakness>CWE-477</Weakness>
    <Description>Use of Obsolete Function</Description>
    <Severity>Medium</Severity>
    <File>File 1</File>
    <Code>mysql_close($conn);</Code>
    <Justification>The code uses the `mysql_close` function, which is deprecated and insecure. It is recommended to use MySQLi or PDO instead.</Justification>
  </Issue>
</Issues>
```"
CWE-89,src/CWE_89__POST__no_sanitizing__multiple_select-concatenation.php,"<?php







$tainted = $_POST['UserData'];



$query = ""SELECT * FROM COURSE c WHERE c.id IN (SELECT idcourse FROM REGISTRATION WHERE idstudent="". $tainted . "")"";


$conn = mysql_connect('localhost', 'mysql_user', 'mysql_password'); 
mysql_select_db('dbname') ;
echo ""query : "". $query .""<br /><br />"" ;

$res = mysql_query($query); 

while($data =mysql_fetch_array($res)){
print_r($data) ;
echo ""<br />"" ;
} 
mysql_close($conn);

?>","$conn = mysql_connect('localhost', 'mysql_user', 'mysql_password'); ",True,False,"$tainted = $_POST['UserData'];\n\n\n\n$query = ""SELECT * FROM COURSE c WHERE c.id IN (SELECT idcourse FROM REGISTRATION WHERE idstudent="". $tainted . "")"";","```xml
<Issues>
  <Issue>
    <Type>Security</Type>
    <Weakness>CWE-89</Weakness>
    <Description>Improper Neutralization of Special Elements used in an SQL Command ('SQL Injection')</Description>
    <Severity>High</Severity>
    <File>File 1</File>
    <Code>$tainted = $_POST['UserData'];\n\n\n\n$query = ""SELECT * FROM COURSE c WHERE c.id IN (SELECT idcourse FROM REGISTRATION WHERE idstudent="". $tainted . "")"";</Code>
    <Justification>The code directly incorporates user-supplied data ($tainted) into an SQL query without proper sanitization or parameterization. This allows an attacker to inject malicious SQL code, potentially compromising the database.</Justification>
  </Issue>
  <Issue>
    <Type>Security</Type>
    <Weakness>CWE-477</Weakness>
    <Description>Use of Obsolete Function</Description>
    <Severity>Medium</Severity>
    <File>File 1</File>
    <Code>$conn = mysql_connect('localhost', 'mysql_user', 'mysql_password'); \nmysql_select_db('dbname') ;
echo ""query : "". $query .""&lt;br /&gt;&lt;br /&gt;"" ;

$res = mysql_query($query); </Code>
    <Justification>The code uses the 'mysql_connect' and 'mysql_query' functions, which are deprecated. These functions are known to have security vulnerabilities and are no longer maintained, making the application susceptible to potential exploits. It is recommended to use mysqli or PDO instead.</Justification>
  </Issue>
</Issues>
```"
CWE-91,src/CWE_91__backticks__no_sanitizing__username_at-interpretation_simple_quote.php,"<?php







$tainted = `cat /tmp/tainted.txt`;



$query = ""


$xml = simplexml_load_file(""users.xml"");
echo ""query : "". $query .""<br /><br />"" ;

$res=$xml->xpath($query);
print_r($res);
echo ""<br />"" ;

?>","$xml = simplexml_load_file(""users.xml"");",True,True,"$tainted = `cat /tmp/tainted.txt`;

$query = ""","```xml
<Issues>
  <Issue>
    <Type>Security</Type>
    <Weakness>CWE-91</Weakness>
    <Description>XML Injection (aka Blind XPath Injection)</Description>
    <Severity>High</Severity>
    <File>File 1</File>
    <Code>$tainted = `cat /tmp/tainted.txt`;

$query = ""</Code>
    <Justification>The code takes external input from the file '/tmp/tainted.txt' and uses it directly in an XPath query without proper neutralization. This allows an attacker to modify the syntax, content, or commands of the XML before it is processed, leading to potential security vulnerabilities such as data exfiltration or denial of service.</Justification>
  </Issue>
</Issues>
```"
CWE-91,src/CWE_91__object-Array__func_FILTER-CLEANING-email_filter__username_text-sprintf_%s_simple_quote.php,"<?php







class Input{
  private $input;

  public function getInput(){
    return $this->input[1];
  }

  public  function __construct(){
    $this->input = array();
    $this->input[0]= 'safe' ;
    $this->input[1]= $_GET['UserData'] ;
    $this->input[2]= 'safe' ;
  }
}
$temp = new Input();
$tainted =  $temp->getInput();

$sanitized = filter_var($tainted, FILTER_SANITIZE_EMAIL);
if (filter_var($sanitized, FILTER_VALIDATE_EMAIL))
  $tainted = $sanitized ;
else
  $tainted = """" ;

$query = sprintf(""


$xml = simplexml_load_file(""users.xml"");
echo ""query : "". $query .""<br /><br />"" ;

$res=$xml->xpath($query);
print_r($res);
echo ""<br />"" ;

?>","$xml = simplexml_load_file(""users.xml"");",False,False,,"```xml
<Issues>
  <Issue>
    <Type>Security</Type>
    <Weakness>CWE-643</Weakness>
    <Description>Improper Neutralization of Data within XPath Expressions ('XPath Injection')</Description>
    <Severity>High</Severity>
    <File>File 1</File>
    <Code>$query = sprintf(""


$xml = simplexml_load_file(""users.xml"");
echo ""query : "". $query .""&lt;br /&gt;&lt;br /&gt;"" ;

$res=$xml->xpath($query);
print_r($res);
echo ""&lt;br /&gt;"" ;</Code>
    <Justification>The code constructs an XPath query using unsanitized input ($_GET['UserData']). Even though the input is filtered to be a valid email, this is not sufficient to prevent XPath injection. An attacker could craft a malicious email address that, when used in the XPath query, could extract sensitive data, bypass authentication, or even modify data within the XML database.</Justification>
  </Issue>
  <Issue>
    <Type>Reliability</Type>
    <Weakness>CWE-252</Weakness>
    <Description>Unchecked Return Value</Description>
    <Severity>Low</Severity>
    <File>File 1</File>
    <Code>$sanitized = filter_var($tainted, FILTER_SANITIZE_EMAIL);
if (filter_var($sanitized, FILTER_VALIDATE_EMAIL))
  $tainted = $sanitized ;
else
  $tainted = """" ;</Code>
    <Justification>The code uses filter_var with FILTER_SANITIZE_EMAIL, but it does not check if the filter_var function returns false. If the sanitization fails, the $sanitized variable might be false, which could lead to unexpected behavior in the validation step or later in the code.</Justification>
  </Issue>
  <Issue>
    <Type>Reliability</Type>
    <Weakness>CWE-391</Weakness>
    <Description>Unchecked Error Condition</Description>
    <Severity>Low</Severity>
    <File>File 1</File>
    <Code>$xml = simplexml_load_file(""users.xml"");
echo ""query : "". $query .""&lt;br /&gt;&lt;br /&gt;"" ;

$res=$xml->xpath($query);
print_r($res);</Code>
    <Justification>The code uses simplexml_load_file without checking if the file loading was successful. If users.xml does not exist or is not a valid XML file, simplexml_load_file will return false, and subsequent calls to $xml->xpath will result in an error. The code should check if $xml is false before proceeding.</Justification>
  </Issue>
</Issues>
```"
CWE-89,src/CWE_89__proc_open__no_sanitizing__join-concatenation_simple_quote.php,"<?php







$descriptorspec = array(
  0 => array(""pipe"", ""r""),
  1 => array(""pipe"", ""w""),
  2 => array(""file"", ""/tmp/error-output.txt"", ""a"")
  );
$cwd = '/tmp';
$process = proc_open('more /tmp/tainted.txt', $descriptorspec, $pipes, $cwd, NULL);
if (is_resource($process)) {
  fclose($pipes[0]);
  $tainted = stream_get_contents($pipes[1]);
  fclose($pipes[1]);
  $return_value = proc_close($process);
}



$query = ""SELECT lastname, firstname FROM drivers, vehicles WHERE drivers.id = vehicles.ownerid AND vehicles.tag='"". $tainted . ""'"";


$conn = mysql_connect('localhost', 'mysql_user', 'mysql_password'); 
mysql_select_db('dbname') ;
echo ""query : "". $query .""<br /><br />"" ;

$res = mysql_query($query); 

while($data =mysql_fetch_array($res)){
print_r($data) ;
echo ""<br />"" ;
} 
mysql_close($conn);

?>","$conn = mysql_connect('localhost', 'mysql_user', 'mysql_password'); ",True,False,"$query = ""SELECT lastname, firstname FROM drivers, vehicles WHERE drivers.id = vehicles.ownerid AND vehicles.tag='"". $tainted . ""'"";","```xml
<Issues>
  <Issue>
    <Type>Security</Type>
    <Weakness>CWE-89</Weakness>
    <Description>Improper Neutralization of Special Elements used in an SQL Command ('SQL Injection')</Description>
    <Severity>High</Severity>
    <File>File 1</File>
    <Code>$query = ""SELECT lastname, firstname FROM drivers, vehicles WHERE drivers.id = vehicles.ownerid AND vehicles.tag='"". $tainted . ""'"";</Code>
    <Justification>The code constructs an SQL query by directly concatenating user-controlled input ($tainted) without proper sanitization. This can lead to SQL injection vulnerabilities where an attacker can manipulate the query to execute arbitrary SQL code.</Justification>
  </Issue>
  <Issue>
    <Type>Security</Type>
    <Weakness>CWE-477</Weakness>
    <Description>Use of Obsolete Function</Description>
    <Severity>Medium</Severity>
    <File>File 1</File>
    <Code>$conn = mysql_connect('localhost', 'mysql_user', 'mysql_password'); 
mysql_select_db('dbname') ;
echo ""query : "". $query .""&lt;br /&gt;&lt;br /&gt;"" ;

$res = mysql_query($query); </Code>
    <Justification>The code uses the `mysql_connect` and `mysql_query` functions, which are deprecated. These functions are not maintained anymore and their usage may expose security vulnerabilities. It is recommended to use `mysqli` or `PDO` instead.</Justification>
  </Issue>
</Issues>
```"
CWE-90,src/CWE_90__object-indexArray__func_FILTER-VALIDATION-email_filter__userByMail-sprintf_%s_simple_quote.php,"<?php







class Input{
  private $input;

  public function getInput(){
    return $this->input['realOne'];
  }

  public  function __construct(){
    $this->input = array();
    $this->input['test']= 'safe' ;
    $this->input['realOne']= $_GET['UserData'] ;
    $this->input['trap']= 'safe' ;
  }
}
$temp = new Input();
$tainted =  $temp->getInput();

if (filter_var($sanitized, FILTER_VALIDATE_EMAIL))
  $tainted = $sanitized ;
else
  $tainted = """" ;

$query = sprintf(""(&(objectCategory=person)(objectClass=user)(mail='%s'))"", $tainted);


$ds=ldap_connect(""localhost""); 
$r=ldap_bind($ds);
$sr=ldap_search($ds,""o=My Company, c=US"", $query);  
ldap_close($ds);

?>","$ds=ldap_connect(""localhost"");",True,False,"$query = sprintf(""(&(objectCategory=person)(objectClass=user)(mail='%s'))"", $tainted);","```xml
<Issues>
  <Issue>
    <Type>Security</Type>
    <Weakness>CWE-90</Weakness>
    <Description>Improper Neutralization of Special Elements used in an LDAP Query ('LDAP Injection')</Description>
    <Severity>High</Severity>
    <File>File 1</File>
    <Code>$query = sprintf(""(&(objectCategory=person)(objectClass=user)(mail='%s'))"", $tainted);</Code>
    <Justification>The code constructs an LDAP query using unsanitized user input ($tainted). This allows an attacker to inject arbitrary LDAP commands, potentially bypassing authentication or accessing sensitive information.</Justification>
  </Issue>
  <Issue>
    <Type>Security</Type>
    <Weakness>CWE-252</Weakness>
    <Description>Unchecked Return Value</Description>
    <Severity>Medium</Severity>
    <File>File 1</File>
    <Code>$ds=ldap_connect(""localhost""); 
$r=ldap_bind($ds);
$sr=ldap_search($ds,""o=My Company, c=US"", $query);</Code>
    <Justification>The code does not check the return values of ldap_connect, ldap_bind, and ldap_search. If any of these functions fail, the subsequent code might operate on an invalid resource, leading to unexpected behavior or security vulnerabilities.</Justification>
  </Issue>
  <Issue>
    <Type>Reliability</Type>
    <Weakness>CWE-252</Weakness>
    <Description>Unchecked Return Value</Description>
    <Severity>Medium</Severity>
    <File>File 1</File>
    <Code>$ds=ldap_connect(""localhost""); 
$r=ldap_bind($ds);
$sr=ldap_search($ds,""o=My Company, c=US"", $query);</Code>
    <Justification>The code does not check the return values of ldap_connect, ldap_bind, and ldap_search. If any of these functions fail, the subsequent code might operate on an invalid resource, leading to unexpected behavior or system crash.</Justification>
  </Issue>
  <Issue>
    <Type>Security</Type>
    <Weakness>CWE-775</Weakness>
    <Description>Missing Release of File Descriptor or Handle after Effective Lifetime</Description>
    <Severity>Low</Severity>
    <File>File 1</File>
    <Code>$ds=ldap_connect(""localhost""); 
$r=ldap_bind($ds);
$sr=ldap_search($ds,""o=My Company, c=US"", $query);  
ldap_close($ds);</Code>
    <Justification>While ldap_close is present, failing to call it under certain conditions (e.g., exceptions during ldap_connect, ldap_bind or ldap_search) can lead to resource exhaustion (file descriptor/handle leak), potentially causing a denial-of-service.</Justification>
  </Issue>
  <Issue>
    <Type>Reliability</Type>
    <Weakness>CWE-775</Weakness>
    <Description>Missing Release of File Descriptor or Handle after Effective Lifetime</Description>
    <Severity>Low</Severity>
    <File>File 1</File>
    <Code>$ds=ldap_connect(""localhost""); 
$r=ldap_bind($ds);
$sr=ldap_search($ds,""o=My Company, c=US"", $query);  
ldap_close($ds);</Code>
    <Justification>While ldap_close is present, failing to call it under certain conditions (e.g., exceptions during ldap_connect, ldap_bind or ldap_search) can lead to resource exhaustion (file descriptor/handle leak), potentially causing a system crash or malfunction.</Justification>
  </Issue>
  <Issue>
    <Type>Security</Type>
    <Weakness>CWE-606</Weakness>
    <Description>Unchecked Input for Loop Condition</Description>
    <Severity>Low</Severity>
    <File>File 1</File>
    <Code>if (filter_var($sanitized, FILTER_VALIDATE_EMAIL))
  $tainted = $sanitized ;
else
  $tainted = """" ;</Code>
    <Justification>The `filter_var` function, when used with `FILTER_VALIDATE_EMAIL`, can still allow very long strings through if they conform to the basic email structure. If this very long string is then used in a loop condition elsewhere in the application, it could lead to a denial-of-service by excessive looping.</Justification>
  </Issue>
</Issues>
```"
CWE-79,src/CWE_79__system__whitelist_using_array__Use_untrusted_data_propertyValue_CSS-span_Style_Property_Value.php,"<!-- 
Unsafe sample
input : execute a ls command using the function system, and put the last result in $tainted
SANITIZE : use in_array to check if $tainted is in the white list
File : unsafe, use of untrusted data in a property value in a span tag(CSS)
-->

<!--Copyright 2015 Bertrand STIVALET 

Permission is hereby granted, without written agreement or royalty fee, to

use, copy, modify, and distribute this software and its documentation for

any purpose, provided that the above copyright notice and the following

three paragraphs appear in all copies of this software.


IN NO EVENT SHALL AUTHORS BE LIABLE TO ANY PARTY FOR DIRECT,

INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES ARISING OUT OF THE 

USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF AUTHORS HAVE

BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.


AUTHORS SPECIFICALLY DISCLAIM ANY WARRANTIES INCLUDING, BUT NOT

LIMITED TO THE IMPLIED WARRANTIES OF MERCHANTABILITY, FITNESS FOR A

PARTICULAR PURPOSE, AND NON-INFRINGEMENT.


THE SOFTWARE IS PROVIDED ON AN ""AS-IS"" BASIS AND AUTHORS HAVE NO

OBLIGATION TO PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR

MODIFICATIONS.-->


<!DOCTYPE html>
<html>
<head/>
<body>
<?php
$tainted = system('ls', $retval);

$legal_table = array(""safe1"", ""safe2"");
if (in_array($tainted, $legal_table, true)) {
  $tainted = $tainted;
} else {
  $tainted = $legal_table[0];
}


echo ""<span style=\""color :"". checked_data .""\"">Hey</span>"" ;
?>
<h1>Hello World!</h1>
</body>
</html>","echo ""<span style=\""color :"". checked_data .""\"">Hey</span>"" ;",True,True,"echo ""<span style=\""color :"". checked_data .""\"">Hey</span>"" ;","```xml
<Issues>
  <Issue>
    <Type>Security</Type>
    <Weakness>CWE-78</Weakness>
    <Description>Improper Neutralization of Special Elements used in a Command ('Command Injection')</Description>
    <Severity>High</Severity>
    <File>File 1</File>
    <Code>$tainted = system('ls', $retval);</Code>
    <Justification>The code uses the `system()` function to execute an OS command (`ls`). This function is vulnerable to command injection if the input is not properly sanitized. Although the output of the command is later validated, the initial execution is still a security risk. An attacker could potentially inject malicious commands that are executed before the validation step.</Justification>
  </Issue>
  <Issue>
    <Type>Security</Type>
    <Weakness>CWE-79</Weakness>
    <Description>Improper Neutralization of Input During Web Page Generation ('Cross-site Scripting')</Description>
    <Severity>Medium</Severity>
    <File>File 1</File>
    <Code>echo ""&lt;span style=\""color :"". checked_data .""\""&gt;Hey&lt;/span&gt;"" ;</Code>
    <Justification>The code uses the variable `checked_data` in a CSS property value within a span tag. If `checked_data` contains malicious code, it could lead to a Cross-Site Scripting (XSS) vulnerability. The code does not neutralize or sanitize the input before embedding it in the HTML output.</Justification>
  </Issue>
  <Issue>
    <Type>Reliability</Type>
    <Weakness>CWE-457</Weakness>
    <Description>Use of uninitialized variable</Description>
    <Severity>Medium</Severity>
    <File>File 1</File>
    <Code>echo ""&lt;span style=\""color :"". checked_data .""\""&gt;Hey&lt;/span&gt;"" ;</Code>
    <Justification>The code uses the variable `checked_data` without initializing it first. This could lead to unpredictable or unintended results. The value of `checked_data` is undefined, and the script's behavior depends on what value happens to be in memory at that location.</Justification>
  </Issue>
</Issues>
```"
CWE-91,src/CWE_91__unserialize__func_FILTER-CLEANING-special_chars_filter__username_at-interpretation_simple_quote.php,"<?php







$string = $_POST['UserData'] ;
$tainted = unserialize($string);
    

$sanitized = filter_var($tainted, FILTER_SANITIZE_SPECIAL_CHARS);
  $tainted = $sanitized ;
      

$query = ""


$xml = simplexml_load_file(""users.xml"");
echo ""query : "". $query .""<br /><br />"" ;

$res=$xml->xpath($query);
print_r($res);
echo ""<br />"" ;

?>","$xml = simplexml_load_file(""users.xml"");",False,False,,"```xml
<Issues>
  <Issue>
    <Type>Security</Type>
    <Weakness>CWE-502</Weakness>
    <Description>Deserialization of Untrusted Data</Description>
    <Severity>Critical</Severity>
    <File>File 1</File>
    <Code>$string = $_POST['UserData'] ;
$tainted = unserialize($string);</Code>
    <Justification>The code uses unserialize() on user-supplied data ($_POST['UserData']). This is extremely dangerous as it allows for arbitrary code execution if the serialized data is maliciously crafted.</Justification>
  </Issue>
  <Issue>
    <Type>Security</Type>
    <Weakness>CWE-79</Weakness>
    <Description>Improper Neutralization of Input During Web Page Generation ('Cross-site Scripting')</Description>
    <Severity>Medium</Severity>
    <File>File 1</File>
    <Code>echo ""query : "". $query .""&lt;br /&gt;&lt;br /&gt;"" ;</Code>
    <Justification>The code echoes the value of $query without proper sanitization. The $query variable contains the value of $sanitized. The $sanitized variable is the result of the filter_var($tainted, FILTER_SANITIZE_SPECIAL_CHARS) which will neutralize special characters, but it is still possible to inject malicious code through the xpath query. The output is then rendered in HTML, which is vulnerable to Cross-Site Scripting (XSS) attacks if $query contains malicious code.</Justification>
  </Issue>
  <Issue>
    <Type>Security</Type>
    <Weakness>CWE-643</Weakness>
    <Description>Improper Neutralization of Data within XPath Expressions ('XPath Injection')</Description>
    <Severity>High</Severity>
    <File>File 1</File>
    <Code>$sanitized = filter_var($tainted, FILTER_SANITIZE_SPECIAL_CHARS);
  $tainted = $sanitized ;
      

$query = ""</Code>
    <Justification>The code constructs an XPath query based on user-controlled data ($tainted). Even after sanitization with FILTER_SANITIZE_SPECIAL_CHARS, it's possible to craft malicious XPath expressions that could extract sensitive data or manipulate the XML structure, leading to XPath Injection vulnerabilities.</Justification>
  </Issue>
  <Issue>
    <Type>Reliability</Type>
    <Weakness>CWE-252</Weakness>
    <Description>Unchecked Return Value</Description>
    <Severity>Low</Severity>
    <File>File 1</File>
    <Code>$xml = simplexml_load_file(""users.xml"");</Code>
    <Justification>The code does not check the return value of simplexml_load_file(). If the file ""users.xml"" cannot be loaded (e.g., file not found, invalid XML), simplexml_load_file() will return FALSE, and subsequent operations on $xml will result in errors.</Justification>
  </Issue>
</Issues>
```"
CWE-79,src/CWE_79__object-directGet__ternary_white_list__Unsafe_use_untrusted_data-style.php,"<!-- 
Unsafe sample
input : get the field userData from the variable $_GET via an object
sanitize : use of ternary condition
File : unsafe, use of untrusted data in CSS
-->

<!--Copyright 2015 Bertrand STIVALET 

Permission is hereby granted, without written agreement or royalty fee, to

use, copy, modify, and distribute this software and its documentation for

any purpose, provided that the above copyright notice and the following

three paragraphs appear in all copies of this software.


IN NO EVENT SHALL AUTHORS BE LIABLE TO ANY PARTY FOR DIRECT,

INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES ARISING OUT OF THE 

USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF AUTHORS HAVE

BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.


AUTHORS SPECIFICALLY DISCLAIM ANY WARRANTIES INCLUDING, BUT NOT

LIMITED TO THE IMPLIED WARRANTIES OF MERCHANTABILITY, FITNESS FOR A

PARTICULAR PURPOSE, AND NON-INFRINGEMENT.


THE SOFTWARE IS PROVIDED ON AN ""AS-IS"" BASIS AND AUTHORS HAVE NO

OBLIGATION TO PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR

MODIFICATIONS.-->


<!DOCTYPE html>
<html>
<head>
<style>
<?php
class Input{
  public function getInput(){
    return $_GET['UserData'] ;
  }
}

$temp = new Input();
$tainted =  $temp->getInput();

$tainted = $tainted  == 'safe1' ? 'safe1' : 'safe2';


echo $tainted ;
?>
</style>
</head>
<body>
<h1>Hello World!</h1>
</body>
</html>",echo $tainted ;,True,True,echo $tainted ;,"```xml
<Issues>
  <Issue>
    <Type>Security</Type>
    <Weakness>CWE-79</Weakness>
    <Description>Improper Neutralization of Input During Web Page Generation ('Cross-site Scripting')</Description>
    <Severity>Medium</Severity>
    <File>File 1</File>
    <Code>echo $tainted ;</Code>
    <Justification>The code directly outputs the `$tainted` variable into the &lt;style&gt; section of the HTML document, which is used to define CSS rules. The `$tainted` variable comes directly from user input, which makes the code vulnerable to CSS injection. An attacker could inject malicious CSS code, potentially leading to information disclosure or other attacks.</Justification>
  </Issue>
  <Issue>
    <Type>Security</Type>
    <Weakness>CWE-477</Weakness>
    <Description>Use of Obsolete Function</Description>
    <Severity>Low</Severity>
    <File>File 1</File>
    <Code>&lt;?php
class Input{
  public function getInput(){
    return $_GET['UserData'] ;
  }
}

$temp = new Input();
$tainted =  $temp->getInput();

$tainted = $tainted  == 'safe1' ? 'safe1' : 'safe2';


echo $tainted ;
?&gt;</Code>
    <Justification>The code uses $_GET to retrieve data from the query string. While not inherently obsolete, relying solely on $_GET without proper validation and sanitization can be a sign of outdated practices and increase the risk of vulnerabilities. Modern frameworks often provide more robust and secure methods for handling user input.</Justification>
  </Issue>
  <Issue>
    <Type>Security</Type>
    <Weakness>CWE-571</Weakness>
    <Description>Expression is Always True</Description>
    <Severity>Low</Severity>
    <File>File 1</File>
    <Code>$tainted = $tainted  == 'safe1' ? 'safe1' : 'safe2';</Code>
    <Justification>The ternary operator always assigns either 'safe1' or 'safe2' to `$tainted`. While this mitigates direct injection, it reduces the input to a binary choice, which might not be the intended behavior and could introduce logic errors if the original input was meant to have more possible valid values.</Justification>
  </Issue>
  <Issue>
    <Type>Maintainability</Type>
    <Weakness>CWE-571</Weakness>
    <Description>Expression is Always True</Description>
    <Severity>Low</Severity>
    <File>File 1</File>
    <Code>$tainted = $tainted  == 'safe1' ? 'safe1' : 'safe2';</Code>
    <Justification>The ternary operator always assigns either 'safe1' or 'safe2' to `$tainted`. This makes the code harder to understand and maintain because it's not immediately clear what the original intent was. A more descriptive variable name or comment could improve readability.</Justification>
  </Issue>
</Issues>
```"
CWE-79,src/CWE_79__GET__no_sanitizing__Unsafe_use_untrusted_data-style.php,"<!-- 
Unsafe sample
input : reads the field UserData from the variable $_GET
sanitize : none
File : unsafe, use of untrusted data in CSS
-->

<!--Copyright 2015 Bertrand STIVALET 

Permission is hereby granted, without written agreement or royalty fee, to

use, copy, modify, and distribute this software and its documentation for

any purpose, provided that the above copyright notice and the following

three paragraphs appear in all copies of this software.


IN NO EVENT SHALL AUTHORS BE LIABLE TO ANY PARTY FOR DIRECT,

INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES ARISING OUT OF THE 

USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF AUTHORS HAVE

BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.


AUTHORS SPECIFICALLY DISCLAIM ANY WARRANTIES INCLUDING, BUT NOT

LIMITED TO THE IMPLIED WARRANTIES OF MERCHANTABILITY, FITNESS FOR A

PARTICULAR PURPOSE, AND NON-INFRINGEMENT.


THE SOFTWARE IS PROVIDED ON AN ""AS-IS"" BASIS AND AUTHORS HAVE NO

OBLIGATION TO PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR

MODIFICATIONS.-->


<!DOCTYPE html>
<html>
<head>
<style>
<?php
$tainted = $_GET['UserData'];




echo $tainted ;
?>
</style>
</head>
<body>
<h1>Hello World!</h1>
</body>
</html>",echo $tainted ;,True,True,"$tainted = $_GET['UserData'];




echo $tainted ;","```xml
<Issues>
  <Issue>
    <Type>Security</Type>
    <Weakness>CWE-79</Weakness>
    <Description>Improper Neutralization of Input During Web Page Generation ('Cross-site Scripting')</Description>
    <Severity>High</Severity>
    <File>File 1</File>
    <Code>
$tainted = $_GET['UserData'];




echo $tainted ;
</Code>
    <Justification>The code directly echoes user-supplied data from the $_GET['UserData'] parameter into the CSS style section of the HTML page without any sanitization. This allows an attacker to inject arbitrary CSS or even JavaScript code (through CSS expressions), leading to Cross-Site Scripting (XSS) vulnerabilities.</Justification>
  </Issue>
</Issues>
```"
CWE-90,src/CWE_90__system__func_preg_match-no_filtering__not_name-interpretation_simple_quote.php,"<?php







$tainted = system('ls', $retval);

$re = ""/^.*$/"";
if(preg_match($re, $tainted) == 1){
  $tainted = $tainted;
}
else{
  $tainted = """";
}

$query = ""!name=' $tainted '"";


$ds=ldap_connect(""localhost""); 
$r=ldap_bind($ds);
$sr=ldap_search($ds,""o=My Company, c=US"", $query);  
ldap_close($ds);

?>","$ds=ldap_connect(""localhost"");",True,False,"$query = ""!name=' $tainted '"";","```xml
<Issues>
  <Issue>
    <Type>Security</Type>
    <Weakness>CWE-77</Weakness>
    <Description>Improper Neutralization of Special Elements used in a Command ('Command Injection')</Description>
    <Severity>High</Severity>
    <File>File 1</File>
    <Code>$tainted = system('ls', $retval);</Code>
    <Justification>The `system` function executes an external command. If the command being executed (here, 'ls') is influenced by external input, it can lead to command injection vulnerabilities. Even though 'ls' is a static string here, the use of system function can be dangerous, especially if the filename is constructed from user input.</Justification>
  </Issue>
  <Issue>
    <Type>Security</Type>
    <Weakness>CWE-90</Weakness>
    <Description>Improper Neutralization of Special Elements used in an LDAP Query ('LDAP Injection')</Description>
    <Severity>High</Severity>
    <File>File 1</File>
    <Code>$query = ""!name=' $tainted '"";</Code>
    <Justification>The code constructs an LDAP query by directly embedding the `$tainted` variable, which is derived from the output of the `system` command, into the query string. This can lead to LDAP injection vulnerabilities if the output of the command contains special characters that are not properly neutralized. An attacker could manipulate the command output to inject malicious LDAP syntax, potentially gaining unauthorized access or control over the LDAP directory.</Justification>
  </Issue>
  <Issue>
    <Type>Reliability</Type>
    <Weakness>CWE-252</Weakness>
    <Description>Unchecked Return Value</Description>
    <Severity>Medium</Severity>
    <File>File 1</File>
    <Code>$r=ldap_bind($ds);
$sr=ldap_search($ds,""o=My Company, c=US"", $query);</Code>
    <Justification>The code does not check the return values of `ldap_bind` and `ldap_search`. If these functions fail (e.g., due to incorrect credentials or network issues), the script will continue to execute, potentially leading to unexpected behavior or security vulnerabilities. It's crucial to check the return values and handle errors appropriately to ensure the reliability of the application.</Justification>
  </Issue>
  <Issue>
    <Type>Security</Type>
    <Weakness>CWE-252</Weakness>
    <Description>Unchecked Return Value</Description>
    <Severity>Medium</Severity>
    <File>File 1</File>
    <Code>$r=ldap_bind($ds);
$sr=ldap_search($ds,""o=My Company, c=US"", $query);</Code>
    <Justification>The code does not check the return values of `ldap_bind` and `ldap_search`. These functions might fail due to various reasons (e.g., invalid credentials, network issues, or malformed queries). Without proper error handling, the application might proceed with incorrect assumptions, potentially leading to security vulnerabilities such as unauthorized access or information disclosure.</Justification>
  </Issue>
  <Issue>
    <Type>Maintainability</Type>
    <Weakness>CWE-571</Weakness>
    <Description>Expression is Always True</Description>
    <Severity>Low</Severity>
    <File>File 1</File>
    <Code>if(preg_match($re, $tainted) == 1){
  $tainted = $tainted;
}
else{
  $tainted = """";
}</Code>
    <Justification>The regular expression `re = ""/^.*$/""` will always match any string, including an empty string. Therefore, the `if` condition `preg_match($re, $tainted) == 1` will always evaluate to true. The `else` block will never be executed, making the code redundant. This reduces maintainability as it adds unnecessary complexity.</Justification>
  </Issue>
</Issues>
```"
CWE-79,src/CWE_79__object-Array__func_FILTER-CLEANING-special_chars_filter__Unsafe_use_untrusted_data-tag_Name.php,"<!-- 
Unsafe sample
input : get the field userData from the variable $_GET via an object, which store it in a array
Uses a special_chars_filter via filter_var function
File : unsafe, use of untrusted data in an tag name
-->

<!--Copyright 2015 Bertrand STIVALET 

Permission is hereby granted, without written agreement or royalty fee, to

use, copy, modify, and distribute this software and its documentation for

any purpose, provided that the above copyright notice and the following

three paragraphs appear in all copies of this software.


IN NO EVENT SHALL AUTHORS BE LIABLE TO ANY PARTY FOR DIRECT,

INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES ARISING OUT OF THE 

USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF AUTHORS HAVE

BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.


AUTHORS SPECIFICALLY DISCLAIM ANY WARRANTIES INCLUDING, BUT NOT

LIMITED TO THE IMPLIED WARRANTIES OF MERCHANTABILITY, FITNESS FOR A

PARTICULAR PURPOSE, AND NON-INFRINGEMENT.


THE SOFTWARE IS PROVIDED ON AN ""AS-IS"" BASIS AND AUTHORS HAVE NO

OBLIGATION TO PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR

MODIFICATIONS.-->


<!DOCTYPE html>
<html>
<head/>
<body>
<?php
class Input{
  private $input;

  public function getInput(){
    return $this->input[1];
  }

  public  function __construct(){
    $this->input = array();
    $this->input[0]= 'safe' ;
    $this->input[1]= $_GET['UserData'] ;
    $this->input[2]= 'safe' ;
  }
}
$temp = new Input();
$tainted =  $temp->getInput();

$sanitized = filter_var($tainted, FILTER_SANITIZE_SPECIAL_CHARS);
  $tainted = $sanitized ;
      


echo ""<"".  $tainted ."" href= \""/bob\"" />"" ;
?>
<h1>Hello World!</h1>
</body>
</html>","echo ""<"".  $tainted ."" href= \""/bob\"" />"" ;",True,True,"$tainted =  $temp->getInput();

$sanitized = filter_var($tainted, FILTER_SANITIZE_SPECIAL_CHARS);
  $tainted = $sanitized ;
      


echo ""<"".  $tainted ."" href= \""/bob\"" />"" ;","```xml
<Issues>
  <Issue>
    <Type>Security</Type>
    <Weakness>CWE-79</Weakness>
    <Description>Improper Neutralization of Input During Web Page Generation ('Cross-site Scripting')</Description>
    <Severity>Medium</Severity>
    <File>File 1</File>
    <Code>$tainted =  $temp->getInput();

$sanitized = filter_var($tainted, FILTER_SANITIZE_SPECIAL_CHARS);
  $tainted = $sanitized ;
      


echo ""&lt;"".  $tainted ."" href= \""/bob\"" /&gt;"" ;</Code>
    <Justification>The code uses user-controlled input `$tainted` as an HTML tag name after sanitizing it with `FILTER_SANITIZE_SPECIAL_CHARS`. While this filter encodes special characters, it does not prevent the injection of arbitrary HTML tags.  An attacker could inject a tag that, while not directly executing script, could still modify the page's structure or content in undesirable ways, or attempt to perform phishing attacks.  For example, injecting an &lt;img&gt; tag could lead to information disclosure or further exploitation.</Justification>
  </Issue>
</Issues>
```"
CWE-79,src/CWE_79__shell_exec__func_FILTER-VALIDATION-email_filter__Use_untrusted_data_script-window_SetInterval.php,"<!-- 
Unsafe sample
input : use shell_exec to cat /tmp/tainted.txt
Flushes content of $sanitized if the filter email_filter is not applied
File : unsafe, use of untrusted data in the function setInterval
-->

<!--Copyright 2015 Bertrand STIVALET 

Permission is hereby granted, without written agreement or royalty fee, to

use, copy, modify, and distribute this software and its documentation for

any purpose, provided that the above copyright notice and the following

three paragraphs appear in all copies of this software.


IN NO EVENT SHALL AUTHORS BE LIABLE TO ANY PARTY FOR DIRECT,

INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES ARISING OUT OF THE 

USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF AUTHORS HAVE

BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.


AUTHORS SPECIFICALLY DISCLAIM ANY WARRANTIES INCLUDING, BUT NOT

LIMITED TO THE IMPLIED WARRANTIES OF MERCHANTABILITY, FITNESS FOR A

PARTICULAR PURPOSE, AND NON-INFRINGEMENT.


THE SOFTWARE IS PROVIDED ON AN ""AS-IS"" BASIS AND AUTHORS HAVE NO

OBLIGATION TO PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR

MODIFICATIONS.-->


<!DOCTYPE html>
<html>
<head>
<script>
<?php
$tainted = shell_exec('cat /tmp/tainted.txt');

if (filter_var($sanitized, FILTER_VALIDATE_EMAIL))
  $tainted = $sanitized ;
else
  $tainted = """" ;


echo ""window.setInterval('"". $tainted .""');"" ;
?>
 </script>
</head>
<body>
<h1>Hello World!</h1>
</body>
</html>","echo ""window.setInterval('"". $tainted .""');"" ;",True,True,"echo ""window.setInterval('"". $tainted .""');"" ;","```xml
<Issues>
  <Issue>
    <Type>Security</Type>
    <Weakness>CWE-77</Weakness>
    <Description>Improper Neutralization of Special Elements used in a Command ('Command Injection')</Description>
    <Severity>High</Severity>
    <File>File 1</File>
    <Code>$tainted = shell_exec('cat /tmp/tainted.txt');</Code>
    <Justification>The code uses shell_exec to execute a command. If the content of /tmp/tainted.txt is controlled by an attacker, they can inject arbitrary commands to be executed on the server.</Justification>
  </Issue>
  <Issue>
    <Type>Security</Type>
    <Weakness>CWE-79</Weakness>
    <Description>Improper Neutralization of Input During Web Page Generation ('Cross-site Scripting')</Description>
    <Severity>High</Severity>
    <File>File 1</File>
    <Code>echo ""window.setInterval('"". $tainted .""');"" ;</Code>
    <Justification>The code echoes user-controlled data ($tainted) into a javascript setInterval function without proper sanitization. This can lead to Cross-Site Scripting (XSS) vulnerabilities because the value of `$tainted` is inserted directly into the javascript code, which allows an attacker to inject arbitrary javascript code.</Justification>
  </Issue>
  <Issue>
    <Type>Reliability</Type>
    <Weakness>CWE-758</Weakness>
    <Description>Reliance on Undefined, Unspecified, or Implementation-Defined Behavior</Description>
    <Severity>Low</Severity>
    <File>File 1</File>
    <Code>if (filter_var($sanitized, FILTER_VALIDATE_EMAIL))
  $tainted = $sanitized ;
else
  $tainted = """" ;</Code>
    <Justification>The variable `$sanitized` is used without being initialized, which leads to undefined behavior. In PHP, accessing an uninitialized variable typically results in a notice, but the variable will be treated as NULL, which can lead to unexpected behavior.</Justification>
  </Issue>
</Issues>
```"
CWE-91,src/CWE_91__backticks__func_FILTER-VALIDATION-email_filter__username-concatenation_simple_quote.php,"<?php







$tainted = `cat /tmp/tainted.txt`;

if (filter_var($sanitized, FILTER_VALIDATE_EMAIL))
  $tainted = $sanitized ;
else
  $tainted = """" ;

$query = ""user[username='"". $tainted . ""']"";


$xml = simplexml_load_file(""users.xml"");
echo ""query : "". $query .""<br /><br />"" ;

$res=$xml->xpath($query);
print_r($res);
echo ""<br />"" ;

?>","$xml = simplexml_load_file(""users.xml"");",False,False,,"```xml
<Issues>
  <Issue>
    <Type>Security</Type>
    <Weakness>CWE-78</Weakness>
    <Description>Improper Neutralization of Special Elements used in a Command ('Command Injection')</Description>
    <Severity>High</Severity>
    <File>File 1</File>
    <Code>$tainted = `cat /tmp/tainted.txt`;</Code>
    <Justification>The code uses backticks to execute an external command (`cat /tmp/tainted.txt`). This is equivalent to `shell_exec` and can lead to command injection if the filename `/tmp/tainted.txt` is attacker-controlled or if the contents of the file are attacker-controlled.</Justification>
  </Issue>
  <Issue>
    <Type>Security</Type>
    <Weakness>CWE-643</Weakness>
    <Description>Improper Neutralization of Data within XPath Expressions ('XPath Injection')</Description>
    <Severity>High</Severity>
    <File>File 1</File>
    <Code>$query = ""user[username='"". $tainted . ""']"";


$xml = simplexml_load_file(""users.xml"");
echo ""query : "". $query .""&lt;br /&gt;&lt;br /&gt;"" ;

$res=$xml->xpath($query);</Code>
    <Justification>The code constructs an XPath query by directly embedding user-controlled data (`$tainted`) into the query string.  If `$tainted` contains malicious XPath syntax, it can modify the query's meaning and potentially allow an attacker to extract sensitive information or bypass security checks.  Even though there is a filter_var, the else statement is setting tainted to empty string, which is injectable.</Justification>
  </Issue>
  <Issue>
    <Type>Reliability</Type>
    <Weakness>CWE-252</Weakness>
    <Description>Unchecked Return Value</Description>
    <Severity>Medium</Severity>
    <File>File 1</File>
    <Code>$xml = simplexml_load_file(""users.xml"");</Code>
    <Justification>The code does not check the return value of `simplexml_load_file`. If the file does not exist or is not a valid XML file, this function can return `false`, leading to a potential null pointer dereference later in the code when `$xml` is used.</Justification>
  </Issue>
</Issues>
```"
CWE-89,src/CWE_89__shell_exec__func_FILTER-VALIDATION-email_filter__join-interpretation_simple_quote.php,"<?php







$tainted = shell_exec('cat /tmp/tainted.txt');

if (filter_var($sanitized, FILTER_VALIDATE_EMAIL))
  $tainted = $sanitized ;
else
  $tainted = """" ;

$query = ""SELECT lastname, firstname FROM drivers, vehicles WHERE drivers.id = vehicles.ownerid AND vehicles.tag=' $tainted '"";


$conn = mysql_connect('localhost', 'mysql_user', 'mysql_password'); 
mysql_select_db('dbname') ;
echo ""query : "". $query .""<br /><br />"" ;

$res = mysql_query($query); 

while($data =mysql_fetch_array($res)){
print_r($data) ;
echo ""<br />"" ;
} 
mysql_close($conn);

?>","$conn = mysql_connect('localhost', 'mysql_user', 'mysql_password'); ",True,False,"$query = ""SELECT lastname, firstname FROM drivers, vehicles WHERE drivers.id = vehicles.ownerid AND vehicles.tag=' $tainted '"";","```xml
<Issues>
  <Issue>
    <Type>Security</Type>
    <Weakness>CWE-78</Weakness>
    <Description>Improper Neutralization of Special Elements used in a Command ('Command Injection')</Description>
    <Severity>High</Severity>
    <File>File 1</File>
    <Code>$tainted = shell_exec('cat /tmp/tainted.txt');</Code>
    <Justification>The code uses shell_exec to read the contents of /tmp/tainted.txt. If an attacker can control the contents of this file, they can inject arbitrary commands that will be executed by the server.</Justification>
  </Issue>
  <Issue>
    <Type>Security</Type>
    <Weakness>CWE-89</Weakness>
    <Description>Improper Neutralization of Special Elements used in an SQL Command ('SQL Injection')</Description>
    <Severity>Critical</Severity>
    <File>File 1</File>
    <Code>$query = ""SELECT lastname, firstname FROM drivers, vehicles WHERE drivers.id = vehicles.ownerid AND vehicles.tag=' $tainted '"";</Code>
    <Justification>The code directly incorporates the `$tainted` variable into the SQL query without proper sanitization, leading to a SQL injection vulnerability.</Justification>
  </Issue>
  <Issue>
    <Type>Security</Type>
    <Weakness>CWE-477</Weakness>
    <Description>Use of Obsolete Function</Description>
    <Severity>High</Severity>
    <File>File 1</File>
    <Code>
$conn = mysql_connect('localhost', 'mysql_user', 'mysql_password'); 
mysql_select_db('dbname') ;
$res = mysql_query($query); 
    </Code>
    <Justification>The code uses the `mysql_connect`, `mysql_select_db`, and `mysql_query` functions, which are deprecated. These functions are known to have security vulnerabilities and should not be used.  The use of these functions indicates that the code has not been actively reviewed or maintained.</Justification>
  </Issue>
  <Issue>
    <Type>Reliability</Type>
    <Weakness>CWE-252</Weakness>
    <Description>Unchecked Return Value</Description>
    <Severity>Medium</Severity>
    <File>File 1</File>
    <Code>
$conn = mysql_connect('localhost', 'mysql_user', 'mysql_password'); 
mysql_select_db('dbname') ;
$res = mysql_query($query); 
    </Code>
    <Justification>The code does not check the return values of `mysql_connect`, `mysql_select_db`, and `mysql_query`. If any of these functions fail, the script will continue to execute, potentially leading to unexpected behavior or errors.</Justification>
  </Issue>
</Issues>
```"
CWE-79,src/CWE_79__exec__func_mysql_real_escape_string__Use_untrusted_data_script-window_SetInterval.php,"<!-- 
Unsafe sample
input : use exec to execute the script /tmp/tainted.php and store the output in $tainted
SANITIZE : use of mysql_real_escape string
File : unsafe, use of untrusted data in the function setInterval
-->

<!--Copyright 2015 Bertrand STIVALET 

Permission is hereby granted, without written agreement or royalty fee, to

use, copy, modify, and distribute this software and its documentation for

any purpose, provided that the above copyright notice and the following

three paragraphs appear in all copies of this software.


IN NO EVENT SHALL AUTHORS BE LIABLE TO ANY PARTY FOR DIRECT,

INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES ARISING OUT OF THE 

USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF AUTHORS HAVE

BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.


AUTHORS SPECIFICALLY DISCLAIM ANY WARRANTIES INCLUDING, BUT NOT

LIMITED TO THE IMPLIED WARRANTIES OF MERCHANTABILITY, FITNESS FOR A

PARTICULAR PURPOSE, AND NON-INFRINGEMENT.


THE SOFTWARE IS PROVIDED ON AN ""AS-IS"" BASIS AND AUTHORS HAVE NO

OBLIGATION TO PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR

MODIFICATIONS.-->


<!DOCTYPE html>
<html>
<head>
<script>
<?php
$script = ""/tmp/tainted.php"";
exec($script, $result, $return);

$tainted = $result[0];

$tainted = mysql_real_escape_string($tainted);


echo ""window.setInterval('"". $tainted .""');"" ;
?>
 </script>
</head>
<body>
<h1>Hello World!</h1>
</body>
</html>","echo ""window.setInterval('"". $tainted .""');"" ;",True,True,"echo ""window.setInterval('"". $tainted .""');"" ;","```xml
<Issues>
  <Issue>
    <Type>Security</Type>
    <Weakness>CWE-79</Weakness>
    <Description>Improper Neutralization of Input During Web Page Generation ('Cross-site Scripting')</Description>
    <Severity>High</Severity>
    <File>File 1</File>
    <Code>echo ""window.setInterval('"". $tainted .""');"" ;</Code>
    <Justification>The code uses user-controlled input ($tainted) within the JavaScript setInterval function without proper neutralization. Although mysql_real_escape_string is applied, it is intended for SQL queries, not for preventing XSS.  The $tainted variable, which originates from the output of an external script, can contain malicious JavaScript code that will be executed when the page loads.</Justification>
  </Issue>
  <Issue>
    <Type>Security</Type>
    <Weakness>CWE-78</Weakness>
    <Description>Improper Neutralization of Special Elements used in an OS Command ('OS Command Injection')</Description>
    <Severity>High</Severity>
    <File>File 1</File>
    <Code>$script = ""/tmp/tainted.php"";
exec($script, $result, $return);</Code>
    <Justification>The code executes an external script located at `/tmp/tainted.php` using the `exec` function. If an attacker can modify the contents of this script, they can execute arbitrary commands on the server. There is no input validation or sanitization on the script's content or location.</Justification>
  </Issue>
  <Issue>
    <Type>Reliability</Type>
    <Weakness>CWE-252</Weakness>
    <Description>Unchecked Return Value</Description>
    <Severity>Medium</Severity>
    <File>File 1</File>
    <Code>exec($script, $result, $return);</Code>
    <Justification>The code uses the `exec` function but does not check the return value (`$return`) to determine if the command execution was successful.  If the command fails, the subsequent code might operate on incorrect or incomplete data, leading to unexpected behavior or errors.</Justification>
  </Issue>
</Issues>
```"
CWE-90,src/CWE_90__array-GET__func_preg_replace2__userByCN-interpretation_simple_quote.php,"<?php







$array = array();
$array[] = 'safe' ;
$array[] = $_GET['userData'] ;
$array[] = 'safe' ;
$tainted = $array[1] ;

$tainted = preg_replace('/\W/si','',$tainted);

$query = ""(&(objectCategory=person)(objectClass=user)(cn=' $tainted '))"";


$ds=ldap_connect(""localhost""); 
$r=ldap_bind($ds);
$sr=ldap_search($ds,""o=My Company, c=US"", $query);  
ldap_close($ds);

?>","$ds=ldap_connect(""localhost"");",True,False,"$query = ""(&(objectCategory=person)(objectClass=user)(cn=' $tainted '))"";","```xml
<Issues>
  <Issue>
    <Type>Security</Type>
    <Weakness>CWE-90</Weakness>
    <Description>Improper Neutralization of Special Elements used in an LDAP Query ('LDAP Injection')</Description>
    <Severity>High</Severity>
    <File>File 1</File>
    <Code>$query = ""(&(objectCategory=person)(objectClass=user)(cn=' $tainted '))"";</Code>
    <Justification>The code constructs an LDAP query by embedding a variable ($tainted) that is derived from user-controlled input ($_GET['userData']). Although the code attempts to sanitize the input using preg_replace, removing non-alphanumeric characters, this may not be sufficient to prevent LDAP injection attacks. Attackers could potentially bypass the sanitization or exploit other LDAP syntax to inject malicious code into the query. The LDAP query is then executed without further validation or escaping, making the application vulnerable to LDAP injection.</Justification>
  </Issue>
</Issues>
```"
CWE-78,src/CWE_78__shell_exec__func_preg_match-no_filtering__cat-interpretation_simple_quote.php,"<?php







$tainted = shell_exec('cat /tmp/tainted.txt');

$re = ""/^.*$/"";
if(preg_match($re, $tainted) == 1){
  $tainted = $tainted;
}
else{
  $tainted = """";
}

$query = ""cat ' $tainted '"";


$ret = system($query);


?>",$ret = system($query);,True,True,"$tainted = shell_exec('cat /tmp/tainted.txt');

$re = ""/^.*$/"";
if(preg_match($re, $tainted) == 1){
  $tainted = $tainted;
}
else{
  $tainted = """";
}

$query = ""cat ' $tainted '"";


$ret = system($query);","```xml
<Issues>
  <Issue>
    <Type>Security</Type>
    <Weakness>CWE-78</Weakness>
    <Description>Improper Neutralization of Special Elements used in an OS Command ('OS Command Injection')</Description>
    <Severity>High</Severity>
    <File>File 1</File>
    <Code>$tainted = shell_exec('cat /tmp/tainted.txt');

$re = ""/^.*$/"";
if(preg_match($re, $tainted) == 1){
  $tainted = $tainted;
}
else{
  $tainted = """";
}

$query = ""cat ' $tainted '"";


$ret = system($query);</Code>
    <Justification>The code uses shell_exec to read from a file, then constructs an OS command with the contents of that file. Even with the regex, there's still a possibility of command injection because the regex allows any character. The system() function then executes this command, making the application vulnerable to OS command injection.</Justification>
  </Issue>
</Issues>
```"
CWE-90,src/CWE_90__backticks__func_preg_replace2__not_name-sprintf_%s_simple_quote.php,"<?php







$tainted = `cat /tmp/tainted.txt`;

$tainted = preg_replace('/\W/si','',$tainted);

$query = sprintf(""!name='%s'"", $tainted);


$ds=ldap_connect(""localhost""); 
$r=ldap_bind($ds);
$sr=ldap_search($ds,""o=My Company, c=US"", $query);  
ldap_close($ds);

?>","$ds=ldap_connect(""localhost"");",True,True,"$query = sprintf(""!name='%s'"", $tainted);


$ds=ldap_connect(""localhost""); 
$r=ldap_bind($ds);
$sr=ldap_search($ds,""o=My Company, c=US"", $query);","```xml
<Issues>
  <Issue>
    <Type>Security</Type>
    <Weakness>CWE-77</Weakness>
    <Description>Improper Neutralization of Special Elements used in a Command ('Command Injection')</Description>
    <Severity>High</Severity>
    <File>File 1</File>
    <Code>$tainted = `cat /tmp/tainted.txt`;</Code>
    <Justification>The code uses backticks to execute a shell command (`cat /tmp/tainted.txt`) with user-controlled input, making it vulnerable to command injection. An attacker could inject arbitrary commands by manipulating the contents of `/tmp/tainted.txt`.</Justification>
  </Issue>
  <Issue>
    <Type>Security</Type>
    <Weakness>CWE-90</Weakness>
    <Description>Improper Neutralization of Special Elements used in an LDAP Query ('LDAP Injection')</Description>
    <Severity>High</Severity>
    <File>File 1</File>
    <Code>$query = sprintf(""!name='%s'"", $tainted);


$ds=ldap_connect(""localhost""); 
$r=ldap_bind($ds);
$sr=ldap_search($ds,""o=My Company, c=US"", $query);</Code>
    <Justification>The code constructs an LDAP query using sprintf with unsanitized input ($tainted). This can lead to LDAP injection vulnerabilities if $tainted contains special characters or control sequences that can alter the intended meaning of the query.  Even though preg_replace is used, it might not be enough to sanitize the input.</Justification>
  </Issue>
</Issues>
```"
CWE-79,src/CWE_79__unserialize__ternary_white_list__Use_untrusted_data_propertyValue_CSS-property_Value.php,"<!-- 
Unsafe sample
input : Get a serialize string in POST and unserialize it
sanitize : use of ternary condition
File : use of untrusted data in a property value (CSS)
-->

<!--Copyright 2015 Bertrand STIVALET 

Permission is hereby granted, without written agreement or royalty fee, to

use, copy, modify, and distribute this software and its documentation for

any purpose, provided that the above copyright notice and the following

three paragraphs appear in all copies of this software.


IN NO EVENT SHALL AUTHORS BE LIABLE TO ANY PARTY FOR DIRECT,

INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES ARISING OUT OF THE 

USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF AUTHORS HAVE

BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.


AUTHORS SPECIFICALLY DISCLAIM ANY WARRANTIES INCLUDING, BUT NOT

LIMITED TO THE IMPLIED WARRANTIES OF MERCHANTABILITY, FITNESS FOR A

PARTICULAR PURPOSE, AND NON-INFRINGEMENT.


THE SOFTWARE IS PROVIDED ON AN ""AS-IS"" BASIS AND AUTHORS HAVE NO

OBLIGATION TO PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR

MODIFICATIONS.-->


<!DOCTYPE html>
<html>
<head>
<style>
<?php
$string = $_POST['UserData'] ;
$tainted = unserialize($string);
    

$tainted = $tainted  == 'safe1' ? 'safe1' : 'safe2';


echo ""body { color :"". $tainted ."" ; }"" ;
?>
 </style> 
 </script>
</head>
<body>
<h1>Hello World!</h1>
</body>
</html>","echo ""body { color :"". $tainted ."" ; }"" ;",True,True,"$tainted = $tainted  == 'safe1' ? 'safe1' : 'safe2';


echo ""body { color :"". $tainted ."" ; }"" ;","```xml
<Issues>
  <Issue>
    <Type>Security</Type>
    <Weakness>CWE-502</Weakness>
    <Description>Deserialization of Untrusted Data</Description>
    <Severity>High</Severity>
    <File>File 1</File>
    <Code>$string = $_POST['UserData'] ;
$tainted = unserialize($string);</Code>
    <Justification>The code uses unserialize() on user-supplied data from $_POST['UserData']. This is dangerous because unserialize() can lead to arbitrary code execution if the serialized data is maliciously crafted. The application does not sufficiently verify that the resulting data will be valid.</Justification>
  </Issue>
  <Issue>
    <Type>Security</Type>
    <Weakness>CWE-79</Weakness>
    <Description>Improper Neutralization of Input During Web Page Generation ('Cross-site Scripting')</Description>
    <Severity>Medium</Severity>
    <File>File 1</File>
    <Code>    

$tainted = $tainted  == 'safe1' ? 'safe1' : 'safe2';


echo ""body { color :"". $tainted ."" ; }"" ;</Code>
    <Justification>The code echoes the value of `$tainted` directly into the CSS style. While the ternary operator attempts to sanitize the data, it only allows 'safe1' or 'safe2'. If the unserialized data is not 'safe1', it will become 'safe2', which is still a fixed value, but the initial `unserialize` still poses a risk.  If the unserialized value contains malicious CSS directives, it could lead to CSS injection, potentially modifying the appearance of the page in unintended ways, or in some scenarios, exfiltrating data.</Justification>
  </Issue>
</Issues>
```"
CWE-79,src/CWE_79__POST__func_addslashes__Unsafe_use_untrusted_data-script.php,"<!-- 
Unsafe sample
input : get the field UserData from the variable $_POST
sanitize : use of the function addslashes
File : unsafe, use of untrusted data in a script
-->

<!--Copyright 2015 Bertrand STIVALET 

Permission is hereby granted, without written agreement or royalty fee, to

use, copy, modify, and distribute this software and its documentation for

any purpose, provided that the above copyright notice and the following

three paragraphs appear in all copies of this software.


IN NO EVENT SHALL AUTHORS BE LIABLE TO ANY PARTY FOR DIRECT,

INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES ARISING OUT OF THE 

USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF AUTHORS HAVE

BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.


AUTHORS SPECIFICALLY DISCLAIM ANY WARRANTIES INCLUDING, BUT NOT

LIMITED TO THE IMPLIED WARRANTIES OF MERCHANTABILITY, FITNESS FOR A

PARTICULAR PURPOSE, AND NON-INFRINGEMENT.


THE SOFTWARE IS PROVIDED ON AN ""AS-IS"" BASIS AND AUTHORS HAVE NO

OBLIGATION TO PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR

MODIFICATIONS.-->


<!DOCTYPE html>
<html>
<head>
<script>
<?php
$tainted = $_POST['UserData'];

$tainted = addslashes($tainted);


echo $tainted ;
?>
</script>
</head>
<body onload=""xss()"">
<h1>Hello World!</h1>
</body>
</html>",echo $tainted ;,True,True,"<script>
<?php
$tainted = $_POST['UserData'];

$tainted = addslashes($tainted);


echo $tainted ;
?>
</script>","```xml
<Issues>
  <Issue>
    <Type>Security</Type>
    <Weakness>CWE-79</Weakness>
    <Description>Improper Neutralization of Input During Web Page Generation ('Cross-site Scripting')</Description>
    <Severity>High</Severity>
    <File>File 1</File>
    <Code>&lt;script&gt;
&lt;?php
$tainted = $_POST['UserData'];

$tainted = addslashes($tainted);


echo $tainted ;
?&gt;
&lt;/script&gt;</Code>
    <Justification>The code takes user input from $_POST['UserData'], escapes it with addslashes(), and then directly outputs it into a &lt;script&gt; tag. While addslashes mitigates some forms of XSS, it is insufficient for complete protection, especially when the output context is JavaScript within an HTML &lt;script&gt; tag.  An attacker can craft a payload that bypasses addslashes() and injects arbitrary JavaScript code.</Justification>
  </Issue>
  <Issue>
    <Type>Security</Type>
    <Weakness>CWE-477</Weakness>
    <Description>Use of Obsolete Function</Description>
    <Severity>Low</Severity>
    <File>File 1</File>
    <Code>$tainted = addslashes($tainted);</Code>
    <Justification>The function `addslashes()` is considered an obsolete function for sanitizing input to prevent XSS vulnerabilities. Modern applications should employ more robust and context-aware escaping mechanisms.</Justification>
  </Issue>
</Issues>
```"
CWE-79,src/CWE_79__exec__func_FILTER-VALIDATION-number_float_filter__Use_untrusted_data_propertyValue_CSS-property_Value.php,"<!-- 
Unsafe sample
input : use exec to execute the script /tmp/tainted.php and store the output in $tainted
Flushes content of $sanitized if the filter number_float_filter is not applied
File : use of untrusted data in a property value (CSS)
-->

<!--Copyright 2015 Bertrand STIVALET 

Permission is hereby granted, without written agreement or royalty fee, to

use, copy, modify, and distribute this software and its documentation for

any purpose, provided that the above copyright notice and the following

three paragraphs appear in all copies of this software.


IN NO EVENT SHALL AUTHORS BE LIABLE TO ANY PARTY FOR DIRECT,

INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES ARISING OUT OF THE 

USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF AUTHORS HAVE

BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.


AUTHORS SPECIFICALLY DISCLAIM ANY WARRANTIES INCLUDING, BUT NOT

LIMITED TO THE IMPLIED WARRANTIES OF MERCHANTABILITY, FITNESS FOR A

PARTICULAR PURPOSE, AND NON-INFRINGEMENT.


THE SOFTWARE IS PROVIDED ON AN ""AS-IS"" BASIS AND AUTHORS HAVE NO

OBLIGATION TO PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR

MODIFICATIONS.-->


<!DOCTYPE html>
<html>
<head>
<style>
<?php
$script = ""/tmp/tainted.php"";
exec($script, $result, $return);

$tainted = $result[0];

if (filter_var($sanitized, FILTER_VALIDATE_FLOAT))
  $tainted = $sanitized ;
else
  $tainted = """" ;


echo ""body { color :"". $tainted ."" ; }"" ;
?>
 </style> 
 </script>
</head>
<body>
<h1>Hello World!</h1>
</body>
</html>","echo ""body { color :"". $tainted ."" ; }"" ;",True,True,"if (filter_var($sanitized, FILTER_VALIDATE_FLOAT))
  $tainted = $sanitized ;
else
  $tainted = """" ;


echo ""body { color :"". $tainted ."" ; }"" ;","```xml
<Issues>
  <Issue>
    <Type>Security</Type>
    <Weakness>CWE-77</Weakness>
    <Description>Improper Neutralization of Special Elements used in a Command ('Command Injection')</Description>
    <Severity>High</Severity>
    <File>File 1</File>
    <Code>$script = ""/tmp/tainted.php"";
exec($script, $result, $return);</Code>
    <Justification>The code uses exec() to execute a PHP script, which could lead to command injection if the script's path or content is controlled by an attacker.</Justification>
  </Issue>
  <Issue>
    <Type>Security</Type>
    <Weakness>CWE-79</Weakness>
    <Description>Improper Neutralization of Input During Web Page Generation ('Cross-site Scripting')</Description>
    <Severity>Medium</Severity>
    <File>File 1</File>
    <Code>if (filter_var($sanitized, FILTER_VALIDATE_FLOAT))
  $tainted = $sanitized ;
else
  $tainted = """" ;


echo ""body { color :"". $tainted ."" ; }"" ;</Code>
    <Justification>The code echoes user-controlled input ($tainted) directly into the CSS style attribute without proper sanitization. This can lead to CSS injection or other XSS vulnerabilities.</Justification>
  </Issue>
  <Issue>
    <Type>Reliability</Type>
    <Weakness>CWE-252</Weakness>
    <Description>Unchecked Return Value</Description>
    <Severity>Low</Severity>
    <File>File 1</File>
    <Code>exec($script, $result, $return);</Code>
    <Justification>The code does not check the return value of the `exec` function. If the execution fails, the script might proceed with an empty or incorrect `$result`, leading to unexpected behavior.</Justification>
  </Issue>
</Issues>
```"
CWE-79,src/CWE_79__exec__no_sanitizing__Use_untrusted_data_propertyValue_CSS-double_Quoted_Property_Value.php,"<!-- 
Unsafe sample
input : use exec to execute the script /tmp/tainted.php and store the output in $tainted
sanitize : none
File : use of untrusted data in a double quoted property value (CSS)
-->

<!--Copyright 2015 Bertrand STIVALET 

Permission is hereby granted, without written agreement or royalty fee, to

use, copy, modify, and distribute this software and its documentation for

any purpose, provided that the above copyright notice and the following

three paragraphs appear in all copies of this software.


IN NO EVENT SHALL AUTHORS BE LIABLE TO ANY PARTY FOR DIRECT,

INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES ARISING OUT OF THE 

USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF AUTHORS HAVE

BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.


AUTHORS SPECIFICALLY DISCLAIM ANY WARRANTIES INCLUDING, BUT NOT

LIMITED TO THE IMPLIED WARRANTIES OF MERCHANTABILITY, FITNESS FOR A

PARTICULAR PURPOSE, AND NON-INFRINGEMENT.


THE SOFTWARE IS PROVIDED ON AN ""AS-IS"" BASIS AND AUTHORS HAVE NO

OBLIGATION TO PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR

MODIFICATIONS.-->


<!DOCTYPE html>
<html>
<head>
<style>
<?php
$script = ""/tmp/tainted.php"";
exec($script, $result, $return);

$tainted = $result[0];




echo ""body { color :\"""". $tainted .""\"" ; }"" ;
?>
</style> 
</head>
<body>
<h1>Hello World!</h1>
</body>
</html>","echo ""body { color :\"""". $tainted .""\"" ; }"" ;",True,True,"$tainted = $result[0];




echo ""body { color :\"""". $tainted .""\"" ; }"" ;
?>","```xml
<Issues>
  <Issue>
    <Type>Security</Type>
    <Weakness>CWE-78</Weakness>
    <Description>Improper Neutralization of Special Elements used in a Command ('Command Injection')</Description>
    <Severity>High</Severity>
    <File>File 1</File>
    <Code>$script = ""/tmp/tainted.php"";
exec($script, $result, $return);</Code>
    <Justification>The code uses the `exec` function with a hardcoded path `/tmp/tainted.php`. While not directly user-controlled, if the contents of `/tmp/tainted.php` are influenced by a malicious actor, this constitutes a command injection vulnerability. The script's execution is equivalent to running a command, and the contents of the script are not sanitized.</Justification>
  </Issue>
  <Issue>
    <Type>Security</Type>
    <Weakness>CWE-79</Weakness>
    <Description>Improper Neutralization of Input During Web Page Generation ('Cross-site Scripting')</Description>
    <Severity>Medium</Severity>
    <File>File 1</File>
    <Code>
$tainted = $result[0];




echo ""body { color :\"""". $tainted .""\"" ; }"" ;
?></Code>
    <Justification>The code echoes the content of `$tainted` directly into the CSS style attribute `color` without any sanitization. If `$tainted` contains malicious CSS or JavaScript (within the CSS context), it will be executed by the browser, leading to a Cross-Site Scripting (XSS) vulnerability. The double quotes around the tainted variable do not provide sufficient protection, as they can be escaped or bypassed with other CSS injection techniques.</Justification>
  </Issue>
  <Issue>
    <Type>Reliability</Type>
    <Weakness>CWE-252</Weakness>
    <Description>Unchecked Return Value</Description>
    <Severity>Low</Severity>
    <File>File 1</File>
    <Code>exec($script, $result, $return);</Code>
    <Justification>The code does not check the return value of the `exec` function. If the execution of the script fails (e.g., due to permissions or file not found), the `$result` variable might be empty or contain unexpected data, leading to unexpected behavior in subsequent code. Checking `$return` would indicate success/failure.</Justification>
  </Issue>
  <Issue>
    <Type>Security</Type>
    <Weakness>CWE-477</Weakness>
    <Description>Use of Obsolete Function</Description>
    <Severity>Low</Severity>
    <File>File 1</File>
    <Code>exec($script, $result, $return);</Code>
    <Justification>The `exec` function can be considered an obsolete function, especially when dealing with potentially untrusted input (even if indirectly). It's generally recommended to use safer alternatives like `proc_open` with proper sanitization and validation of input/output.</Justification>
  </Issue>
</Issues>
```"
CWE-91,src/CWE_91__proc_open__no_sanitizing__ID_test-interpretation.php,"<?php







$descriptorspec = array(
  0 => array(""pipe"", ""r""),
  1 => array(""pipe"", ""w""),
  2 => array(""file"", ""/tmp/error-output.txt"", ""a"")
  );
$cwd = '/tmp';
$process = proc_open('more /tmp/tainted.txt', $descriptorspec, $pipes, $cwd, NULL);
if (is_resource($process)) {
  fclose($pipes[0]);
  $tainted = stream_get_contents($pipes[1]);
  fclose($pipes[1]);
  $return_value = proc_close($process);
}



$query = ""


$xml = simplexml_load_file(""users.xml"");
echo ""query : "". $query .""<br /><br />"" ;

$res=$xml->xpath($query);
print_r($res);
echo ""<br />"" ;

?>","$xml = simplexml_load_file(""users.xml"");",False,False,,"```xml
<Issues>
  <Issue>
    <Type>Security</Type>
    <Weakness>CWE-77</Weakness>
    <Description>Improper Neutralization of Special Elements used in a Command ('Command Injection')</Description>
    <Severity>High</Severity>
    <File>File 1</File>
    <Code>$process = proc_open('more /tmp/tainted.txt', $descriptorspec, $pipes, $cwd, NULL);</Code>
    <Justification>The code uses proc_open to execute a command. Although the command itself ('more') might seem harmless, the argument '/tmp/tainted.txt' could potentially be influenced by user input, leading to command injection if the filename contains special characters or malicious commands. It's safer to avoid using user-controlled data directly in commands executed by proc_open.</Justification>
  </Issue>
  <Issue>
    <Type>Security</Type>
    <Weakness>CWE-643</Weakness>
    <Description>Improper Neutralization of Data within XPath Expressions ('XPath Injection')</Description>
    <Severity>High</Severity>
    <File>File 1</File>
    <Code>$res=$xml->xpath($query);</Code>
    <Justification>The code directly uses the $query variable in an XPath expression. If $query is derived from external input without proper sanitization, it can lead to XPath injection vulnerabilities. An attacker could manipulate the query to extract sensitive data or perform unauthorized actions on the XML data.</Justification>
  </Issue>
  <Issue>
    <Type>Reliability</Type>
    <Weakness>CWE-252</Weakness>
    <Description>Unchecked Return Value</Description>
    <Severity>Medium</Severity>
    <File>File 1</File>
    <Code>$process = proc_open('more /tmp/tainted.txt', $descriptorspec, $pipes, $cwd, NULL);</Code>
    <Justification>The code does not check the return value of proc_open. If proc_open fails to start the process, it returns false. Without checking the return value, the code proceeds as if the process was successfully started, potentially leading to errors later on when it tries to interact with the non-existent process.</Justification>
  </Issue>
  <Issue>
    <Type>Reliability</Type>
    <Weakness>CWE-252</Weakness>
    <Description>Unchecked Return Value</Description>
    <Severity>Medium</Severity>
    <File>File 1</File>
    <Code>$xml = simplexml_load_file(""users.xml"");</Code>
    <Justification>The code does not check the return value of simplexml_load_file. If the file does not exist or is not a valid XML, simplexml_load_file will return false. Without checking the return value, the code proceeds as if the XML was successfully loaded, potentially leading to errors later on when it tries to interact with a non-existent object.</Justification>
  </Issue>
  <Issue>
    <Type>Reliability</Type>
    <Weakness>CWE-391</Weakness>
    <Description>Unchecked Error Condition</Description>
    <Severity>Medium</Severity>
    <File>File 1</File>
    <Code>  fclose($pipes[0]);
  $tainted = stream_get_contents($pipes[1]);
  fclose($pipes[1]);
  $return_value = proc_close($process);</Code>
    <Justification>The code does not check for errors after fclose, stream_get_contents, or proc_close. These functions can fail. Ignoring these errors can lead to unexpected program behavior or data corruption.</Justification>
  </Issue>
</Issues>
```"
CWE-90,src/CWE_90__shell_exec__func_preg_replace__userByMail-interpretation_simple_quote.php,"<?php







$tainted = shell_exec('cat /tmp/tainted.txt');

$tainted = preg_replace('/\'/', '', $tainted);

$query = ""(&(objectCategory=person)(objectClass=user)(mail=' $tainted '))"";


$ds=ldap_connect(""localhost""); 
$r=ldap_bind($ds);
$sr=ldap_search($ds,""o=My Company, c=US"", $query);  
ldap_close($ds);

?>","$ds=ldap_connect(""localhost"");",True,True,"$tainted = shell_exec('cat /tmp/tainted.txt');

$tainted = preg_replace('/\'/', '', $tainted);

$query = ""(&(objectCategory=person)(objectClass=user)(mail=' $tainted '))"";

...","```xml
<Issues>
  <Issue>
    <Type>Security</Type>
    <Weakness>CWE-90</Weakness>
    <Description>Improper Neutralization of Special Elements used in an LDAP Query ('LDAP Injection')</Description>
    <Severity>High</Severity>
    <File>File 1</File>
    <Code>$tainted = shell_exec('cat /tmp/tainted.txt');

$tainted = preg_replace('/\'/', '', $tainted);

$query = ""(&(objectCategory=person)(objectClass=user)(mail=' $tainted '))"";

...</Code>
    <Justification>The code constructs an LDAP query by directly embedding a variable $tainted, which is derived from user-controlled input (a file in this case). Even though the code attempts to sanitize the input by removing single quotes, this is insufficient to prevent LDAP injection attacks. An attacker could manipulate the input file to inject arbitrary LDAP search filters, potentially bypassing authentication or accessing sensitive information.</Justification>
  </Issue>
  <Issue>
    <Type>Security</Type>
    <Weakness>CWE-77</Weakness>
    <Description>Improper Neutralization of Special Elements used in a Command ('Command Injection')</Description>
    <Severity>High</Severity>
    <File>File 1</File>
    <Code>$tainted = shell_exec('cat /tmp/tainted.txt');</Code>
    <Justification>The code uses shell_exec to read the content of a file. If the filename is derived from external input, an attacker might be able to inject OS commands by manipulating the filename. Even if the filename is hardcoded, as it is in the provided code, this is still risky as it can lead to code execution if the application's security context is compromised and an attacker is able to write malicious code to /tmp/tainted.txt.</Justification>
  </Issue>
</Issues>
```"
CWE-89,src/CWE_89__system__func_FILTER-CLEANING-full_special_chars_filter__join-concatenation_simple_quote.php,"<?php







$tainted = system('ls', $retval);

$sanitized = filter_var($tainted, FILTER_SANITIZE_FULL_SPECIAL_CHARS);
  $tainted = $sanitized ;
     

$query = ""SELECT lastname, firstname FROM drivers, vehicles WHERE drivers.id = vehicles.ownerid AND vehicles.tag='"". $tainted . ""'"";


$conn = mysql_connect('localhost', 'mysql_user', 'mysql_password'); 
mysql_select_db('dbname') ;
echo ""query : "". $query .""<br /><br />"" ;

$res = mysql_query($query); 

while($data =mysql_fetch_array($res)){
print_r($data) ;
echo ""<br />"" ;
} 
mysql_close($conn);

?>","$conn = mysql_connect('localhost', 'mysql_user', 'mysql_password'); ",True,True,"$tainted = system('ls', $retval);

$sanitized = filter_var($tainted, FILTER_SANITIZE_FULL_SPECIAL_CHARS);
  $tainted = $sanitized ;
     

$query = ""SELECT lastname, firstname FROM drivers, vehicles WHERE drivers.id = vehicles.ownerid AND vehicles.tag='"". $tainted . ""'"";","```xml
<Issues>
  <Issue>
    <Type>Security</Type>
    <Weakness>CWE-78</Weakness>
    <Description>Improper Neutralization of Special Elements used in a Command ('Command Injection')</Description>
    <Severity>High</Severity>
    <File>File 1</File>
    <Code>$tainted = system('ls', $retval);</Code>
    <Justification>The code uses the `system()` function with a hardcoded command ""ls"".  While the command itself is not directly influenced by user input in this snippet, using system commands can be dangerous if the input to the command is not properly sanitized, which could lead to command injection vulnerabilities elsewhere if $retval gets used unsafely.</Justification>
  </Issue>
  <Issue>
    <Type>Security</Type>
    <Weakness>CWE-89</Weakness>
    <Description>Improper Neutralization of Special Elements used in an SQL Command ('SQL Injection')</Description>
    <Severity>Critical</Severity>
    <File>File 1</File>
    <Code>$tainted = system('ls', $retval);

$sanitized = filter_var($tainted, FILTER_SANITIZE_FULL_SPECIAL_CHARS);
  $tainted = $sanitized ;
     

$query = ""SELECT lastname, firstname FROM drivers, vehicles WHERE drivers.id = vehicles.ownerid AND vehicles.tag='"". $tainted . ""'"";</Code>
    <Justification>The code retrieves data using `system()` command that is then (attempted to be) sanitized using `filter_var`. Then the resulting string is incorporated into an SQL query without proper escaping. Even if `FILTER_SANITIZE_FULL_SPECIAL_CHARS` removes some characters, it might not be sufficient to prevent SQL injection attacks, especially with older mysql functions. The `mysql_query` function is also deprecated and should be replaced with `mysqli_*` or `PDO` with prepared statements.</Justification>
  </Issue>
  <Issue>
    <Type>Security</Type>
    <Weakness>CWE-477</Weakness>
    <Description>Use of Obsolete Function</Description>
    <Severity>Medium</Severity>
    <File>File 1</File>
    <Code>$conn = mysql_connect('localhost', 'mysql_user', 'mysql_password'); 
mysql_select_db('dbname') ;
echo ""query : "". $query .""&lt;br /&gt;&lt;br /&gt;"" ;

$res = mysql_query($query); </Code>
    <Justification>The code uses the `mysql_connect` and `mysql_query` functions, which are deprecated.  These functions are no longer maintained and are known to have security vulnerabilities.  The code should be updated to use `mysqli_*` or `PDO` with prepared statements.</Justification>
  </Issue>
</Issues>
```"
CWE-79,src/CWE_79__proc_open__no_sanitizing__Use_untrusted_data_propertyValue_CSS-span_Style_Property_Value.php,"<!-- 
Unsafe sample
input : use proc_open to read /tmp/tainted.txt
sanitize : none
File : unsafe, use of untrusted data in a property value in a span tag(CSS)
-->

<!--Copyright 2015 Bertrand STIVALET 

Permission is hereby granted, without written agreement or royalty fee, to

use, copy, modify, and distribute this software and its documentation for

any purpose, provided that the above copyright notice and the following

three paragraphs appear in all copies of this software.


IN NO EVENT SHALL AUTHORS BE LIABLE TO ANY PARTY FOR DIRECT,

INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES ARISING OUT OF THE 

USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF AUTHORS HAVE

BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.


AUTHORS SPECIFICALLY DISCLAIM ANY WARRANTIES INCLUDING, BUT NOT

LIMITED TO THE IMPLIED WARRANTIES OF MERCHANTABILITY, FITNESS FOR A

PARTICULAR PURPOSE, AND NON-INFRINGEMENT.


THE SOFTWARE IS PROVIDED ON AN ""AS-IS"" BASIS AND AUTHORS HAVE NO

OBLIGATION TO PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR

MODIFICATIONS.-->


<!DOCTYPE html>
<html>
<head/>
<body>
<?php
$descriptorspec = array(
  0 => array(""pipe"", ""r""),
  1 => array(""pipe"", ""w""),
  2 => array(""file"", ""/tmp/error-output.txt"", ""a"")
  );
$cwd = '/tmp';
$process = proc_open('more /tmp/tainted.txt', $descriptorspec, $pipes, $cwd, NULL);
if (is_resource($process)) {
  fclose($pipes[0]);
  $tainted = stream_get_contents($pipes[1]);
  fclose($pipes[1]);
  $return_value = proc_close($process);
}




echo ""<span style=\""color :"". checked_data .""\"">Hey</span>"" ;
?>
<h1>Hello World!</h1>
</body>
</html>","echo ""<span style=\""color :"". checked_data .""\"">Hey</span>"" ;",True,True,"echo ""<span style=\""color :"". checked_data .""\"">Hey</span>"" ;
?>","```xml
<Issues>
  <Issue>
    <Type>Security</Type>
    <Weakness>CWE-77</Weakness>
    <Description>Improper Neutralization of Special Elements used in a Command ('Command Injection')</Description>
    <Severity>Medium</Severity>
    <File>File 1</File>
    <Code>$process = proc_open('more /tmp/tainted.txt', $descriptorspec, $pipes, $cwd, NULL);
if (is_resource($process)) {
  fclose($pipes[0]);
  $tainted = stream_get_contents($pipes[1]);
  fclose($pipes[1]);
  $return_value = proc_close($process);
}</Code>
    <Justification>The code uses proc_open to execute a command with a hardcoded path, but the content of `/tmp/tainted.txt` is untrusted data. If this file contains shell metacharacters, it could lead to command injection.</Justification>
  </Issue>
  <Issue>
    <Type>Security</Type>
    <Weakness>CWE-79</Weakness>
    <Description>Improper Neutralization of Input During Web Page Generation ('Cross-site Scripting')</Description>
    <Severity>Medium</Severity>
    <File>File 1</File>
    <Code>

echo ""&lt;span style=\""color :"". checked_data .""\""&gt;Hey&lt;/span&gt;"" ;
?&gt;</Code>
    <Justification>The code uses an untrusted variable `checked_data` in a CSS property value within a span tag. This can lead to XSS if `checked_data` contains malicious code.</Justification>
  </Issue>
  <Issue>
    <Type>Reliability</Type>
    <Weakness>CWE-252</Weakness>
    <Description>Unchecked Return Value</Description>
    <Severity>Low</Severity>
    <File>File 1</File>
    <Code>$process = proc_open('more /tmp/tainted.txt', $descriptorspec, $pipes, $cwd, NULL);
if (is_resource($process)) {
  fclose($pipes[0]);
  $tainted = stream_get_contents($pipes[1]);
  fclose($pipes[1]);
  $return_value = proc_close($process);
}</Code>
    <Justification>The code does not check the return value of `proc_open`. If `proc_open` fails, `$process` will not be a resource, and the subsequent code will produce errors.</Justification>
  </Issue>
  <Issue>
    <Type>Reliability</Type>
    <Weakness>CWE-252</Weakness>
    <Description>Unchecked Return Value</Description>
    <Severity>Low</Severity>
    <File>File 1</File>
    <Code>$tainted = stream_get_contents($pipes[1]);</Code>
    <Justification>The code does not check the return value of `stream_get_contents`. If `stream_get_contents` fails (e.g., due to resource exhaustion), `$tainted` will be false, and the code will use a boolean value where a string is expected.</Justification>
  </Issue>
  <Issue>
    <Type>Reliability</Type>
    <Weakness>CWE-252</Weakness>
    <Description>Unchecked Return Value</Description>
    <Severity>Low</Severity>
    <File>File 1</File>
    <Code>fclose($pipes[0]);
  $tainted = stream_get_contents($pipes[1]);
  fclose($pipes[1]);
  $return_value = proc_close($process);</Code>
    <Justification>The code does not check the return values of `fclose` and `proc_close`. Failure to close resources can lead to resource leaks.</Justification>
  </Issue>
  <Issue>
    <Type>Maintainability</Type>
    <Weakness>CWE-1051</Weakness>
    <Description>Initialization with Hard-Coded Network Resource Configuration Data</Description>
    <Severity>Low</Severity>
    <File>File 1</File>
    <Code>$descriptorspec = array(
  0 => array(""pipe"", ""r""),
  1 => array(""pipe"", ""w""),
  2 => array(""file"", ""/tmp/error-output.txt"", ""a"")
  );</Code>
    <Justification>The code initializes the `descriptorspec` array with a hard-coded file path `/tmp/error-output.txt`. This makes the code less flexible and harder to maintain if the file path needs to be changed.</Justification>
  </Issue>
</Issues>
```"
CWE-91,src/CWE_91__popen__no_sanitizing__ID_at-sprintf_%s_simple_quote.php,"<?php







$handle = popen('/bin/cat /tmp/tainted.txt', 'r');
$tainted = fread($handle, 4096);
pclose($handle);



$query = sprintf(""


$xml = simplexml_load_file(""users.xml"");
echo ""query : "". $query .""<br /><br />"" ;

$res=$xml->xpath($query);
print_r($res);
echo ""<br />"" ;

?>","$xml = simplexml_load_file(""users.xml"");",False,False,,"```xml
<Issues>
  <Issue>
    <Type>Security</Type>
    <Weakness>CWE-78</Weakness>
    <Description>Improper Neutralization of Special Elements used in a Command ('Command Injection')</Description>
    <Severity>High</Severity>
    <File>File 1</File>
    <Code>$handle = popen('/bin/cat /tmp/tainted.txt', 'r');
$tainted = fread($handle, 4096);
pclose($handle);</Code>
    <Justification>The code uses popen to execute a command, reading the output of /bin/cat /tmp/tainted.txt.  If /tmp/tainted.txt contains shell metacharacters, they will be executed, leading to command injection.</Justification>
  </Issue>
  <Issue>
    <Type>Security</Type>
    <Weakness>CWE-643</Weakness>
    <Description>Improper Neutralization of Data within XPath Expressions ('XPath Injection')</Description>
    <Severity>High</Severity>
    <File>File 1</File>
    <Code>$query = sprintf(""


$xml = simplexml_load_file(""users.xml"");
echo ""query : "". $query .""&lt;br /&gt;&lt;br /&gt;"" ;

$res=$xml->xpath($query);</Code>
    <Justification>The code uses sprintf to construct an XPath query using the tainted data from the command injection.  If the tainted variable contains XPath metacharacters, they will be interpreted as part of the XPath query, leading to XPath injection.</Justification>
  </Issue>
</Issues>
```"
CWE-89,src/CWE_89__array-GET__func_mysql_real_escape_string__multiple_AS-interpretation.php,"<?php







$array = array();
$array[] = 'safe' ;
$array[] = $_GET['userData'] ;
$array[] = 'safe' ;
$tainted = $array[1] ;

$tainted = mysql_real_escape_string($tainted);

$query = ""SELECT Trim(a.FirstName) & ' ' & Trim(a.LastName) AS employee_name, a.city, a.street & (' ' +a.housenum) AS address FROM Employees AS a  WHERE a.supervisor= $tainted "";


$conn = mysql_connect('localhost', 'mysql_user', 'mysql_password'); 
mysql_select_db('dbname') ;
echo ""query : "". $query .""<br /><br />"" ;

$res = mysql_query($query); 

while($data =mysql_fetch_array($res)){
print_r($data) ;
echo ""<br />"" ;
} 
mysql_close($conn);

?>","$conn = mysql_connect('localhost', 'mysql_user', 'mysql_password'); ",True,True,"$tainted = mysql_real_escape_string($tainted);

$query = ""SELECT Trim(a.FirstName) & ' ' & Trim(a.LastName) AS employee_name, a.city, a.street & (' ' +a.housenum) AS address FROM Employees AS a  WHERE a.supervisor= $tainted "";","```xml
<Issues>
  <Issue>
    <Type>Security</Type>
    <Weakness>CWE-89</Weakness>
    <Description>Improper Neutralization of Special Elements used in an SQL Command ('SQL Injection')</Description>
    <Severity>High</Severity>
    <File>File 1</File>
    <Code>$tainted = mysql_real_escape_string($tainted);

$query = ""SELECT Trim(a.FirstName) &amp; ' ' &amp; Trim(a.LastName) AS employee_name, a.city, a.street &amp; (' ' +a.housenum) AS address FROM Employees AS a  WHERE a.supervisor= $tainted "";</Code>
    <Justification>Even after using mysql_real_escape_string, the code is still vulnerable to SQL injection because the entire query is constructed as a string and then executed. While mysql_real_escape_string prevents simple SQL injection, it might not be effective against all types of SQL injection attacks, especially against integer-based SQL injection. Also, the query uses string concatenation with user-supplied data, increasing the risk. Using prepared statements with parameterized queries is the recommended way to prevent SQL injection.</Justification>
  </Issue>
  <Issue>
    <Type>Security</Type>
    <Weakness>CWE-477</Weakness>
    <Description>Use of Obsolete Function</Description>
    <Severity>Medium</Severity>
    <File>File 1</File>
    <Code>$conn = mysql_connect('localhost', 'mysql_user', 'mysql_password'); 
mysql_select_db('dbname') ;</Code>
    <Justification>The mysql_* functions are deprecated and should not be used. They are removed in PHP7. Using mysqli or PDO is the recommended approach.</Justification>
  </Issue>
  <Issue>
    <Type>Reliability</Type>
    <Weakness>CWE-252</Weakness>
    <Description>Unchecked Return Value</Description>
    <Severity>Medium</Severity>
    <File>File 1</File>
    <Code>$conn = mysql_connect('localhost', 'mysql_user', 'mysql_password'); 
mysql_select_db('dbname') ;
echo ""query : "". $query .""&lt;br /&gt;&lt;br /&gt;"" ;

$res = mysql_query($query);</Code>
    <Justification>The code does not check the return values of `mysql_connect`, `mysql_select_db`, and `mysql_query`. If these functions fail, they will return FALSE, and the script will continue to execute, potentially leading to errors or unexpected behavior.</Justification>
  </Issue>
  <Issue>
    <Type>Maintainability</Type>
    <Weakness>CWE-1051</Weakness>
    <Description>Initialization with Hard-Coded Network Resource Configuration Data</Description>
    <Severity>Low</Severity>
    <File>File 1</File>
    <Code>$conn = mysql_connect('localhost', 'mysql_user', 'mysql_password');</Code>
    <Justification>The database connection details ('localhost', 'mysql_user', 'mysql_password') are hard-coded in the script. This makes it difficult to change the database configuration without modifying the code. It is recommended to store these details in a configuration file or environment variables.</Justification>
  </Issue>
</Issues>
```"
CWE-79,src/CWE_79__popen__func_FILTER-VALIDATION-email_filter__Use_untrusted_data_attribute-unquoted_Attr.php,"<!-- 
Unsafe sample
input : Uses popen to read the file /tmp/tainted.txt using cat command
Flushes content of $sanitized if the filter email_filter is not applied
File : use of untrusted data in a unquoted attribute
-->

<!--Copyright 2015 Bertrand STIVALET 

Permission is hereby granted, without written agreement or royalty fee, to

use, copy, modify, and distribute this software and its documentation for

any purpose, provided that the above copyright notice and the following

three paragraphs appear in all copies of this software.


IN NO EVENT SHALL AUTHORS BE LIABLE TO ANY PARTY FOR DIRECT,

INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES ARISING OUT OF THE 

USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF AUTHORS HAVE

BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.


AUTHORS SPECIFICALLY DISCLAIM ANY WARRANTIES INCLUDING, BUT NOT

LIMITED TO THE IMPLIED WARRANTIES OF MERCHANTABILITY, FITNESS FOR A

PARTICULAR PURPOSE, AND NON-INFRINGEMENT.


THE SOFTWARE IS PROVIDED ON AN ""AS-IS"" BASIS AND AUTHORS HAVE NO

OBLIGATION TO PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR

MODIFICATIONS.-->


<!DOCTYPE html>
<html>
<head/>
<body>
<?php
$handle = popen('/bin/cat /tmp/tainted.txt', 'r');
$tainted = fread($handle, 4096);
pclose($handle);

if (filter_var($sanitized, FILTER_VALIDATE_EMAIL))
  $tainted = $sanitized ;
else
  $tainted = """" ;


echo ""<div id="". $tainted ."">content</div>"" ;
?>
<h1>Hello World!</h1>
</body>
</html>","echo ""<div id="". $tainted ."">content</div>"" ;",True,True,"echo ""<div id="". $tainted ."">content</div>"" ;","```xml
<Issues>
  <Issue>
    <Type>Security</Type>
    <Weakness>CWE-79</Weakness>
    <Description>Improper Neutralization of Input During Web Page Generation ('Cross-site Scripting')</Description>
    <Severity>High</Severity>
    <File>File 1</File>
    <Code>echo ""&lt;div id="". $tainted ."">content&lt;/div>"" ;</Code>
    <Justification>The variable $tainted, which is derived from an external source (/tmp/tainted.txt), is directly outputted into an HTML attribute without proper sanitization. This allows for XSS attacks, as an attacker could inject malicious JavaScript code into the attribute value.</Justification>
  </Issue>
  <Issue>
    <Type>Security</Type>
    <Weakness>CWE-78</Weakness>
    <Description>Improper Neutralization of Special Elements used in an OS Command ('OS Command Injection')</Description>
    <Severity>High</Severity>
    <File>File 1</File>
    <Code>$handle = popen('/bin/cat /tmp/tainted.txt', 'r');</Code>
    <Justification>The code executes an OS command using popen to read the content of /tmp/tainted.txt. While the command itself is hardcoded, the reliance on an external file introduces a potential vulnerability. If an attacker can control the content of /tmp/tainted.txt, they might be able to inject shell commands.</Justification>
  </Issue>
  <Issue>
    <Type>Reliability</Type>
    <Weakness>CWE-252</Weakness>
    <Description>Unchecked Return Value</Description>
    <Severity>Medium</Severity>
    <File>File 1</File>
    <Code>$handle = popen('/bin/cat /tmp/tainted.txt', 'r');
$tainted = fread($handle, 4096);
pclose($handle);</Code>
    <Justification>The code doesn't check the return values of `popen`, `fread`, and `pclose`. If `popen` fails, `$handle` could be `false`, leading to errors when passed to `fread` and `pclose`. If `fread` fails to read the file (e.g., file not found, permission issues), `$tainted` might not be properly initialized or contain partial data, potentially leading to unexpected behavior. Similarly, failing to close the file descriptor with `pclose` could leave resources open.</Justification>
  </Issue>
</Issues>
```"
CWE-90,src/CWE_90__object-indexArray__func_FILTER-CLEANING-email_filter__userByMail-interpretation_simple_quote.php,"<?php







class Input{
  private $input;

  public function getInput(){
    return $this->input['realOne'];
  }

  public  function __construct(){
    $this->input = array();
    $this->input['test']= 'safe' ;
    $this->input['realOne']= $_GET['UserData'] ;
    $this->input['trap']= 'safe' ;
  }
}
$temp = new Input();
$tainted =  $temp->getInput();

$sanitized = filter_var($tainted, FILTER_SANITIZE_EMAIL);
if (filter_var($sanitized, FILTER_VALIDATE_EMAIL))
  $tainted = $sanitized ;
else
  $tainted = """" ;

$query = ""(&(objectCategory=person)(objectClass=user)(mail=' $tainted '))"";


$ds=ldap_connect(""localhost""); 
$r=ldap_bind($ds);
$sr=ldap_search($ds,""o=My Company, c=US"", $query);  
ldap_close($ds);

?>","$ds=ldap_connect(""localhost"");",True,False,"$query = ""(&(objectCategory=person)(objectClass=user)(mail=' $tainted '))"";","```xml
<Issues>
  <Issue>
    <Type>Security</Type>
    <Weakness>CWE-90</Weakness>
    <Description>Improper Neutralization of Special Elements used in an LDAP Query ('LDAP Injection')</Description>
    <Severity>High</Severity>
    <File>File 1</File>
    <Code>$query = ""(&(objectCategory=person)(objectClass=user)(mail=' $tainted '))"";</Code>
    <Justification>The code constructs an LDAP query by directly embedding user-controlled data ($tainted) into the query string. This can lead to LDAP injection vulnerabilities if the input is not properly sanitized or validated. Although the code attempts to sanitize the input as an email, this is insufficient as LDAP has its own set of special characters that need to be escaped.</Justification>
  </Issue>
  <Issue>
    <Type>Reliability</Type>
    <Weakness>CWE-252</Weakness>
    <Description>Unchecked Return Value</Description>
    <Severity>Medium</Severity>
    <File>File 1</File>
    <Code>$ds=ldap_connect(""localhost""); 
$r=ldap_bind($ds);
$sr=ldap_search($ds,""o=My Company, c=US"", $query);  
ldap_close($ds);</Code>
    <Justification>The code does not check the return values of `ldap_connect`, `ldap_bind`, and `ldap_search`. If any of these functions fail, the subsequent code may operate on an invalid resource or produce incorrect results. For example, if `ldap_connect` fails, $ds will be false, and `ldap_bind($ds)` will generate a warning and may not bind, but the code continues execution.</Justification>
  </Issue>
  <Issue>
    <Type>Security</Type>
    <Weakness>CWE-477</Weakness>
    <Description>Use of Obsolete Function</Description>
    <Severity>Low</Severity>
    <File>File 1</File>
    <Code>$ds=ldap_connect(""localhost""); 
$r=ldap_bind($ds);
$sr=ldap_search($ds,""o=My Company, c=US"", $query);  
ldap_close($ds);</Code>
    <Justification>The ldap_* functions are considered obsolete and may not be available or secure in future PHP versions.  Using these functions suggests the code has not been actively reviewed or maintained.</Justification>
  </Issue>
</Issues>
```"
CWE-89,src/CWE_89__object-directGet__func_FILTER-CLEANING-special_chars_filter__select_from-concatenation_simple_quote.php,"<?php







class Input{
  public function getInput(){
    return $_GET['UserData'] ;
  }
}

$temp = new Input();
$tainted =  $temp->getInput();

$sanitized = filter_var($tainted, FILTER_SANITIZE_SPECIAL_CHARS);
  $tainted = $sanitized ;
      

$query = ""SELECT * FROM '"". $tainted . ""'"";


$conn = mysql_connect('localhost', 'mysql_user', 'mysql_password'); 
mysql_select_db('dbname') ;
echo ""query : "". $query .""<br /><br />"" ;

$res = mysql_query($query); 

while($data =mysql_fetch_array($res)){
print_r($data) ;
echo ""<br />"" ;
} 
mysql_close($conn);

?>","$conn = mysql_connect('localhost', 'mysql_user', 'mysql_password'); ",True,False,"$query = ""SELECT * FROM '"". $tainted . ""'"";","```xml
<Issues>
  <Issue>
    <Type>Security</Type>
    <Weakness>CWE-89</Weakness>
    <Description>Improper Neutralization of Special Elements used in an SQL Command ('SQL Injection')</Description>
    <Severity>Critical</Severity>
    <File>File 1</File>
    <Code>$query = ""SELECT * FROM '"". $tainted . ""'"";</Code>
    <Justification>The code is vulnerable to SQL injection because it directly incorporates unsanitized user input ($tainted) into the SQL query.  Even though the input is sanitized with FILTER_SANITIZE_SPECIAL_CHARS, this is insufficient to prevent SQL injection as it doesn't properly escape or quote the input for use within the SQL query.  An attacker could manipulate the $tainted variable to inject malicious SQL code.</Justification>
  </Issue>
  <Issue>
    <Type>Reliability</Type>
    <Weakness>CWE-252</Weakness>
    <Description>Unchecked Return Value</Description>
    <Severity>Medium</Severity>
    <File>File 1</File>
    <Code>$conn = mysql_connect('localhost', 'mysql_user', 'mysql_password');</Code>
    <Justification>The code does not check the return value of mysql_connect(). If the connection fails, mysql_connect() will return FALSE, and subsequent operations on $conn will lead to errors. This could cause the application to behave unpredictably or crash.</Justification>
  </Issue>
  <Issue>
    <Type>Reliability</Type>
    <Weakness>CWE-252</Weakness>
    <Description>Unchecked Return Value</Description>
    <Severity>Medium</Severity>
    <File>File 1</File>
    <Code>$res = mysql_query($query);</Code>
    <Justification>The code does not check the return value of mysql_query(). If the query fails, mysql_query() will return FALSE, and subsequent operations on $res will lead to errors.  This could cause the application to behave unpredictably or crash.</Justification>
  </Issue>
  <Issue>
    <Type>Maintainability</Type>
    <Weakness>CWE-477</Weakness>
    <Description>Use of Obsolete Function</Description>
    <Severity>Low</Severity>
    <File>File 1</File>
    <Code>
$conn = mysql_connect('localhost', 'mysql_user', 'mysql_password'); 
mysql_select_db('dbname') ;
</Code>
    <Justification>The mysql_* functions are deprecated. Using deprecated functions makes the code harder to maintain and potentially less secure, as these functions may not receive security updates.</Justification>
  </Issue>
  <Issue>
    <Type>Security</Type>
    <Weakness>CWE-477</Weakness>
    <Description>Use of Obsolete Function</Description>
    <Severity>Low</Severity>
    <File>File 1</File>
    <Code>
$conn = mysql_connect('localhost', 'mysql_user', 'mysql_password'); 
mysql_select_db('dbname') ;
</Code>
    <Justification>The mysql_* functions are deprecated. Using deprecated functions can introduce security vulnerabilities, as they might not receive the same level of scrutiny and security patches as more modern alternatives like mysqli or PDO.</Justification>
  </Issue>
</Issues>
```"
CWE-79,src/CWE_79__object-indexArray__func_addslashes__Unsafe_use_untrusted_data-comment.php,"<!-- 
Unsafe sample
input : get the field userData from the variable $_GET via an object, which store it in a array
sanitize : use of the function addslashes
File : unsafe, use of untrusted data in a comment
-->

<!--Copyright 2015 Bertrand STIVALET 

Permission is hereby granted, without written agreement or royalty fee, to

use, copy, modify, and distribute this software and its documentation for

any purpose, provided that the above copyright notice and the following

three paragraphs appear in all copies of this software.


IN NO EVENT SHALL AUTHORS BE LIABLE TO ANY PARTY FOR DIRECT,

INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES ARISING OUT OF THE 

USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF AUTHORS HAVE

BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.


AUTHORS SPECIFICALLY DISCLAIM ANY WARRANTIES INCLUDING, BUT NOT

LIMITED TO THE IMPLIED WARRANTIES OF MERCHANTABILITY, FITNESS FOR A

PARTICULAR PURPOSE, AND NON-INFRINGEMENT.


THE SOFTWARE IS PROVIDED ON AN ""AS-IS"" BASIS AND AUTHORS HAVE NO

OBLIGATION TO PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR

MODIFICATIONS.-->


<!DOCTYPE html>
<html>
<head>
<!--
<?php
class Input{
  private $input;

  public function getInput(){
    return $this->input['realOne'];
  }

  public  function __construct(){
    $this->input = array();
    $this->input['test']= 'safe' ;
    $this->input['realOne']= $_GET['UserData'] ;
    $this->input['trap']= 'safe' ;
  }
}
$temp = new Input();
$tainted =  $temp->getInput();

$tainted = addslashes($tainted);


echo $tainted ;
?>
-->
</head>
<body>
<h1>Hello World!</h1>
</body>
</html>",echo $tainted ;,True,True,"echo $tainted ;
?>
-->","```xml
<Issues>
  <Issue>
    <Type>Security</Type>
    <Weakness>CWE-79</Weakness>
    <Description>Improper Neutralization of Input During Web Page Generation ('Cross-site Scripting')</Description>
    <Severity>Medium</Severity>
    <File>File 1</File>
    <Code>
echo $tainted ;
?>
--&gt;</Code>
    <Justification>The code sanitizes the input with addslashes() but outputs directly into an HTML comment. While addslashes() helps prevent SQL Injection, it does not neutralize input for HTML context.  A specially crafted input could break out of the comment and inject malicious HTML/JavaScript, leading to XSS.</Justification>
  </Issue>
</Issues>
```"
CWE-79,src/CWE_79__object-indexArray__func_addslashes__Use_untrusted_data_propertyValue_CSS-property_Value.php,"<!-- 
Unsafe sample
input : get the field userData from the variable $_GET via an object, which store it in a array
sanitize : use of the function addslashes
File : use of untrusted data in a property value (CSS)
-->

<!--Copyright 2015 Bertrand STIVALET 

Permission is hereby granted, without written agreement or royalty fee, to

use, copy, modify, and distribute this software and its documentation for

any purpose, provided that the above copyright notice and the following

three paragraphs appear in all copies of this software.


IN NO EVENT SHALL AUTHORS BE LIABLE TO ANY PARTY FOR DIRECT,

INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES ARISING OUT OF THE 

USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF AUTHORS HAVE

BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.


AUTHORS SPECIFICALLY DISCLAIM ANY WARRANTIES INCLUDING, BUT NOT

LIMITED TO THE IMPLIED WARRANTIES OF MERCHANTABILITY, FITNESS FOR A

PARTICULAR PURPOSE, AND NON-INFRINGEMENT.


THE SOFTWARE IS PROVIDED ON AN ""AS-IS"" BASIS AND AUTHORS HAVE NO

OBLIGATION TO PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR

MODIFICATIONS.-->


<!DOCTYPE html>
<html>
<head>
<style>
<?php
class Input{
  private $input;

  public function getInput(){
    return $this->input['realOne'];
  }

  public  function __construct(){
    $this->input = array();
    $this->input['test']= 'safe' ;
    $this->input['realOne']= $_GET['UserData'] ;
    $this->input['trap']= 'safe' ;
  }
}
$temp = new Input();
$tainted =  $temp->getInput();

$tainted = addslashes($tainted);


echo ""body { color :"". $tainted ."" ; }"" ;
?>
 </style> 
 </script>
</head>
<body>
<h1>Hello World!</h1>
</body>
</html>","echo ""body { color :"". $tainted ."" ; }"" ;",True,True,"$tainted = addslashes($tainted);


echo ""body { color :"". $tainted ."" ; }"" ;
?>
 </style>","```xml
<Issues>
  <Issue>
    <Type>Security</Type>
    <Weakness>CWE-79</Weakness>
    <Description>Improper Neutralization of Input During Web Page Generation ('Cross-site Scripting')</Description>
    <Severity>Medium</Severity>
    <File>File 1</File>
    <Code>
$tainted = addslashes($tainted);


echo ""body { color :"". $tainted ."" ; }"" ;
?>
 </style>
    </Code>
    <Justification>The code uses external input ($_GET['UserData']) to construct a CSS property value. Although addslashes() is used, it is insufficient to prevent XSS in CSS context. An attacker could inject malicious CSS code, leading to XSS.</Justification>
  </Issue>
  <Issue>
    <Type>Security</Type>
    <Weakness>CWE-22</Weakness>
    <Description>Improper Limitation of a Pathname to a Restricted Directory ('Path Traversal')</Description>
    <Severity>Low</Severity>
    <File>File 1</File>
    <Code>
    $this->input['realOne']= $_GET['UserData'] ;
    $this->input['trap']= 'safe' ;
  }
}
$temp = new Input();
$tainted =  $temp->getInput();

$tainted = addslashes($tainted);</Code>
    <Justification>Although this is not a direct path traversal, the code uses external input ($_GET['UserData']) without proper validation.  If the application were to use this `$tainted` variable in a file path construction later, it could potentially lead to path traversal vulnerabilities, even though it's not immediately apparent in the given code snippet.</Justification>
  </Issue>
</Issues>
```"
CWE-91,src/CWE_91__proc_open__func_FILTER-CLEANING-full_special_chars_filter__username_text-sprintf_%s_simple_quote.php,"<?php







$descriptorspec = array(
  0 => array(""pipe"", ""r""),
  1 => array(""pipe"", ""w""),
  2 => array(""file"", ""/tmp/error-output.txt"", ""a"")
  );
$cwd = '/tmp';
$process = proc_open('more /tmp/tainted.txt', $descriptorspec, $pipes, $cwd, NULL);
if (is_resource($process)) {
  fclose($pipes[0]);
  $tainted = stream_get_contents($pipes[1]);
  fclose($pipes[1]);
  $return_value = proc_close($process);
}

$sanitized = filter_var($tainted, FILTER_SANITIZE_FULL_SPECIAL_CHARS);
  $tainted = $sanitized ;
     

$query = sprintf(""


$xml = simplexml_load_file(""users.xml"");
echo ""query : "". $query .""<br /><br />"" ;

$res=$xml->xpath($query);
print_r($res);
echo ""<br />"" ;

?>","$xml = simplexml_load_file(""users.xml"");",True,True,"$sanitized = filter_var($tainted, FILTER_SANITIZE_FULL_SPECIAL_CHARS);
  $tainted = $sanitized ;
     

$query = sprintf(""","```xml
<Issues>
  <Issue>
    <Type>Security</Type>
    <Weakness>CWE-91</Weakness>
    <Description>XML Injection (aka Blind XPath Injection)</Description>
    <Severity>High</Severity>
    <File>File 1</File>
    <Code>$sanitized = filter_var($tainted, FILTER_SANITIZE_FULL_SPECIAL_CHARS);
  $tainted = $sanitized ;
     

$query = sprintf(""</Code>
    <Justification>The code sanitizes the tainted input with 'FILTER_SANITIZE_FULL_SPECIAL_CHARS' but then assigns it back to the $tainted variable, which is then used in an XPath query. This can lead to XML/XPath injection, allowing attackers to modify the syntax, content, or commands of the XML before it is processed.</Justification>
  </Issue>
  <Issue>
    <Type>Reliability</Type>
    <Weakness>CWE-252</Weakness>
    <Description>Unchecked Return Value</Description>
    <Severity>Medium</Severity>
    <File>File 1</File>
    <Code>$process = proc_open('more /tmp/tainted.txt', $descriptorspec, $pipes, $cwd, NULL);
if (is_resource($process)) {
  fclose($pipes[0]);
  $tainted = stream_get_contents($pipes[1]);
  fclose($pipes[1]);
  $return_value = proc_close($process);
}
</Code>
    <Justification>The code does not check the return value of `proc_open`. If `proc_open` fails, `$process` will not be a resource, but the code proceeds to use it as if it were, potentially causing errors.</Justification>
  </Issue>
  <Issue>
    <Type>Reliability</Type>
    <Weakness>CWE-252</Weakness>
    <Description>Unchecked Return Value</Description>
    <Severity>Medium</Severity>
    <File>File 1</File>
    <Code>if (is_resource($process)) {
  fclose($pipes[0]);
  $tainted = stream_get_contents($pipes[1]);
  fclose($pipes[1]);
  $return_value = proc_close($process);
}</Code>
    <Justification>The code does not check the return value of `fclose` after calling it on `$pipes[0]` and `$pipes[1]`. If `fclose` fails, the code proceeds without handling the error, potentially leading to resource leaks or other issues.</Justification>
  </Issue>
  <Issue>
    <Type>Reliability</Type>
    <Weakness>CWE-252</Weakness>
    <Description>Unchecked Return Value</Description>
    <Severity>Medium</Severity>
    <File>File 1</File>
    <Code>if (is_resource($process)) {
  fclose($pipes[0]);
  $tainted = stream_get_contents($pipes[1]);
  fclose($pipes[1]);
  $return_value = proc_close($process);
}</Code>
    <Justification>The code does not check the return value of `stream_get_contents`. If `stream_get_contents` fails, `$tainted` might be empty or contain unexpected data, leading to unpredictable behavior in subsequent operations.</Justification>
  </Issue>
  <Issue>
    <Type>Reliability</Type>
    <Weakness>CWE-703</Weakness>
    <Description>Improper Check or Handling of Exceptional Conditions</Description>
    <Severity>Medium</Severity>
    <File>File 1</File>
    <Code>$xml = simplexml_load_file(""users.xml"");
echo ""query : "". $query .""<br /><br />"" ;

$res=$xml->xpath($query);
print_r($res);</Code>
    <Justification>The code does not check if `simplexml_load_file` successfully loads the XML file. If the file does not exist or is malformed, `simplexml_load_file` may return false or null, leading to errors when trying to call `xpath` on a non-object.</Justification>
  </Issue>
</Issues>
```"
CWE-91,src/CWE_91__object-indexArray__func_FILTER-CLEANING-full_special_chars_filter__username_at-interpretation_simple_quote.php,"<?php







class Input{
  private $input;

  public function getInput(){
    return $this->input['realOne'];
  }

  public  function __construct(){
    $this->input = array();
    $this->input['test']= 'safe' ;
    $this->input['realOne']= $_GET['UserData'] ;
    $this->input['trap']= 'safe' ;
  }
}
$temp = new Input();
$tainted =  $temp->getInput();

$sanitized = filter_var($tainted, FILTER_SANITIZE_FULL_SPECIAL_CHARS);
  $tainted = $sanitized ;
     

$query = ""


$xml = simplexml_load_file(""users.xml"");
echo ""query : "". $query .""<br /><br />"" ;

$res=$xml->xpath($query);
print_r($res);
echo ""<br />"" ;

?>","$xml = simplexml_load_file(""users.xml"");",False,False,,"```xml
<Issues>
  <Issue>
    <Type>Security</Type>
    <Weakness>CWE-643</Weakness>
    <Description>Improper Neutralization of Data within XPath Expressions ('XPath Injection')</Description>
    <Severity>High</Severity>
    <File>File 1</File>
    <Code>$sanitized = filter_var($tainted, FILTER_SANITIZE_FULL_SPECIAL_CHARS);
  $tainted = $sanitized ;
     

$query = ""</Code>
    <Justification>The code uses user-controlled data ($tainted) to construct an XPath query without proper neutralization, leading to XPath Injection vulnerability. Even though filter_var is used, it might not be sufficient to neutralize all special characters that can be used to manipulate the XPath query, especially if the XPath query logic relies on specific characters or patterns.</Justification>
  </Issue>
  <Issue>
    <Type>Reliability</Type>
    <Weakness>CWE-252</Weakness>
    <Description>Unchecked Return Value</Description>
    <Severity>Low</Severity>
    <File>File 1</File>
    <Code>$xml = simplexml_load_file(""users.xml"");
echo ""query : "". $query .""<br /><br />"" ;

$res=$xml->xpath($query);</Code>
    <Justification>The code does not check the return value of simplexml_load_file(). If the file does not exist or is malformed, simplexml_load_file() will return false and using $xml will cause an error.</Justification>
  </Issue>
</Issues>
```"
CWE-79,src/CWE_79__object-classicGet__func_mysql_real_escape_string__Use_untrusted_data-body.php,"<!-- 
Unsafe sample
input : get the field userData from the variable $_GET via an object
SANITIZE : use of mysql_real_escape string
File : use of untrusted data in the body
-->

<!--Copyright 2015 Bertrand STIVALET 

Permission is hereby granted, without written agreement or royalty fee, to

use, copy, modify, and distribute this software and its documentation for

any purpose, provided that the above copyright notice and the following

three paragraphs appear in all copies of this software.


IN NO EVENT SHALL AUTHORS BE LIABLE TO ANY PARTY FOR DIRECT,

INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES ARISING OUT OF THE 

USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF AUTHORS HAVE

BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.


AUTHORS SPECIFICALLY DISCLAIM ANY WARRANTIES INCLUDING, BUT NOT

LIMITED TO THE IMPLIED WARRANTIES OF MERCHANTABILITY, FITNESS FOR A

PARTICULAR PURPOSE, AND NON-INFRINGEMENT.


THE SOFTWARE IS PROVIDED ON AN ""AS-IS"" BASIS AND AUTHORS HAVE NO

OBLIGATION TO PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR

MODIFICATIONS.-->


<!DOCTYPE html>
<html>
<head/>
<body>
<?php
class Input{
  private $input;

  public function getInput(){
    return $this->input;
  }

  public  function __construct(){
   $this->input = $_GET['UserData'] ;
  }
}
$temp = new Input();
$tainted =  $temp->getInput();

$tainted = mysql_real_escape_string($tainted);


echo $tainted ;
?>
<h1>Hello World!</h1>
</body>
</html>
",echo $tainted ;,False,False,,"```xml
<Issues>
  <Issue>
    <Type>Security</Type>
    <Weakness>CWE-477</Weakness>
    <Description>Use of Obsolete Function</Description>
    <Severity>High</Severity>
    <File>File 1</File>
    <Code>$tainted = mysql_real_escape_string($tainted);</Code>
    <Justification>The function mysql_real_escape_string() is deprecated and can lead to vulnerabilities if the application is migrated to a newer PHP version where it is no longer supported. The code should use a supported and secure alternative, such as prepared statements with PDO or mysqli.</Justification>
  </Issue>
  <Issue>
    <Type>Maintainability</Type>
    <Weakness>CWE-477</Weakness>
    <Description>Use of Obsolete Function</Description>
    <Severity>Low</Severity>
    <File>File 1</File>
    <Code>$tainted = mysql_real_escape_string($tainted);</Code>
    <Justification>The function mysql_real_escape_string() is deprecated, making the code harder to maintain as it relies on outdated technology.  It should be replaced with a modern alternative.</Justification>
  </Issue>
</Issues>
```"
CWE-90,src/CWE_90__object-directGet__func_htmlentities__userByMail-concatenation_simple_quote.php,"<?php







class Input{
  public function getInput(){
    return $_GET['UserData'] ;
  }
}

$temp = new Input();
$tainted =  $temp->getInput();

$tainted = htmlentities($tainted, ENT_QUOTES);

$query = ""(&(objectCategory=person)(objectClass=user)(mail='"". $tainted . ""'))"";


$ds=ldap_connect(""localhost""); 
$r=ldap_bind($ds);
$sr=ldap_search($ds,""o=My Company, c=US"", $query);  
ldap_close($ds);

?>","$ds=ldap_connect(""localhost"");",True,True,"$tainted = htmlentities($tainted, ENT_QUOTES);

$query = ""(&(objectCategory=person)(objectClass=user)(mail='"". $tainted . ""'))"";


$ds=ldap_connect(""localhost"");","```xml
<Issues>
  <Issue>
    <Type>Security</Type>
    <Weakness>CWE-90</Weakness>
    <Description>Improper Neutralization of Special Elements used in an LDAP Query ('LDAP Injection')</Description>
    <Severity>High</Severity>
    <File>File 1</File>
    <Code>$tainted = htmlentities($tainted, ENT_QUOTES);

$query = ""(&(objectCategory=person)(objectClass=user)(mail='"". $tainted . ""'))"";


$ds=ldap_connect(""localhost"");</Code>
    <Justification>The code constructs an LDAP query by directly embedding user-supplied input ($tainted) into the query string. Although htmlentities is used, it does not provide sufficient protection against LDAP injection.  An attacker could manipulate the $tainted input to inject arbitrary LDAP code, potentially bypassing authentication or extracting sensitive information.</Justification>
  </Issue>
  <Issue>
    <Type>Reliability</Type>
    <Weakness>CWE-252</Weakness>
    <Description>Unchecked Return Value</Description>
    <Severity>Medium</Severity>
    <File>File 1</File>
    <Code>$ds=ldap_connect(""localhost""); 
$r=ldap_bind($ds);
$sr=ldap_search($ds,""o=My Company, c=US"", $query);  
ldap_close($ds);</Code>
    <Justification>The code does not check the return values of ldap_connect, ldap_bind, and ldap_search. If any of these functions fail, they will return FALSE, and the subsequent code may operate on an invalid resource, leading to unpredictable behavior or errors. For example, if ldap_connect fails, $ds will be FALSE, and calling ldap_bind($ds) will result in an error.</Justification>
  </Issue>
</Issues>
```"
CWE-79,src/CWE_79__popen__func_preg_replace__Use_untrusted_data_propertyValue_CSS-span_Style_Property_Value.php,"<!-- 
Unsafe sample
input : Uses popen to read the file /tmp/tainted.txt using cat command
SANITIZE : use of preg_replace
File : unsafe, use of untrusted data in a property value in a span tag(CSS)
-->

<!--Copyright 2015 Bertrand STIVALET 

Permission is hereby granted, without written agreement or royalty fee, to

use, copy, modify, and distribute this software and its documentation for

any purpose, provided that the above copyright notice and the following

three paragraphs appear in all copies of this software.


IN NO EVENT SHALL AUTHORS BE LIABLE TO ANY PARTY FOR DIRECT,

INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES ARISING OUT OF THE 

USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF AUTHORS HAVE

BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.


AUTHORS SPECIFICALLY DISCLAIM ANY WARRANTIES INCLUDING, BUT NOT

LIMITED TO THE IMPLIED WARRANTIES OF MERCHANTABILITY, FITNESS FOR A

PARTICULAR PURPOSE, AND NON-INFRINGEMENT.


THE SOFTWARE IS PROVIDED ON AN ""AS-IS"" BASIS AND AUTHORS HAVE NO

OBLIGATION TO PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR

MODIFICATIONS.-->


<!DOCTYPE html>
<html>
<head/>
<body>
<?php
$handle = popen('/bin/cat /tmp/tainted.txt', 'r');
$tainted = fread($handle, 4096);
pclose($handle);

$tainted = preg_replace('/\'/', '', $tainted);


echo ""<span style=\""color :"". checked_data .""\"">Hey</span>"" ;
?>
<h1>Hello World!</h1>
</body>
</html>","echo ""<span style=\""color :"". checked_data .""\"">Hey</span>"" ;",True,True,"echo ""<span style=\""color :"". checked_data .""\"">Hey</span>"" ;","```xml
<Issues>
  <Issue>
    <Type>Security</Type>
    <Weakness>CWE-77</Weakness>
    <Description>Improper Neutralization of Special Elements used in a Command ('Command Injection')</Description>
    <Severity>High</Severity>
    <File>File 1</File>
    <Code>$handle = popen('/bin/cat /tmp/tainted.txt', 'r');</Code>
    <Justification>The code uses popen to execute a command. Although the command itself seems safe, popen can be dangerous if the input to the command is not carefully validated. In this case, the command is hardcoded, so the risk is lower, but it is still a potential weakness.</Justification>
  </Issue>
  <Issue>
    <Type>Security</Type>
    <Weakness>CWE-79</Weakness>
    <Description>Improper Neutralization of Input During Web Page Generation ('Cross-site Scripting')</Description>
    <Severity>Medium</Severity>
    <File>File 1</File>
    <Code>echo ""&lt;span style=\""color :"". checked_data .""\""&gt;Hey&lt;/span&gt;"" ;</Code>
    <Justification>The code is using an untrusted variable named 'checked_data' without proper sanitization in the style attribute of a span tag. If an attacker can control the value of 'checked_data', they could inject arbitrary CSS or even JavaScript code, leading to a cross-site scripting (XSS) vulnerability.</Justification>
  </Issue>
</Issues>
```"
CWE-90,src/CWE_90__array-GET__no_sanitizing__userByCN-sprintf_%s_simple_quote.php,"<?php







$array = array();
$array[] = 'safe' ;
$array[] = $_GET['userData'] ;
$array[] = 'safe' ;
$tainted = $array[1] ;



$query = sprintf(""(&(objectCategory=person)(objectClass=user)(cn='%s'))"", $tainted);


$ds=ldap_connect(""localhost""); 
$r=ldap_bind($ds);
$sr=ldap_search($ds,""o=My Company, c=US"", $query);  
ldap_close($ds);

?>","$ds=ldap_connect(""localhost"");",True,False,"$query = sprintf(""(&(objectCategory=person)(objectClass=user)(cn='%s'))"", $tainted);","```xml
<Issues>
  <Issue>
    <Type>Security</Type>
    <Weakness>CWE-90</Weakness>
    <Description>Improper Neutralization of Special Elements used in an LDAP Query ('LDAP Injection')</Description>
    <Severity>High</Severity>
    <File>File 1</File>
    <Code>$query = sprintf(""(&(objectCategory=person)(objectClass=user)(cn='%s'))"", $tainted);</Code>
    <Justification>The code constructs an LDAP query using user-supplied data without proper sanitization, which can lead to LDAP injection vulnerabilities.</Justification>
  </Issue>
</Issues>
```"
CWE-90,src/CWE_90__SESSION__func_htmlspecialchars__not_name-concatenation_simple_quote.php,"<?php







$tainted = $_SESSION['UserData'];

$tainted = htmlspecialchars($tainted, ENT_QUOTES);

$query = ""!name='"". $tainted . ""'"";


$ds=ldap_connect(""localhost""); 
$r=ldap_bind($ds);
$sr=ldap_search($ds,""o=My Company, c=US"", $query);  
ldap_close($ds);

?>","$ds=ldap_connect(""localhost"");",True,True,"$tainted = $_SESSION['UserData'];

$tainted = htmlspecialchars($tainted, ENT_QUOTES);

$query = ""!name='"". $tainted . ""'"";


$ds=ldap_connect(""localhost""); 
$r=ldap_bind($ds);
$sr=ldap_search($ds,""o=My Company, c=US"", $query);  
ldap_close($ds);","```xml
<Issues>
  <Issue>
    <Type>Security</Type>
    <Weakness>CWE-90</Weakness>
    <Description>Improper Neutralization of Special Elements used in an LDAP Query ('LDAP Injection')</Description>
    <Severity>High</Severity>
    <File>File 1</File>
    <Code>$tainted = $_SESSION['UserData'];

$tainted = htmlspecialchars($tainted, ENT_QUOTES);

$query = ""!name='"". $tainted . ""'"";


$ds=ldap_connect(""localhost""); 
$r=ldap_bind($ds);
$sr=ldap_search($ds,""o=My Company, c=US"", $query);  
ldap_close($ds);</Code>
    <Justification>The code constructs an LDAP query by directly embedding user-controlled data ($tainted) into the query string. Even though htmlspecialchars is used, it's insufficient to prevent LDAP injection because it does not neutralize LDAP-specific metacharacters. An attacker could manipulate the $_SESSION['UserData'] to inject malicious LDAP syntax, potentially gaining unauthorized access or modifying data in the LDAP directory.</Justification>
  </Issue>
</Issues>
```"
CWE-79,src/CWE_79__proc_open__func_FILTER-VALIDATION-number_float_filter__Unsafe_use_untrusted_data-tag_Name.php,"<!-- 
Unsafe sample
input : use proc_open to read /tmp/tainted.txt
Flushes content of $sanitized if the filter number_float_filter is not applied
File : unsafe, use of untrusted data in an tag name
-->

<!--Copyright 2015 Bertrand STIVALET 

Permission is hereby granted, without written agreement or royalty fee, to

use, copy, modify, and distribute this software and its documentation for

any purpose, provided that the above copyright notice and the following

three paragraphs appear in all copies of this software.


IN NO EVENT SHALL AUTHORS BE LIABLE TO ANY PARTY FOR DIRECT,

INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES ARISING OUT OF THE 

USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF AUTHORS HAVE

BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.


AUTHORS SPECIFICALLY DISCLAIM ANY WARRANTIES INCLUDING, BUT NOT

LIMITED TO THE IMPLIED WARRANTIES OF MERCHANTABILITY, FITNESS FOR A

PARTICULAR PURPOSE, AND NON-INFRINGEMENT.


THE SOFTWARE IS PROVIDED ON AN ""AS-IS"" BASIS AND AUTHORS HAVE NO

OBLIGATION TO PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR

MODIFICATIONS.-->


<!DOCTYPE html>
<html>
<head/>
<body>
<?php
$descriptorspec = array(
  0 => array(""pipe"", ""r""),
  1 => array(""pipe"", ""w""),
  2 => array(""file"", ""/tmp/error-output.txt"", ""a"")
  );
$cwd = '/tmp';
$process = proc_open('more /tmp/tainted.txt', $descriptorspec, $pipes, $cwd, NULL);
if (is_resource($process)) {
  fclose($pipes[0]);
  $tainted = stream_get_contents($pipes[1]);
  fclose($pipes[1]);
  $return_value = proc_close($process);
}

if (filter_var($sanitized, FILTER_VALIDATE_FLOAT))
  $tainted = $sanitized ;
else
  $tainted = """" ;


echo ""<"".  $tainted ."" href= \""/bob\"" />"" ;
?>
<h1>Hello World!</h1>
</body>
</html>","echo ""<"".  $tainted ."" href= \""/bob\"" />"" ;",True,True,"echo ""<"".  $tainted ."" href= \""/bob\"" />"" ;","```xml
<Issues>
  <Issue>
    <Type>Security</Type>
    <Weakness>CWE-79</Weakness>
    <Description>Improper Neutralization of Input During Web Page Generation ('Cross-site Scripting')</Description>
    <Severity>High</Severity>
    <File>File 1</File>
    <Code>echo ""&lt;"".  $tainted ."" href= \""/bob\"" /&gt;"" ;</Code>
    <Justification>The code uses unsanitized input ($tainted) directly within an HTML tag name. If $tainted contains malicious code (e.g., JavaScript), it will be executed by the browser, leading to a cross-site scripting (XSS) vulnerability.</Justification>
  </Issue>
  <Issue>
    <Type>Security</Type>
    <Weakness>CWE-78</Weakness>
    <Description>Improper Neutralization of Special Elements used in an OS Command ('OS Command Injection')</Description>
    <Severity>High</Severity>
    <File>File 1</File>
    <Code>$process = proc_open('more /tmp/tainted.txt', $descriptorspec, $pipes, $cwd, NULL);</Code>
    <Justification>The code uses proc_open to execute the 'more' command on a file named '/tmp/tainted.txt'. While the file name itself is hardcoded, the content of this file is derived from an external source. If an attacker can control the content of '/tmp/tainted.txt', they can inject malicious commands that will be executed by the server. If the file did not exist, it would return an error.</Justification>
  </Issue>
  <Issue>
    <Type>Reliability</Type>
    <Weakness>CWE-252</Weakness>
    <Description>Unchecked Return Value</Description>
    <Severity>Medium</Severity>
    <File>File 1</File>
    <Code>  fclose($pipes[0]);
  $tainted = stream_get_contents($pipes[1]);
  fclose($pipes[1]);
  $return_value = proc_close($process);</Code>
    <Justification>The code does not check the return value of fclose() and proc_close(). If these functions fail (e.g., due to resource exhaustion or permission issues), the program might continue execution with invalid file handles or processes, leading to unpredictable behavior or crashes.</Justification>
  </Issue>
  <Issue>
    <Type>Security</Type>
    <Weakness>CWE-477</Weakness>
    <Description>Use of Obsolete Function</Description>
    <Severity>Low</Severity>
    <File>File 1</File>
    <Code>  $tainted = stream_get_contents($pipes[1]);</Code>
    <Justification>stream_get_contents() can exhibit unexpected behavior with certain streams or large amounts of data. While not directly a security vulnerability, its use indicates a potential lack of awareness of modern alternatives and might lead to reliability issues.</Justification>
  </Issue>
  <Issue>
    <Type>Reliability</Type>
    <Weakness>CWE-390</Weakness>
    <Description>Detection of Error Condition Without Action</Description>
    <Severity>Low</Severity>
    <File>File 1</File>
    <Code>if (filter_var($sanitized, FILTER_VALIDATE_FLOAT))
  $tainted = $sanitized ;
else
  $tainted = """" ;</Code>
    <Justification>The code uses filter_var with FILTER_VALIDATE_FLOAT to validate $sanitized, but the code does not handle the case where the validation fails (else condition). If the validation fails, $tainted is set to an empty string. This approach ensures that $tainted is always assigned a value, it does not properly report or handle the failed validation. A more robust approach would involve logging the validation failure or taking other appropriate error-handling actions.</Justification>
  </Issue>
</Issues>
```"
CWE-79,src/CWE_79__backticks__func_htmlentities__Use_untrusted_data_propertyValue_CSS-quoted_Property_Value.php,"<!-- 
Unsafe sample
input : backticks interpretation, reading the file /tmp/tainted.txt
sanitize : use of the function htmlentities. Sanitizes the query but has a high chance to produce unexpected results
File : unsafe, use of untrusted data in a quoted property value (CSS)
-->

<!--Copyright 2015 Bertrand STIVALET 

Permission is hereby granted, without written agreement or royalty fee, to

use, copy, modify, and distribute this software and its documentation for

any purpose, provided that the above copyright notice and the following

three paragraphs appear in all copies of this software.


IN NO EVENT SHALL AUTHORS BE LIABLE TO ANY PARTY FOR DIRECT,

INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES ARISING OUT OF THE 

USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF AUTHORS HAVE

BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.


AUTHORS SPECIFICALLY DISCLAIM ANY WARRANTIES INCLUDING, BUT NOT

LIMITED TO THE IMPLIED WARRANTIES OF MERCHANTABILITY, FITNESS FOR A

PARTICULAR PURPOSE, AND NON-INFRINGEMENT.


THE SOFTWARE IS PROVIDED ON AN ""AS-IS"" BASIS AND AUTHORS HAVE NO

OBLIGATION TO PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR

MODIFICATIONS.-->


<!DOCTYPE html>
<html>
<head>
<style>
<?php
$tainted = `cat /tmp/tainted.txt`;

$tainted = htmlentities($tainted, ENT_QUOTES);


echo ""body { color :\'"". $tainted .""\' ; }"" ;
?>
</style> 
</head>
<body>
<h1>Hello World!</h1>
</body>
</html>","echo ""body { color :\'"". $tainted .""\' ; }"" ;",True,True,"$tainted = htmlentities($tainted, ENT_QUOTES);


echo ""body { color :\'"". $tainted .""\' ; }"" ;
?>","```xml
<Issues>
  <Issue>
    <Type>Security</Type>
    <Weakness>CWE-78</Weakness>
    <Description>Improper Neutralization of Special Elements used in a Command ('Command Injection')</Description>
    <Severity>High</Severity>
    <File>File 1</File>
    <Code>$tainted = `cat /tmp/tainted.txt`;</Code>
    <Justification>The code uses backticks to execute a shell command (`cat /tmp/tainted.txt`) to read the content of a file. This is vulnerable to command injection if the file name or path is influenced by user input. An attacker could potentially inject arbitrary commands by manipulating the content of `/tmp/tainted.txt`.</Justification>
  </Issue>
  <Issue>
    <Type>Security</Type>
    <Weakness>CWE-79</Weakness>
    <Description>Improper Neutralization of Input During Web Page Generation ('Cross-site Scripting')</Description>
    <Severity>Medium</Severity>
    <File>File 1</File>
    <Code>
$tainted = htmlentities($tainted, ENT_QUOTES);


echo ""body { color :\'"". $tainted .""\' ; }"" ;
?>
</Code>
    <Justification>The code attempts to sanitize the `$tainted` variable using `htmlentities()` before embedding it in the CSS style. However, this can be bypassed or may not be sufficient, leading to potential XSS vulnerabilities. While `htmlentities` encodes HTML entities, it might not prevent all forms of injection, especially if the context requires more specific sanitization or if the output is interpreted in a different way than expected. The main issue here is that user-controlled input is directly placed into the CSS context.</Justification>
  </Issue>
</Issues>
```"
CWE-89,src/CWE_89__object-classicGet__no_sanitizing__select_from-sprintf_%s_simple_quote.php,"<?php







class Input{
  private $input;

  public function getInput(){
    return $this->input;
  }

  public  function __construct(){
   $this->input = $_GET['UserData'] ;
  }
}
$temp = new Input();
$tainted =  $temp->getInput();



$query = sprintf(""SELECT * FROM '%s'"", $tainted);


$conn = mysql_connect('localhost', 'mysql_user', 'mysql_password'); 
mysql_select_db('dbname') ;
echo ""query : "". $query .""<br /><br />"" ;

$res = mysql_query($query); 

while($data =mysql_fetch_array($res)){
print_r($data) ;
echo ""<br />"" ;
} 
mysql_close($conn);

?>","$conn = mysql_connect('localhost', 'mysql_user', 'mysql_password'); ",True,False,"$query = sprintf(""SELECT * FROM '%s'"", $tainted);","```xml
<Issues>
  <Issue>
    <Type>Security</Type>
    <Weakness>CWE-89</Weakness>
    <Description>Improper Neutralization of Special Elements used in an SQL Command ('SQL Injection')</Description>
    <Severity>Critical</Severity>
    <File>File 1</File>
    <Code>$query = sprintf(""SELECT * FROM '%s'"", $tainted);</Code>
    <Justification>The code uses sprintf to construct a SQL query. The $tainted variable, which originates from user-supplied GET data, is directly incorporated into the query without proper sanitization or validation. This allows an attacker to inject arbitrary SQL code, potentially leading to data breaches or other malicious activities.</Justification>
  </Issue>
  <Issue>
    <Type>Security</Type>
    <Weakness>CWE-477</Weakness>
    <Description>Use of Obsolete Function</Description>
    <Severity>High</Severity>
    <File>File 1</File>
    <Code>$conn = mysql_connect('localhost', 'mysql_user', 'mysql_password'); 
mysql_select_db('dbname') ;
echo ""query : "". $query .""&lt;br /&gt;&lt;br /&gt;"" ;

$res = mysql_query($query); </Code>
    <Justification>The code uses the mysql_connect and mysql_query functions, which are deprecated. These functions are known to have security vulnerabilities and are no longer maintained, making the application susceptible to exploitation. Developers should migrate to mysqli or PDO.</Justification>
  </Issue>
</Issues>
```"
CWE-90,src/CWE_90__shell_exec__func_preg_match-no_filtering__name-interpretation_simple_quote.php,"<?php







$tainted = shell_exec('cat /tmp/tainted.txt');

$re = ""/^.*$/"";
if(preg_match($re, $tainted) == 1){
  $tainted = $tainted;
}
else{
  $tainted = """";
}

$query = ""name=' $tainted '"";


$ds=ldap_connect(""localhost""); 
$r=ldap_bind($ds);
$sr=ldap_search($ds,""o=My Company, c=US"", $query);  
ldap_close($ds);

?>","$ds=ldap_connect(""localhost"");",True,True,"$query = ""name=' $tainted '"";

$ds=ldap_connect(""localhost""); 
$r=ldap_bind($ds);
$sr=ldap_search($ds,""o=My Company, c=US"", $query);  
ldap_close($ds);","```xml
<Issues>
  <Issue>
    <Type>Security</Type>
    <Weakness>CWE-77</Weakness>
    <Description>Improper Neutralization of Special Elements used in a Command ('Command Injection')</Description>
    <Severity>High</Severity>
    <File>File 1</File>
    <Code>$tainted = shell_exec('cat /tmp/tainted.txt');</Code>
    <Justification>The code uses shell_exec to read data from a file. If an attacker can control the contents of `/tmp/tainted.txt`, they can inject arbitrary commands to be executed on the server.</Justification>
  </Issue>
  <Issue>
    <Type>Security</Type>
    <Weakness>CWE-90</Weakness>
    <Description>Improper Neutralization of Special Elements used in an LDAP Query ('LDAP Injection')</Description>
    <Severity>High</Severity>
    <File>File 1</File>
    <Code>$query = ""name=' $tainted '"";

$ds=ldap_connect(""localhost""); 
$r=ldap_bind($ds);
$sr=ldap_search($ds,""o=My Company, c=US"", $query);  
ldap_close($ds);</Code>
    <Justification>The code constructs an LDAP query by directly embedding user-controlled data (`$tainted`) without proper sanitization.  This can lead to LDAP injection vulnerabilities, allowing attackers to bypass authentication or access unauthorized information.</Justification>
  </Issue>
</Issues>
```"
CWE-79,src/CWE_79__system__func_urlencode__Unsafe_use_untrusted_data-attribute_Name.php,"<!-- 
Unsafe sample
input : execute a ls command using the function system, and put the last result in $tainted
SANITIZE : use of urlencode
File : unsafe, use of untrusted data in an attribute name
-->

<!--Copyright 2015 Bertrand STIVALET 

Permission is hereby granted, without written agreement or royalty fee, to

use, copy, modify, and distribute this software and its documentation for

any purpose, provided that the above copyright notice and the following

three paragraphs appear in all copies of this software.


IN NO EVENT SHALL AUTHORS BE LIABLE TO ANY PARTY FOR DIRECT,

INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES ARISING OUT OF THE 

USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF AUTHORS HAVE

BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.


AUTHORS SPECIFICALLY DISCLAIM ANY WARRANTIES INCLUDING, BUT NOT

LIMITED TO THE IMPLIED WARRANTIES OF MERCHANTABILITY, FITNESS FOR A

PARTICULAR PURPOSE, AND NON-INFRINGEMENT.


THE SOFTWARE IS PROVIDED ON AN ""AS-IS"" BASIS AND AUTHORS HAVE NO

OBLIGATION TO PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR

MODIFICATIONS.-->


<!DOCTYPE html>
<html>
<body>
<?php
$tainted = system('ls', $retval);

$tainted = urlencode($tainted);


echo ""<div "". $tainted .""= bob />"" ;
?>
<h1>Hello World!</h1>
</div>
</body>
</html>","echo ""<div "". $tainted .""= bob />"" ;",True,True,"$tainted = urlencode($tainted);


echo ""<div "". $tainted .""= bob />"" ;","```xml
<Issues>
  <Issue>
    <Type>Security</Type>
    <Weakness>CWE-78</Weakness>
    <Description>Improper Neutralization of Special Elements used in a Command ('Command Injection')</Description>
    <Severity>High</Severity>
    <File>File 1</File>
    <Code>$tainted = system('ls', $retval);</Code>
    <Justification>The code uses the `system()` function to execute an OS command. While the output of the command is later URL encoded, the initial execution of `ls` is still a command injection vulnerability if the script itself is exposed to external influence. The use of system() without proper sanitization is dangerous.</Justification>
  </Issue>
  <Issue>
    <Type>Security</Type>
    <Weakness>CWE-79</Weakness>
    <Description>Improper Neutralization of Input During Web Page Generation ('Cross-site Scripting')</Description>
    <Severity>Medium</Severity>
    <File>File 1</File>
    <Code>$tainted = urlencode($tainted);


echo ""&lt;div "". $tainted .""= bob />"" ;</Code>
    <Justification>The code uses the output of the `ls` command, URL encodes it, and then uses it as an attribute name in an HTML tag. While `urlencode` provides some level of sanitization, it is insufficient to prevent all XSS attacks. Using untrusted data as attribute names is a dangerous practice and can lead to XSS.</Justification>
  </Issue>
</Issues>
```"
CWE-91,src/CWE_91__fopen__func_FILTER-CLEANING-full_special_chars_filter__username_at-sprintf_%s_simple_quote.php,"<?php







$handle = @fopen(""/tmp/tainted.txt"", ""r"");

if ($handle) {
  if(($tainted = fgets($handle, 4096)) == false) {
    $tainted = """";
  }
  fclose($handle);
} else {
  $tainted = """";
}

$sanitized = filter_var($tainted, FILTER_SANITIZE_FULL_SPECIAL_CHARS);
  $tainted = $sanitized ;
     

$query = sprintf(""


$xml = simplexml_load_file(""users.xml"");
echo ""query : "". $query .""<br /><br />"" ;

$res=$xml->xpath($query);
print_r($res);
echo ""<br />"" ;

?>","$xml = simplexml_load_file(""users.xml"");",False,False,,"```xml
<Issues>
  <Issue>
    <Type>Security</Type>
    <Weakness>CWE-643</Weakness>
    <Description>Improper Neutralization of Data within XPath Expressions ('XPath Injection')</Description>
    <Severity>High</Severity>
    <File>File 1</File>
    <Code>$query = sprintf(""


$xml = simplexml_load_file(""users.xml"");
echo ""query : "". $query .""&lt;br /&gt;&lt;br /&gt;"" ;

$res=$xml->xpath($query);
print_r($res);</Code>
    <Justification>The code uses user-controlled input ($tainted) to construct an XPath query without proper neutralization. This allows an attacker to control the structure of the query and potentially extract sensitive information or manipulate the XML data.  Even though the input is sanitized, the FILTER_SANITIZE_FULL_SPECIAL_CHARS is insufficient to prevent XPath injection.</Justification>
  </Issue>
  <Issue>
    <Type>Reliability</Type>
    <Weakness>CWE-252</Weakness>
    <Description>Unchecked Return Value</Description>
    <Severity>Medium</Severity>
    <File>File 1</File>
    <Code>if(($tainted = fgets($handle, 4096)) == false) {
    $tainted = """";
  }
  fclose($handle);
} else {
  $tainted = """";
}</Code>
    <Justification>The code checks if fgets returns false, but it doesn't check for other possible errors during file reading.  fgets can return false if there's an error, or if the end of the file is reached before any data is read. The code should handle all possible error conditions to ensure reliable operation.</Justification>
  </Issue>
  <Issue>
    <Type>Reliability</Type>
    <Weakness>CWE-703</Weakness>
    <Description>Improper Check or Handling of Exceptional Conditions</Description>
    <Severity>Low</Severity>
    <File>File 1</File>
    <Code>$handle = @fopen(""/tmp/tainted.txt"", ""r"");</Code>
    <Justification>The code uses the error suppression operator `@` before `fopen`. While this prevents error messages from being displayed, it also means that the code doesn't explicitly handle the case where `fopen` fails. The subsequent `if ($handle)` check is a form of error handling, but it's better to avoid suppressing errors in the first place and handle them more explicitly, potentially logging the error or taking corrective action.</Justification>
  </Issue>
</Issues>
```"
CWE-79,src/CWE_79__backticks__no_sanitizing__Unsafe_use_untrusted_data-style.php,"<!-- 
Unsafe sample
input : backticks interpretation, reading the file /tmp/tainted.txt
sanitize : none
File : unsafe, use of untrusted data in CSS
-->

<!--Copyright 2015 Bertrand STIVALET 

Permission is hereby granted, without written agreement or royalty fee, to

use, copy, modify, and distribute this software and its documentation for

any purpose, provided that the above copyright notice and the following

three paragraphs appear in all copies of this software.


IN NO EVENT SHALL AUTHORS BE LIABLE TO ANY PARTY FOR DIRECT,

INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES ARISING OUT OF THE 

USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF AUTHORS HAVE

BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.


AUTHORS SPECIFICALLY DISCLAIM ANY WARRANTIES INCLUDING, BUT NOT

LIMITED TO THE IMPLIED WARRANTIES OF MERCHANTABILITY, FITNESS FOR A

PARTICULAR PURPOSE, AND NON-INFRINGEMENT.


THE SOFTWARE IS PROVIDED ON AN ""AS-IS"" BASIS AND AUTHORS HAVE NO

OBLIGATION TO PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR

MODIFICATIONS.-->


<!DOCTYPE html>
<html>
<head>
<style>
<?php
$tainted = `cat /tmp/tainted.txt`;




echo $tainted ;
?>
</style>
</head>
<body>
<h1>Hello World!</h1>
</body>
</html>",echo $tainted ;,True,True,echo $tainted ;,"```xml
<Issues>
  <Issue>
    <Type>Security</Type>
    <Weakness>CWE-77</Weakness>
    <Description>Improper Neutralization of Special Elements used in a Command ('Command Injection')</Description>
    <Severity>High</Severity>
    <File>File 1</File>
    <Code>$tainted = `cat /tmp/tainted.txt`;</Code>
    <Justification>The code uses backticks to execute a shell command (`cat /tmp/tainted.txt`). This is equivalent to using `shell_exec()`. If the content of `/tmp/tainted.txt` is controlled by a malicious user, they could inject arbitrary commands to be executed on the server.</Justification>
  </Issue>
  <Issue>
    <Type>Security</Type>
    <Weakness>CWE-79</Weakness>
    <Description>Improper Neutralization of Input During Web Page Generation ('Cross-site Scripting')</Description>
    <Severity>Medium</Severity>
    <File>File 1</File>
    <Code>echo $tainted ;</Code>
    <Justification>The code directly echoes the value of `$tainted` into the CSS style block without any sanitization. If `$tainted` contains malicious CSS or JavaScript code, it will be executed in the user's browser, leading to XSS.</Justification>
  </Issue>
</Issues>
```"
CWE-79,src/CWE_79__POST__func_preg_replace__Use_untrusted_data_attribute-unquoted_Attr.php,"<!-- 
Unsafe sample
input : get the field UserData from the variable $_POST
SANITIZE : use of preg_replace
File : use of untrusted data in a unquoted attribute
-->

<!--Copyright 2015 Bertrand STIVALET 

Permission is hereby granted, without written agreement or royalty fee, to

use, copy, modify, and distribute this software and its documentation for

any purpose, provided that the above copyright notice and the following

three paragraphs appear in all copies of this software.


IN NO EVENT SHALL AUTHORS BE LIABLE TO ANY PARTY FOR DIRECT,

INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES ARISING OUT OF THE 

USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF AUTHORS HAVE

BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.


AUTHORS SPECIFICALLY DISCLAIM ANY WARRANTIES INCLUDING, BUT NOT

LIMITED TO THE IMPLIED WARRANTIES OF MERCHANTABILITY, FITNESS FOR A

PARTICULAR PURPOSE, AND NON-INFRINGEMENT.


THE SOFTWARE IS PROVIDED ON AN ""AS-IS"" BASIS AND AUTHORS HAVE NO

OBLIGATION TO PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR

MODIFICATIONS.-->


<!DOCTYPE html>
<html>
<head/>
<body>
<?php
$tainted = $_POST['UserData'];

$tainted = preg_replace('/\'/', '', $tainted);


echo ""<div id="". $tainted ."">content</div>"" ;
?>
<h1>Hello World!</h1>
</body>
</html>","echo ""<div id="". $tainted ."">content</div>"" ;",True,True,"echo ""<div id="". $tainted ."">content</div>"" ;","```xml
<Issues>
  <Issue>
    <Type>Security</Type>
    <Weakness>CWE-79</Weakness>
    <Description>Improper Neutralization of Input During Web Page Generation ('Cross-site Scripting')</Description>
    <Severity>Medium</Severity>
    <File>File 1</File>
    <Code>echo ""&lt;div id="". $tainted ."">content&lt;/div>"" ;</Code>
    <Justification>The code directly outputs user-controlled input ($tainted) into an HTML attribute without proper escaping. Although the code attempts to sanitize the input by removing single quotes, this is insufficient to prevent XSS attacks. An attacker can inject arbitrary HTML or JavaScript code by crafting an input that contains other special characters or HTML entities that are not neutralized by the preg_replace function.</Justification>
  </Issue>
</Issues>
```"
CWE-90,src/CWE_90__shell_exec__func_htmlentities__name-concatenation_simple_quote.php,"<?php







$tainted = shell_exec('cat /tmp/tainted.txt');

$tainted = htmlentities($tainted, ENT_QUOTES);

$query = ""name='"". $tainted . ""'"";


$ds=ldap_connect(""localhost""); 
$r=ldap_bind($ds);
$sr=ldap_search($ds,""o=My Company, c=US"", $query);  
ldap_close($ds);

?>","$ds=ldap_connect(""localhost"");",True,True,"$tainted = shell_exec('cat /tmp/tainted.txt');

$tainted = htmlentities($tainted, ENT_QUOTES);

$query = ""name='"". $tainted . ""'"";


$ds=ldap_connect(""localhost""); 
$r=ldap_bind($ds);
$sr=ldap_search($ds,""o=My Company, c=US"", $query);  
ldap_close($ds);","```xml
<Issues>
  <Issue>
    <Type>Security</Type>
    <Weakness>CWE-90</Weakness>
    <Description>Improper Neutralization of Special Elements used in an LDAP Query ('LDAP Injection')</Description>
    <Severity>High</Severity>
    <File>File 1</File>
    <Code>$tainted = shell_exec('cat /tmp/tainted.txt');

$tainted = htmlentities($tainted, ENT_QUOTES);

$query = ""name='"". $tainted . ""'"";


$ds=ldap_connect(""localhost""); 
$r=ldap_bind($ds);
$sr=ldap_search($ds,""o=My Company, c=US"", $query);  
ldap_close($ds);</Code>
    <Justification>The code constructs an LDAP query by directly embedding user-controlled data (obtained from the tainted variable) into the query string. Although htmlentities is used, it may not be sufficient to prevent LDAP injection attacks, as certain special characters relevant to LDAP syntax may not be properly neutralized. This allows an attacker to potentially modify the LDAP query and gain unauthorized access to information or perform malicious operations.</Justification>
  </Issue>
  <Issue>
    <Type>Security</Type>
    <Weakness>CWE-77</Weakness>
    <Description>Improper Neutralization of Special Elements used in a Command ('Command Injection')</Description>
    <Severity>High</Severity>
    <File>File 1</File>
    <Code>$tainted = shell_exec('cat /tmp/tainted.txt');</Code>
    <Justification>The code uses shell_exec to execute the command 'cat /tmp/tainted.txt'. If the content of /tmp/tainted.txt is influenced by an attacker, they could inject arbitrary commands into the shell, leading to command injection vulnerability. The attacker could potentially execute arbitrary commands on the system with the privileges of the web server user.</Justification>
  </Issue>
</Issues>
```"
