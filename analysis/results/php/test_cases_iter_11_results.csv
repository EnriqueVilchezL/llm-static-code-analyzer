Test Case Weakness,Test Case File,Test Case Code,Test Case Line,LLM Hit CWE,LLM Hit Code,LLM Code,LLM Complete Response
CWE-79,src/CWE_79__GET__func_preg_replace__Use_untrusted_data-body.php,"<!-- 
Unsafe sample
input : reads the field UserData from the variable $_GET
SANITIZE : use of preg_replace
File : use of untrusted data in the body
-->

<!--Copyright 2015 Bertrand STIVALET 

Permission is hereby granted, without written agreement or royalty fee, to

use, copy, modify, and distribute this software and its documentation for

any purpose, provided that the above copyright notice and the following

three paragraphs appear in all copies of this software.


IN NO EVENT SHALL AUTHORS BE LIABLE TO ANY PARTY FOR DIRECT,

INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES ARISING OUT OF THE 

USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF AUTHORS HAVE

BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.


AUTHORS SPECIFICALLY DISCLAIM ANY WARRANTIES INCLUDING, BUT NOT

LIMITED TO THE IMPLIED WARRANTIES OF MERCHANTABILITY, FITNESS FOR A

PARTICULAR PURPOSE, AND NON-INFRINGEMENT.


THE SOFTWARE IS PROVIDED ON AN ""AS-IS"" BASIS AND AUTHORS HAVE NO

OBLIGATION TO PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR

MODIFICATIONS.-->


<!DOCTYPE html>
<html>
<head/>
<body>
<?php
$tainted = $_GET['UserData'];

$tainted = preg_replace('/\'/', '', $tainted);


echo $tainted ;
?>
<h1>Hello World!</h1>
</body>
</html>
",echo $tainted ;,True,True,"<?php
$tainted = $_GET['UserData'];

$tainted = preg_replace('/\'/', '', $tainted);


echo $tainted ;
?>","```xml
<Issues>
  <Issue>
    <Type>Security</Type>
    <Weakness>CWE-79</Weakness>
    <Description>Improper Neutralization of Input During Web Page Generation ('Cross-site Scripting')</Description>
    <Severity>Medium</Severity>
    <File>File 1</File>
    <Code>&lt;?php
$tainted = $_GET['UserData'];

$tainted = preg_replace('/\'/', '', $tainted);


echo $tainted ;
?&gt;</Code>
    <Justification>The code retrieves user input from $_GET['UserData'], sanitizes it using preg_replace to remove single quotes, and then directly echoes the sanitized input. While the single quote removal provides some sanitization, it's insufficient to prevent XSS vulnerabilities.  An attacker could inject other HTML or JavaScript code that would be executed in the user's browser.</Justification>
  </Issue>
</Issues>
```"
CWE-79,src/CWE_79__system__func_FILTER-VALIDATION-number_float_filter__Unsafe_use_untrusted_data-tag_Name.php,"<!-- 
Unsafe sample
input : execute a ls command using the function system, and put the last result in $tainted
Flushes content of $sanitized if the filter number_float_filter is not applied
File : unsafe, use of untrusted data in an tag name
-->

<!--Copyright 2015 Bertrand STIVALET 

Permission is hereby granted, without written agreement or royalty fee, to

use, copy, modify, and distribute this software and its documentation for

any purpose, provided that the above copyright notice and the following

three paragraphs appear in all copies of this software.


IN NO EVENT SHALL AUTHORS BE LIABLE TO ANY PARTY FOR DIRECT,

INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES ARISING OUT OF THE 

USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF AUTHORS HAVE

BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.


AUTHORS SPECIFICALLY DISCLAIM ANY WARRANTIES INCLUDING, BUT NOT

LIMITED TO THE IMPLIED WARRANTIES OF MERCHANTABILITY, FITNESS FOR A

PARTICULAR PURPOSE, AND NON-INFRINGEMENT.


THE SOFTWARE IS PROVIDED ON AN ""AS-IS"" BASIS AND AUTHORS HAVE NO

OBLIGATION TO PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR

MODIFICATIONS.-->


<!DOCTYPE html>
<html>
<head/>
<body>
<?php
$tainted = system('ls', $retval);

if (filter_var($sanitized, FILTER_VALIDATE_FLOAT))
  $tainted = $sanitized ;
else
  $tainted = """" ;


echo ""<"".  $tainted ."" href= \""/bob\"" />"" ;
?>
<h1>Hello World!</h1>
</body>
</html>","echo ""<"".  $tainted ."" href= \""/bob\"" />"" ;",True,True,"echo ""<"".  $tainted ."" href= \""/bob\"" />"" ;","```xml
<Issues>
  <Issue>
    <Type>Security</Type>
    <Weakness>CWE-77</Weakness>
    <Description>Improper Neutralization of Special Elements used in a Command ('Command Injection')</Description>
    <Severity>High</Severity>
    <File>File 1</File>
    <Code>$tainted = system('ls', $retval);</Code>
    <Justification>The code uses the `system()` function to execute an external command ('ls'). While the command itself is harmless, the broader risk lies in potentially allowing a user-controlled or influenced input to be used as part of the command in other contexts. This can lead to command injection vulnerabilities if not properly sanitized.</Justification>
  </Issue>
  <Issue>
    <Type>Security</Type>
    <Weakness>CWE-79</Weakness>
    <Description>Improper Neutralization of Input During Web Page Generation ('Cross-site Scripting')</Description>
    <Severity>High</Severity>
    <File>File 1</File>
    <Code>echo ""&lt;"".  $tainted ."" href= \""/bob\"" /&gt;"" ;</Code>
    <Justification>The code directly outputs the `$tainted` variable, which is derived from the `system()` function's output (or an empty string), into the HTML without proper sanitization.  If the output of `system('ls', $retval)` contains HTML metacharacters or JavaScript, it could lead to XSS vulnerabilities.</Justification>
  </Issue>
</Issues>
```"
CWE-89,src/CWE_89__object-classicGet__func_FILTER-CLEANING-full_special_chars_filter__join-sprintf_%s_simple_quote.php,"<?php







class Input{
  private $input;

  public function getInput(){
    return $this->input;
  }

  public  function __construct(){
   $this->input = $_GET['UserData'] ;
  }
}
$temp = new Input();
$tainted =  $temp->getInput();

$sanitized = filter_var($tainted, FILTER_SANITIZE_FULL_SPECIAL_CHARS);
  $tainted = $sanitized ;
     

$query = sprintf(""SELECT lastname, firstname FROM drivers, vehicles WHERE drivers.id = vehicles.ownerid AND vehicles.tag='%s'"", $tainted);


$conn = mysql_connect('localhost', 'mysql_user', 'mysql_password'); 
mysql_select_db('dbname') ;
echo ""query : "". $query .""<br /><br />"" ;

$res = mysql_query($query); 

while($data =mysql_fetch_array($res)){
print_r($data) ;
echo ""<br />"" ;
} 
mysql_close($conn);

?>","$conn = mysql_connect('localhost', 'mysql_user', 'mysql_password'); ",True,False,"$query = sprintf(""SELECT lastname, firstname FROM drivers, vehicles WHERE drivers.id = vehicles.ownerid AND vehicles.tag='%s'"", $tainted);","```xml
<Issues>
  <Issue>
    <Type>Security</Type>
    <Weakness>CWE-89</Weakness>
    <Description>Improper Neutralization of Special Elements used in an SQL Command ('SQL Injection')</Description>
    <Severity>High</Severity>
    <File>File 1</File>
    <Code>$query = sprintf(""SELECT lastname, firstname FROM drivers, vehicles WHERE drivers.id = vehicles.ownerid AND vehicles.tag='%s'"", $tainted);</Code>
    <Justification>The code uses sprintf to construct a SQL query, directly embedding the $tainted variable, even after sanitization. While FILTER_SANITIZE_FULL_SPECIAL_CHARS encodes characters like &lt;, &gt;, &amp;, "", and ', it does not prevent all forms of SQL injection, particularly if the database encoding is different or if other special characters are used that are not handled by the filter. This could allow an attacker to manipulate the query.</Justification>
  </Issue>
  <Issue>
    <Type>Security</Type>
    <Weakness>CWE-477</Weakness>
    <Description>Use of Obsolete Function</Description>
    <Severity>Low</Severity>
    <File>File 1</File>
    <Code>$conn = mysql_connect('localhost', 'mysql_user', 'mysql_password'); 
mysql_select_db('dbname') ;
echo ""query : "". $query .""&lt;br /&gt;&lt;br /&gt;"" ;

$res = mysql_query($query); </Code>
    <Justification>The code uses the mysql_connect and mysql_query functions, which are deprecated. These functions are no longer maintained and have known security issues.  Using mysqli or PDO is recommended.</Justification>
  </Issue>
  <Issue>
    <Type>Reliability</Type>
    <Weakness>CWE-252</Weakness>
    <Description>Unchecked Return Value</Description>
    <Severity>Medium</Severity>
    <File>File 1</File>
    <Code>$conn = mysql_connect('localhost', 'mysql_user', 'mysql_password'); 
mysql_select_db('dbname') ;
echo ""query : "". $query .""&lt;br /&gt;&lt;br /&gt;"" ;

$res = mysql_query($query); </Code>
    <Justification>The code does not check the return value of mysql_connect or mysql_query. If the connection fails or the query is invalid, these functions will return false, which can lead to further errors if not handled.</Justification>
  </Issue>
  <Issue>
    <Type>Security</Type>
    <Weakness>CWE-798</Weakness>
    <Description>Use of Hard-coded Credentials</Description>
    <Severity>Critical</Severity>
    <File>File 1</File>
    <Code>$conn = mysql_connect('localhost', 'mysql_user', 'mysql_password'); </Code>
    <Justification>The code uses hard-coded credentials ('mysql_user', 'mysql_password') to connect to the database.  This is a critical security vulnerability because anyone with access to the source code can gain access to the database.</Justification>
  </Issue>
</Issues>
```"
CWE-91,src/CWE_91__object-directGet__no_sanitizing__data-concatenation_simple_quote.php,"<?php







class Input{
  public function getInput(){
    return $_GET['UserData'] ;
  }
}

$temp = new Input();
$tainted =  $temp->getInput();



$query = ""'"". $tainted . ""'"";


$xml = simplexml_load_file(""users.xml"");
echo ""query : "". $query .""<br /><br />"" ;

$res=$xml->xpath($query);
print_r($res);
echo ""<br />"" ;

?>","$xml = simplexml_load_file(""users.xml"");",False,False,,"```xml
<Issues>
  <Issue>
    <Type>Security</Type>
    <Weakness>CWE-643</Weakness>
    <Description>Improper Neutralization of Data within XPath Expressions ('XPath Injection')</Description>
    <Severity>High</Severity>
    <File>File 1</File>
    <Code>$xml = simplexml_load_file(""users.xml"");
echo ""query : "". $query .""&lt;br /&gt;&lt;br /&gt;"" ;

$res=$xml->xpath($query);</Code>
    <Justification>The code uses user-supplied data to construct an XPath query without proper sanitization. An attacker could manipulate the input to inject malicious XPath code, potentially extracting sensitive information or performing unauthorized actions on the XML data.</Justification>
  </Issue>
  <Issue>
    <Type>Reliability</Type>
    <Weakness>CWE-252</Weakness>
    <Description>Unchecked Return Value</Description>
    <Severity>Medium</Severity>
    <File>File 1</File>
    <Code>$xml = simplexml_load_file(""users.xml"");
echo ""query : "". $query .""&lt;br /&gt;&lt;br /&gt;"" ;

$res=$xml->xpath($query);</Code>
    <Justification>The code does not check the return value of simplexml_load_file. If the file is not loaded correctly it can lead to an error and stop the execution of the program.</Justification>
  </Issue>
</Issues>
```"
CWE-79,src/CWE_79__fopen__func_preg_replace__Use_untrusted_data_script-doublequoted_String.php,"<!-- 
Unsafe sample
input : use fopen to read /tmp/tainted.txt and put the first line in $tainted
SANITIZE : use of preg_replace
File : use of untrusted data in a double quoted string in a script
-->

<!--Copyright 2015 Bertrand STIVALET 

Permission is hereby granted, without written agreement or royalty fee, to

use, copy, modify, and distribute this software and its documentation for

any purpose, provided that the above copyright notice and the following

three paragraphs appear in all copies of this software.


IN NO EVENT SHALL AUTHORS BE LIABLE TO ANY PARTY FOR DIRECT,

INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES ARISING OUT OF THE 

USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF AUTHORS HAVE

BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.


AUTHORS SPECIFICALLY DISCLAIM ANY WARRANTIES INCLUDING, BUT NOT

LIMITED TO THE IMPLIED WARRANTIES OF MERCHANTABILITY, FITNESS FOR A

PARTICULAR PURPOSE, AND NON-INFRINGEMENT.


THE SOFTWARE IS PROVIDED ON AN ""AS-IS"" BASIS AND AUTHORS HAVE NO

OBLIGATION TO PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR

MODIFICATIONS.-->


<!DOCTYPE html>
<html>
<head>
<script>
<?php
$handle = @fopen(""/tmp/tainted.txt"", ""r"");

if ($handle) {
  if(($tainted = fgets($handle, 4096)) == false) {
    $tainted = """";
  }
  fclose($handle);
} else {
  $tainted = """";
}

$tainted = preg_replace('/\'/', '', $tainted);


echo ""alert(\"""". $tainted .""\"")"" ;
?>
</script>
</head>
<body>
<h1>Hello World!</h1>
</body>
</html>","echo ""alert(\"""". $tainted .""\"")"" ;",True,True,"echo ""alert(\"""". $tainted .""\"")"" ;","```xml
<Issues>
  <Issue>
    <Type>Security</Type>
    <Weakness>CWE-79</Weakness>
    <Description>Improper Neutralization of Input During Web Page Generation ('Cross-site Scripting')</Description>
    <Severity>Medium</Severity>
    <File>File 1</File>
    <Code>
echo ""alert(\"""". $tainted .""\"")"" ;</Code>
    <Justification>The code echoes user-controlled data ($tainted) directly into a JavaScript alert function within a double-quoted string. While the code attempts to sanitize single quotes using preg_replace, it doesn't address other characters that could be used to inject malicious JavaScript code (e.g., double quotes to break out of the string, or angle brackets to inject HTML tags). This can lead to XSS vulnerabilities.</Justification>
  </Issue>
  <Issue>
    <Type>Reliability</Type>
    <Weakness>CWE-252</Weakness>
    <Description>Unchecked Return Value</Description>
    <Severity>Low</Severity>
    <File>File 1</File>
    <Code>
  if(($tainted = fgets($handle, 4096)) == false) {
    $tainted = """";
  }
  fclose($handle);</Code>
    <Justification>The code uses the return value of fgets and fclose but doesn't check for errors after the initial check. While it checks if fgets returns false, indicating an error or end of file, it doesn't handle potential errors during fclose, which could lead to resource leaks or other unexpected behavior if the file cannot be closed properly.</Justification>
  </Issue>
  <Issue>
    <Type>Security</Type>
    <Weakness>CWE-434</Weakness>
    <Description>Unrestricted Upload of File with Dangerous Type</Description>
    <Severity>Low</Severity>
    <File>File 1</File>
    <Code>$handle = @fopen(""/tmp/tainted.txt"", ""r"");</Code>
    <Justification>The code reads from a file located at `/tmp/tainted.txt`. While not an upload, if an attacker can control the contents of this file without restrictions, they could insert potentially malicious content that, when used in subsequent operations, can lead to security vulnerabilities such as XSS or command injection.</Justification>
  </Issue>
</Issues>
```"
CWE-91,src/CWE_91__fopen__func_FILTER-VALIDATION-email_filter__data-interpretation_simple_quote.php,"<?php







$handle = @fopen(""/tmp/tainted.txt"", ""r"");

if ($handle) {
  if(($tainted = fgets($handle, 4096)) == false) {
    $tainted = """";
  }
  fclose($handle);
} else {
  $tainted = """";
}

if (filter_var($sanitized, FILTER_VALIDATE_EMAIL))
  $tainted = $sanitized ;
else
  $tainted = """" ;

$query = ""' $tainted '"";


$xml = simplexml_load_file(""users.xml"");
echo ""query : "". $query .""<br /><br />"" ;

$res=$xml->xpath($query);
print_r($res);
echo ""<br />"" ;

?>","$xml = simplexml_load_file(""users.xml"");",False,False,,"```xml
<Issues>
  <Issue>
    <Type>Security</Type>
    <Weakness>CWE-78</Weakness>
    <Description>Improper Neutralization of Special Elements used in a Command ('Command Injection')</Description>
    <Severity>High</Severity>
    <File>File 1</File>
    <Code>$query = ""' $tainted '"";


$xml = simplexml_load_file(""users.xml"");
echo ""query : "". $query .""&lt;br /&gt;&lt;br /&gt;"" ;

$res=$xml->xpath($query);</Code>
    <Justification>The code constructs an XPath query using unsanitized input ($tainted) and executes it using simplexml_load_file and xpath. This allows an attacker to inject malicious XPath expressions, potentially gaining unauthorized access to data or executing arbitrary code.</Justification>
  </Issue>
  <Issue>
    <Type>Reliability</Type>
    <Weakness>CWE-252</Weakness>
    <Description>Unchecked Return Value</Description>
    <Severity>Medium</Severity>
    <File>File 1</File>
    <Code>$handle = @fopen(""/tmp/tainted.txt"", ""r"");

if ($handle) {
  if(($tainted = fgets($handle, 4096)) == false) {
    $tainted = """";
  }
  fclose($handle);</Code>
    <Justification>The code uses @fopen to suppress errors, and then proceeds without checking if fopen actually returned a valid file handle. If fopen fails (e.g., due to permission issues), $handle will be false, and subsequent operations on $handle will lead to errors or unexpected behavior. fgets could also return false and is not checked.</Justification>
  </Issue>
  <Issue>
    <Type>Security</Type>
    <Weakness>CWE-434</Weakness>
    <Description>Unrestricted Upload of File with Dangerous Type</Description>
    <Severity>Medium</Severity>
    <File>File 1</File>
    <Code>$handle = @fopen(""/tmp/tainted.txt"", ""r"");</Code>
    <Justification>The code reads data from /tmp/tainted.txt, and this file could be uploaded without any sanitization. If it is uploaded with malicious code (php file), it will compromise the system.</Justification>
  </Issue>
  <Issue>
    <Type>Reliability</Type>
    <Weakness>CWE-703</Weakness>
    <Description>Improper Check or Handling of Exceptional Conditions</Description>
    <Severity>Low</Severity>
    <File>File 1</File>
    <Code>if (filter_var($sanitized, FILTER_VALIDATE_EMAIL))
  $tainted = $sanitized ;
else
  $tainted = """" ;</Code>
    <Justification>The filter_var function is used but the variable $sanitized is not initialized, so the filter does not function. This can lead to unexpected behavior of the filter when deployed.</Justification>
  </Issue>
</Issues>
```"
CWE-90,src/CWE_90__POST__func_htmlentities__name-sprintf_%s_simple_quote.php,"<?php







$tainted = $_POST['UserData'];

$tainted = htmlentities($tainted, ENT_QUOTES);

$query = sprintf(""name='%s'"", $tainted);


$ds=ldap_connect(""localhost""); 
$r=ldap_bind($ds);
$sr=ldap_search($ds,""o=My Company, c=US"", $query);  
ldap_close($ds);

?>","$ds=ldap_connect(""localhost"");",True,True,"$tainted = $_POST['UserData'];

$tainted = htmlentities($tainted, ENT_QUOTES);

$query = sprintf(""name='%s'"", $tainted);


$ds=ldap_connect(""localhost""); 
$r=ldap_bind($ds);
$sr=ldap_search($ds,""o=My Company, c=US"", $query);  
ldap_close($ds);","```xml
<Issues>
  <Issue>
    <Type>Security</Type>
    <Weakness>CWE-90</Weakness>
    <Description>Improper Neutralization of Special Elements used in an LDAP Query ('LDAP Injection')</Description>
    <Severity>High</Severity>
    <File>File 1</File>
    <Code>$tainted = $_POST['UserData'];

$tainted = htmlentities($tainted, ENT_QUOTES);

$query = sprintf(""name='%s'"", $tainted);


$ds=ldap_connect(""localhost""); 
$r=ldap_bind($ds);
$sr=ldap_search($ds,""o=My Company, c=US"", $query);  
ldap_close($ds);</Code>
    <Justification>The code constructs an LDAP query using unsanitized user-provided data ($tainted), which can lead to LDAP injection vulnerabilities. Although htmlentities is used, it is not sufficient to prevent all types of LDAP injection attacks. An attacker could potentially inject arbitrary LDAP commands.</Justification>
  </Issue>
</Issues>
```"
CWE-78,src/CWE_78__POST__func_FILTER-VALIDATION-email_filter__cat-interpretation_simple_quote.php,"<?php







$tainted = $_POST['UserData'];

if (filter_var($sanitized, FILTER_VALIDATE_EMAIL))
  $tainted = $sanitized ;
else
  $tainted = """" ;

$query = ""cat ' $tainted '"";


$ret = system($query);


?>",$ret = system($query);,True,True,"$tainted = $_POST['UserData'];

if (filter_var($sanitized, FILTER_VALIDATE_EMAIL))
  $tainted = $sanitized ;
else
  $tainted = """" ;

$query = ""cat ' $tainted '"";


$ret = system($query);","```xml
<Issues>
  <Issue>
    <Type>Security</Type>
    <Weakness>CWE-78</Weakness>
    <Description>Improper Neutralization of Special Elements used in an OS Command ('OS Command Injection')</Description>
    <Severity>High</Severity>
    <File>File 1</File>
    <Code>$tainted = $_POST['UserData'];

if (filter_var($sanitized, FILTER_VALIDATE_EMAIL))
  $tainted = $sanitized ;
else
  $tainted = """" ;

$query = ""cat ' $tainted '"";


$ret = system($query);</Code>
    <Justification>The code is vulnerable to OS command injection because it uses user-supplied data ($tainted) directly within a system call without proper sanitization.  Even with the attempt to filter email, a crafted input could still inject commands.</Justification>
  </Issue>
  <Issue>
    <Type>Reliability</Type>
    <Weakness>CWE-252</Weakness>
    <Description>Unchecked Return Value</Description>
    <Severity>Low</Severity>
    <File>File 1</File>
    <Code>$ret = system($query);</Code>
    <Justification>The return value of the `system()` call is not checked. This could lead to undetected errors if the command fails to execute properly.</Justification>
  </Issue>
</Issues>
```"
CWE-79,src/CWE_79__shell_exec__whitelist_using_array__Use_untrusted_data_script-window_SetInterval.php,"<!-- 
Unsafe sample
input : use shell_exec to cat /tmp/tainted.txt
SANITIZE : use in_array to check if $tainted is in the white list
File : unsafe, use of untrusted data in the function setInterval
-->

<!--Copyright 2015 Bertrand STIVALET 

Permission is hereby granted, without written agreement or royalty fee, to

use, copy, modify, and distribute this software and its documentation for

any purpose, provided that the above copyright notice and the following

three paragraphs appear in all copies of this software.


IN NO EVENT SHALL AUTHORS BE LIABLE TO ANY PARTY FOR DIRECT,

INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES ARISING OUT OF THE 

USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF AUTHORS HAVE

BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.


AUTHORS SPECIFICALLY DISCLAIM ANY WARRANTIES INCLUDING, BUT NOT

LIMITED TO THE IMPLIED WARRANTIES OF MERCHANTABILITY, FITNESS FOR A

PARTICULAR PURPOSE, AND NON-INFRINGEMENT.


THE SOFTWARE IS PROVIDED ON AN ""AS-IS"" BASIS AND AUTHORS HAVE NO

OBLIGATION TO PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR

MODIFICATIONS.-->


<!DOCTYPE html>
<html>
<head>
<script>
<?php
$tainted = shell_exec('cat /tmp/tainted.txt');

$legal_table = array(""safe1"", ""safe2"");
if (in_array($tainted, $legal_table, true)) {
  $tainted = $tainted;
} else {
  $tainted = $legal_table[0];
}


echo ""window.setInterval('"". $tainted .""');"" ;
?>
 </script>
</head>
<body>
<h1>Hello World!</h1>
</body>
</html>","echo ""window.setInterval('"". $tainted .""');"" ;",True,True,"echo ""window.setInterval('"". $tainted .""');"" ;","```xml
<Issues>
  <Issue>
    <Type>Security</Type>
    <Weakness>CWE-77</Weakness>
    <Description>Improper Neutralization of Special Elements used in a Command ('Command Injection')</Description>
    <Severity>High</Severity>
    <File>File 1</File>
    <Code>$tainted = shell_exec('cat /tmp/tainted.txt');</Code>
    <Justification>The code uses shell_exec to execute a command based on a fixed string with `cat /tmp/tainted.txt`. While the command itself is fixed, the content of the `/tmp/tainted.txt` file is uncontrolled and can be influenced by an attacker, potentially injecting malicious commands.</Justification>
  </Issue>
  <Issue>
    <Type>Security</Type>
    <Weakness>CWE-79</Weakness>
    <Description>Improper Neutralization of Input During Web Page Generation ('Cross-site Scripting')</Description>
    <Severity>High</Severity>
    <File>File 1</File>
    <Code>echo ""window.setInterval('"". $tainted .""');"" ;</Code>
    <Justification>The code embeds the `$tainted` variable directly into Javascript code within a setInterval function. Even though the `$tainted` variable is sanitized using in_array to compare it to a whitelist of safe values, the `setInterval` function can still be vulnerable to XSS if the values in the `$legal_table` contain malicious javascript code themselves, like alerts, or any other javascript that could be used for Cross Site Scripting</Justification>
  </Issue>
</Issues>
```"
CWE-89,src/CWE_89__object-Array__func_preg_match-no_filtering__join-interpretation_simple_quote.php,"<?php







class Input{
  private $input;

  public function getInput(){
    return $this->input[1];
  }

  public  function __construct(){
    $this->input = array();
    $this->input[0]= 'safe' ;
    $this->input[1]= $_GET['UserData'] ;
    $this->input[2]= 'safe' ;
  }
}
$temp = new Input();
$tainted =  $temp->getInput();

$re = ""/^.*$/"";
if(preg_match($re, $tainted) == 1){
  $tainted = $tainted;
}
else{
  $tainted = """";
}

$query = ""SELECT lastname, firstname FROM drivers, vehicles WHERE drivers.id = vehicles.ownerid AND vehicles.tag=' $tainted '"";


$conn = mysql_connect('localhost', 'mysql_user', 'mysql_password'); 
mysql_select_db('dbname') ;
echo ""query : "". $query .""<br /><br />"" ;

$res = mysql_query($query); 

while($data =mysql_fetch_array($res)){
print_r($data) ;
echo ""<br />"" ;
} 
mysql_close($conn);

?>","$conn = mysql_connect('localhost', 'mysql_user', 'mysql_password'); ",True,False,"$query = ""SELECT lastname, firstname FROM drivers, vehicles WHERE drivers.id = vehicles.ownerid AND vehicles.tag=' $tainted '"";","```xml
<Issues>
  <Issue>
    <Type>Security</Type>
    <Weakness>CWE-89</Weakness>
    <Description>Improper Neutralization of Special Elements used in an SQL Command ('SQL Injection')</Description>
    <Severity>High</Severity>
    <File>File 1</File>
    <Code>$query = ""SELECT lastname, firstname FROM drivers, vehicles WHERE drivers.id = vehicles.ownerid AND vehicles.tag=' $tainted '"";</Code>
    <Justification>The code constructs a SQL query by directly embedding user-controlled input ($tainted) into the query string.  Even though a regular expression is used, it matches any characters. This allows for SQL injection attacks where an attacker can manipulate the query to extract, modify, or delete data.</Justification>
  </Issue>
  <Issue>
    <Type>Reliability</Type>
    <Weakness>CWE-252</Weakness>
    <Description>Unchecked Return Value</Description>
    <Severity>Medium</Severity>
    <File>File 1</File>
    <Code>$conn = mysql_connect('localhost', 'mysql_user', 'mysql_password');</Code>
    <Justification>The code does not check the return value of mysql_connect. If the connection fails, $conn will be false, and subsequent operations on $conn will cause errors.</Justification>
  </Issue>
  <Issue>
    <Type>Reliability</Type>
    <Weakness>CWE-252</Weakness>
    <Description>Unchecked Return Value</Description>
    <Severity>Medium</Severity>
    <File>File 1</File>
    <Code>$res = mysql_query($query);</Code>
    <Justification>The code does not check the return value of mysql_query. If the query fails, $res will be false, and subsequent operations on $res will cause errors.</Justification>
  </Issue>
  <Issue>
    <Type>Maintainability</Type>
    <Weakness>CWE-477</Weakness>
    <Description>Use of Obsolete Function</Description>
    <Severity>Low</Severity>
    <File>File 1</File>
    <Code>$conn = mysql_connect('localhost', 'mysql_user', 'mysql_password');
mysql_select_db('dbname') ;
$res = mysql_query($query);</Code>
    <Justification>The code uses the mysql_connect, mysql_select_db, and mysql_query functions, which are deprecated. These functions are no longer maintained and can lead to security vulnerabilities and compatibility issues in the future. It's better to use the improved mysqli or PDO extensions.</Justification>
  </Issue>
  <Issue>
    <Type>Security</Type>
    <Weakness>CWE-798</Weakness>
    <Description>Use of Hard-coded Credentials</Description>
    <Severity>Critical</Severity>
    <File>File 1</File>
    <Code>$conn = mysql_connect('localhost', 'mysql_user', 'mysql_password');</Code>
    <Justification>The code uses hard-coded credentials (username and password) to connect to the database. This is a critical security vulnerability as anyone with access to the code can potentially gain unauthorized access to the database.</Justification>
  </Issue>
</Issues>
```"
CWE-78,src/CWE_78__exec__no_sanitizing__ls-concatenation_simple_quote.php,"<?php







$script = ""/tmp/tainted.php"";
exec($script, $result, $return);

$tainted = $result[0];



$query = ""ls '"". $tainted . ""'"";


$ret = system($query);


?>",$ret = system($query);,True,True,"$script = ""/tmp/tainted.php"";
exec($script, $result, $return);

$tainted = $result[0];



$query = ""ls '"". $tainted . ""'"";


$ret = system($query);","```xml
<Issues>
  <Issue>
    <Type>Security</Type>
    <Weakness>CWE-78</Weakness>
    <Description>Improper Neutralization of Special Elements used in an OS Command ('OS Command Injection')</Description>
    <Severity>Critical</Severity>
    <File>File 1</File>
    <Code>$script = ""/tmp/tainted.php"";
exec($script, $result, $return);

$tainted = $result[0];



$query = ""ls '"". $tainted . ""'"";


$ret = system($query);</Code>
    <Justification>The code executes an OS command constructed using external input $tainted. The $tainted variable is obtained from the execution of /tmp/tainted.php, making it an externally-influenced input. This input is then directly concatenated into the $query string, which is executed using the system() function. This lack of neutralization of special elements within $tainted allows for command injection, potentially leading to arbitrary command execution on the system.</Justification>
  </Issue>
</Issues>
```"
CWE-79,src/CWE_79__POST__no_sanitizing__Use_untrusted_data_propertyValue_CSS-span_Style_Property_Value.php,"<!-- 
Unsafe sample
input : get the field UserData from the variable $_POST
sanitize : none
File : unsafe, use of untrusted data in a property value in a span tag(CSS)
-->

<!--Copyright 2015 Bertrand STIVALET 

Permission is hereby granted, without written agreement or royalty fee, to

use, copy, modify, and distribute this software and its documentation for

any purpose, provided that the above copyright notice and the following

three paragraphs appear in all copies of this software.


IN NO EVENT SHALL AUTHORS BE LIABLE TO ANY PARTY FOR DIRECT,

INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES ARISING OUT OF THE 

USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF AUTHORS HAVE

BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.


AUTHORS SPECIFICALLY DISCLAIM ANY WARRANTIES INCLUDING, BUT NOT

LIMITED TO THE IMPLIED WARRANTIES OF MERCHANTABILITY, FITNESS FOR A

PARTICULAR PURPOSE, AND NON-INFRINGEMENT.


THE SOFTWARE IS PROVIDED ON AN ""AS-IS"" BASIS AND AUTHORS HAVE NO

OBLIGATION TO PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR

MODIFICATIONS.-->


<!DOCTYPE html>
<html>
<head/>
<body>
<?php
$tainted = $_POST['UserData'];




echo ""<span style=\""color :"". checked_data .""\"">Hey</span>"" ;
?>
<h1>Hello World!</h1>
</body>
</html>","echo ""<span style=\""color :"". checked_data .""\"">Hey</span>"" ;",True,True,"echo ""<span style=\""color :"". checked_data .""\"">Hey</span>"" ;","```xml
<Issues>
  <Issue>
    <Type>Security</Type>
    <Weakness>CWE-79</Weakness>
    <Description>Improper Neutralization of Input During Web Page Generation ('Cross-site Scripting')</Description>
    <Severity>High</Severity>
    <File>File 1</File>
    <Code>echo ""&lt;span style=\""color :"". checked_data .""\"">Hey&lt;/span&gt;"" ;</Code>
    <Justification>The code uses unsanitized user input ($tainted, which becomes checked_data) directly within the style attribute of a span tag. This allows an attacker to inject arbitrary CSS or even JavaScript code, leading to Cross-Site Scripting (XSS).</Justification>
  </Issue>
  <Issue>
    <Type>Reliability</Type>
    <Weakness>CWE-457</Weakness>
    <Description>Use of uninitialized variable</Description>
    <Severity>Medium</Severity>
    <File>File 1</File>
    <Code>echo ""&lt;span style=\""color :"". checked_data .""\"">Hey&lt;/span&gt;"" ;</Code>
    <Justification>The code uses variable 'checked_data' without initialization. In PHP, using an uninitialized variable will not necessarily cause a fatal error but it will result in undefined behavior and potentially lead to unexpected results or expose default values, affecting reliability. While the security impact comes from the use of tainted data, that variable wasn't even initialized before being used.</Justification>
  </Issue>
</Issues>
```"
CWE-78,src/CWE_78__POST__func_FILTER-CLEANING-special_chars_filter__ls-interpretation_simple_quote.php,"<?php







$tainted = $_POST['UserData'];

$sanitized = filter_var($tainted, FILTER_SANITIZE_SPECIAL_CHARS);
  $tainted = $sanitized ;
      

$query = ""ls ' $tainted '"";


$ret = system($query);


?>",$ret = system($query);,True,True,"$tainted = $_POST['UserData'];

$sanitized = filter_var($tainted, FILTER_SANITIZE_SPECIAL_CHARS);
  $tainted = $sanitized ;
      

$query = ""ls ' $tainted '"";


$ret = system($query);","```xml
<Issues>
  <Issue>
    <Type>Security</Type>
    <Weakness>CWE-78</Weakness>
    <Description>Improper Neutralization of Special Elements used in an OS Command ('OS Command Injection')</Description>
    <Severity>High</Severity>
    <File>File 1</File>
    <Code>$tainted = $_POST['UserData'];

$sanitized = filter_var($tainted, FILTER_SANITIZE_SPECIAL_CHARS);
  $tainted = $sanitized ;
      

$query = ""ls ' $tainted '"";


$ret = system($query);</Code>
    <Justification>The code takes user input from $_POST['UserData'], sanitizes it using filter_var with FILTER_SANITIZE_SPECIAL_CHARS, and then uses it to construct an OS command using system(). While the input is sanitized, it's still incorporated into the command. This could allow an attacker to inject arbitrary OS commands if the sanitization is insufficient or bypassed. Using single quotes around the tainted variable is not sufficient to prevent command injection.</Justification>
  </Issue>
</Issues>
```"
CWE-79,src/CWE_79__unserialize__func_FILTER-CLEANING-email_filter__Use_untrusted_data_script-quoted_Event_Handler.php,"<!-- 
Unsafe sample
input : Get a serialize string in POST and unserialize it
Uses an email_filter via filter_var function
File : use of untrusted data in a quoted event handler in a script
-->

<!--Copyright 2015 Bertrand STIVALET 

Permission is hereby granted, without written agreement or royalty fee, to

use, copy, modify, and distribute this software and its documentation for

any purpose, provided that the above copyright notice and the following

three paragraphs appear in all copies of this software.


IN NO EVENT SHALL AUTHORS BE LIABLE TO ANY PARTY FOR DIRECT,

INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES ARISING OUT OF THE 

USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF AUTHORS HAVE

BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.


AUTHORS SPECIFICALLY DISCLAIM ANY WARRANTIES INCLUDING, BUT NOT

LIMITED TO THE IMPLIED WARRANTIES OF MERCHANTABILITY, FITNESS FOR A

PARTICULAR PURPOSE, AND NON-INFRINGEMENT.


THE SOFTWARE IS PROVIDED ON AN ""AS-IS"" BASIS AND AUTHORS HAVE NO

OBLIGATION TO PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR

MODIFICATIONS.-->


<!DOCTYPE html>
<html>
<head/>
<body>
<?php
$string = $_POST['UserData'] ;
$tainted = unserialize($string);
    

$sanitized = filter_var($tainted, FILTER_SANITIZE_EMAIL);
if (filter_var($sanitized, FILTER_VALIDATE_EMAIL))
  $tainted = $sanitized ;
else
  $tainted = """" ;


echo ""<div onmouseover=\""x='"". $tainted .""'\>"";
?>
<h1>Hello World!</h1>
</div>
</body>
</html>","echo ""<div onmouseover=\""x='"". $tainted .""'\>"";",True,True,"echo ""<div onmouseover=""x='"". $tainted .""'\>"";","```xml
<Issues>
  <Issue>
    <Type>Security</Type>
    <Weakness>CWE-79</Weakness>
    <Description>Improper Neutralization of Input During Web Page Generation ('Cross-site Scripting')</Description>
    <Severity>High</Severity>
    <File>File 1</File>
    <Code>echo ""&lt;div onmouseover=&quot;x='"". $tainted .""'\&gt;"";</Code>
    <Justification>The code uses unfiltered data ($tainted) within an HTML event handler (onmouseover). An attacker could inject malicious JavaScript code via the POST parameter 'UserData'. While FILTER_SANITIZE_EMAIL is used, it does not prevent the injection of javascript code within the string. This results in Cross-Site Scripting (XSS).</Justification>
  </Issue>
  <Issue>
    <Type>Security</Type>
    <Weakness>CWE-502</Weakness>
    <Description>Deserialization of Untrusted Data</Description>
    <Severity>Critical</Severity>
    <File>File 1</File>
    <Code>$string = $_POST['UserData'] ;
$tainted = unserialize($string);</Code>
    <Justification>The code uses unserialize() on data received from the POST request without any validation. This allows for arbitrary code execution by a malicious user who can craft a serialized object. Unserialize should be avoided unless strictly necessary and input is very carefully validated.</Justification>
  </Issue>
</Issues>
```"
CWE-90,src/CWE_90__system__func_addslashes__not_name-concatenation_simple_quote.php,"<?php







$tainted = system('ls', $retval);

$tainted = addslashes($tainted);

$query = ""!name='"". $tainted . ""'"";


$ds=ldap_connect(""localhost""); 
$r=ldap_bind($ds);
$sr=ldap_search($ds,""o=My Company, c=US"", $query);  
ldap_close($ds);

?>","$ds=ldap_connect(""localhost"");",True,True,"$tainted = addslashes($tainted);

$query = ""!name='"". $tainted . ""'"";

$sr=ldap_search($ds,""o=My Company, c=US"", $query);","```xml
<Issues>
  <Issue>
    <Type>Security</Type>
    <Weakness>CWE-77</Weakness>
    <Description>Improper Neutralization of Special Elements used in a Command ('Command Injection')</Description>
    <Severity>High</Severity>
    <File>File 1</File>
    <Code>$tainted = system('ls', $retval);</Code>
    <Justification>The `system()` function executes an external command. While the example uses a safe command ('ls'), relying on this function without proper sanitization poses a risk. An attacker could potentially modify the command if the input to `system()` is derived from an external source.</Justification>
  </Issue>
  <Issue>
    <Type>Security</Type>
    <Weakness>CWE-90</Weakness>
    <Description>Improper Neutralization of Special Elements used in an LDAP Query ('LDAP Injection')</Description>
    <Severity>High</Severity>
    <File>File 1</File>
    <Code>$tainted = addslashes($tainted);

$query = ""!name='"". $tainted . ""'"";

$sr=ldap_search($ds,""o=My Company, c=US"", $query);  </Code>
    <Justification>The code constructs an LDAP query by concatenating user-controlled data (`$tainted`) into the query string. Although `addslashes()` is used, it's not sufficient to prevent LDAP injection. An attacker can manipulate the query logic by injecting special characters or sequences, potentially gaining unauthorized access to or control over LDAP data.</Justification>
  </Issue>
</Issues>
```"
CWE-90,src/CWE_90__system__func_pg_escape_string__name-concatenation_simple_quote.php,"<?php







$tainted = system('ls', $retval);

$tainted = pg_escape_string($tainted);

$query = ""name='"". $tainted . ""'"";


$ds=ldap_connect(""localhost""); 
$r=ldap_bind($ds);
$sr=ldap_search($ds,""o=My Company, c=US"", $query);  
ldap_close($ds);

?>","$ds=ldap_connect(""localhost"");",True,True,"$tainted = pg_escape_string($tainted);

$query = ""name='"". $tainted . ""'"";

$sr=ldap_search($ds,""o=My Company, c=US"", $query);","```xml
<Issues>
  <Issue>
    <Type>Security</Type>
    <Weakness>CWE-77</Weakness>
    <Description>Improper Neutralization of Special Elements used in a Command ('Command Injection')</Description>
    <Severity>High</Severity>
    <File>File 1</File>
    <Code>$tainted = system('ls', $retval);</Code>
    <Justification>The 'system' function executes an external command.  If the command is influenced by external input, it can lead to command injection vulnerabilities. Although in this specific example, the command 'ls' is hardcoded, the general use of 'system' without proper sanitization can be dangerous.</Justification>
  </Issue>
  <Issue>
    <Type>Security</Type>
    <Weakness>CWE-90</Weakness>
    <Description>Improper Neutralization of Special Elements used in an LDAP Query ('LDAP Injection')</Description>
    <Severity>High</Severity>
    <File>File 1</File>
    <Code>$tainted = pg_escape_string($tainted);

$query = ""name='"". $tainted . ""'"";

$sr=ldap_search($ds,""o=My Company, c=US"", $query);</Code>
    <Justification>The code constructs an LDAP query by concatenating user-controlled data ($tainted) into the query string.  While pg_escape_string is used, it's intended for PostgreSQL and doesn't neutralize characters that are special in LDAP queries.  This can lead to LDAP injection vulnerabilities, allowing attackers to modify the query and potentially gain unauthorized access to information or execute arbitrary commands.</Justification>
  </Issue>
</Issues>
```"
CWE-91,src/CWE_91__object-Array__func_FILTER-CLEANING-full_special_chars_filter__username_at-sprintf_%s_simple_quote.php,"<?php







class Input{
  private $input;

  public function getInput(){
    return $this->input[1];
  }

  public  function __construct(){
    $this->input = array();
    $this->input[0]= 'safe' ;
    $this->input[1]= $_GET['UserData'] ;
    $this->input[2]= 'safe' ;
  }
}
$temp = new Input();
$tainted =  $temp->getInput();

$sanitized = filter_var($tainted, FILTER_SANITIZE_FULL_SPECIAL_CHARS);
  $tainted = $sanitized ;
     

$query = sprintf(""


$xml = simplexml_load_file(""users.xml"");
echo ""query : "". $query .""<br /><br />"" ;

$res=$xml->xpath($query);
print_r($res);
echo ""<br />"" ;

?>","$xml = simplexml_load_file(""users.xml"");",False,False,,"```xml
<Issues>
  <Issue>
    <Type>Security</Type>
    <Weakness>CWE-643</Weakness>
    <Description>Improper Neutralization of Data within XPath Expressions ('XPath Injection')</Description>
    <Severity>High</Severity>
    <File>File 1</File>
    <Code>$query = sprintf(""


$xml = simplexml_load_file(""users.xml"");
echo ""query : "". $query .""&lt;br /&gt;&lt;br /&gt;"" ;

$res=$xml->xpath($query);</Code>
    <Justification>The code constructs an XPath query using sprintf without proper neutralization of user-supplied data ($tainted). Even though FILTER_SANITIZE_FULL_SPECIAL_CHARS is used, it might not be sufficient to prevent XPath injection in all cases, as it might not escape all special characters relevant to XPath.  This could allow an attacker to inject malicious XPath expressions, potentially leading to unauthorized access to or modification of XML data.</Justification>
  </Issue>
  <Issue>
    <Type>Security</Type>
    <Weakness>CWE-22</Weakness>
    <Description>Improper Limitation of a Pathname to a Restricted Directory ('Path Traversal')</Description>
    <Severity>Medium</Severity>
    <File>File 1</File>
    <Code>$query = sprintf(""


$xml = simplexml_load_file(""users.xml"");
echo ""query : "". $query .""&lt;br /&gt;&lt;br /&gt;"" ;</Code>
    <Justification>The code uses a hardcoded file path ""users.xml"" in the simplexml_load_file function. While this specific instance doesn't directly involve user input for path construction, the lack of flexibility could lead to path traversal vulnerabilities if the application's configuration or deployment changes to allow external control over the included file path.</Justification>
  </Issue>
</Issues>
```"
CWE-91,src/CWE_91__object-directGet__func_FILTER-CLEANING-full_special_chars_filter__data-sprintf_%s_simple_quote.php,"<?php







class Input{
  public function getInput(){
    return $_GET['UserData'] ;
  }
}

$temp = new Input();
$tainted =  $temp->getInput();

$sanitized = filter_var($tainted, FILTER_SANITIZE_FULL_SPECIAL_CHARS);
  $tainted = $sanitized ;
     

$query = sprintf(""'%s'"", $tainted);


$xml = simplexml_load_file(""users.xml"");
echo ""query : "". $query .""<br /><br />"" ;

$res=$xml->xpath($query);
print_r($res);
echo ""<br />"" ;

?>","$xml = simplexml_load_file(""users.xml"");",False,False,,"```xml
<Issues>
  <Issue>
    <Type>Security</Type>
    <Weakness>CWE-643</Weakness>
    <Description>Improper Neutralization of Data within XPath Expressions ('XPath Injection')</Description>
    <Severity>High</Severity>
    <File>File 1</File>
    <Code>$query = sprintf(""'%s'"", $tainted);


$xml = simplexml_load_file(""users.xml"");
echo ""query : "". $query .""&lt;br /&gt;&lt;br /&gt;"" ;

$res=$xml->xpath($query);</Code>
    <Justification>The code uses user-controlled data ($tainted) to construct an XPath query without proper neutralization. Although FILTER_SANITIZE_FULL_SPECIAL_CHARS is used, it might not be sufficient to prevent XPath injection, as it only encodes certain characters. An attacker could still craft malicious XPath expressions to extract sensitive information from the XML file or cause a denial of service.</Justification>
  </Issue>
</Issues>
```"
CWE-91,src/CWE_91__array-GET__func_FILTER-VALIDATION-email_filter__username_at-sprintf_%s_simple_quote.php,"<?php







$array = array();
$array[] = 'safe' ;
$array[] = $_GET['userData'] ;
$array[] = 'safe' ;
$tainted = $array[1] ;

if (filter_var($sanitized, FILTER_VALIDATE_EMAIL))
  $tainted = $sanitized ;
else
  $tainted = """" ;

$query = sprintf(""


$xml = simplexml_load_file(""users.xml"");
echo ""query : "". $query .""<br /><br />"" ;

$res=$xml->xpath($query);
print_r($res);
echo ""<br />"" ;

?>","$xml = simplexml_load_file(""users.xml"");",True,True,"$query = sprintf(""
\n
\n$xml = simplexml_load_file(""users.xml"");","```xml
<Issues>
  <Issue>
    <Type>Security</Type>
    <Weakness>CWE-91</Weakness>
    <Description>XML Injection (aka Blind XPath Injection)</Description>
    <Severity>High</Severity>
    <File>File 1</File>
    <Code>$query = sprintf(""
\n
\n$xml = simplexml_load_file(""users.xml"");</Code>
    <Justification>The code uses unsanitized user input ($_GET['userData']) in an XPath query, making it vulnerable to XML injection.  Even after the email validation filter_var, the code still relies on the `$tainted` variable which can lead to XML injection if `$sanitized` is not properly initialized or handled. The  simplexml_load_file function is used which is not the main vulnerability but is used to execute the query where the injection occurs.</Justification>
  </Issue>
  <Issue>
    <Type>Reliability</Type>
    <Weakness>CWE-252</Weakness>
    <Description>Unchecked Return Value</Description>
    <Severity>Medium</Severity>
    <File>File 1</File>
    <Code>$xml = simplexml_load_file(""users.xml"");</Code>
    <Justification>The code does not check the return value of simplexml_load_file(). If the file does not exist or is malformed, it could return false, leading to a NULL pointer dereference later when $xml->xpath($query) is called.</Justification>
  </Issue>
  <Issue>
    <Type>Security</Type>
    <Weakness>CWE-502</Weakness>
    <Description>Deserialization of Untrusted Data</Description>
    <Severity>High</Severity>
    <File>File 1</File>
    <Code>$xml = simplexml_load_file(""users.xml"");</Code>
    <Justification>simplexml_load_file deserializes data from XML. If ""users.xml"" is sourced from an untrusted source (e.g., user upload, external API), it could be maliciously crafted to exploit vulnerabilities in the XML parser or lead to other security issues, particularly denial of service. Even if the file is not directly from the user it's better to consider this aspect as a security issue</Justification>
  </Issue>
</Issues>
```"
CWE-89,src/CWE_89__shell_exec__no_sanitizing__multiple_AS-interpretation_simple_quote.php,"<?php







$tainted = shell_exec('cat /tmp/tainted.txt');



$query = ""SELECT Trim(a.FirstName) & ' ' & Trim(a.LastName) AS employee_name, a.city, a.street & (' ' +a.housenum) AS address FROM Employees AS a  WHERE a.supervisor=' $tainted '"";


$conn = mysql_connect('localhost', 'mysql_user', 'mysql_password'); 
mysql_select_db('dbname') ;
echo ""query : "". $query .""<br /><br />"" ;

$res = mysql_query($query); 

while($data =mysql_fetch_array($res)){
print_r($data) ;
echo ""<br />"" ;
} 
mysql_close($conn);

?>","$conn = mysql_connect('localhost', 'mysql_user', 'mysql_password'); ",True,False,"$query = ""SELECT Trim(a.FirstName) & ' ' & Trim(a.LastName) AS employee_name, a.city, a.street & (' ' +a.housenum) AS address FROM Employees AS a  WHERE a.supervisor=' $tainted '"";","```xml
<Issues>
  <Issue>
    <Type>Security</Type>
    <Weakness>CWE-78</Weakness>
    <Description>Improper Neutralization of Special Elements used in a Command ('Command Injection')</Description>
    <Severity>High</Severity>
    <File>File 1</File>
    <Code>$tainted = shell_exec('cat /tmp/tainted.txt');</Code>
    <Justification>The code is using shell_exec to execute a command, which is reading content of a file. An attacker could inject arbitrary commands into the /tmp/tainted.txt file, leading to command execution on the server.</Justification>
  </Issue>
  <Issue>
    <Type>Security</Type>
    <Weakness>CWE-89</Weakness>
    <Description>Improper Neutralization of Special Elements used in an SQL Command ('SQL Injection')</Description>
    <Severity>Critical</Severity>
    <File>File 1</File>
    <Code>$query = ""SELECT Trim(a.FirstName) & ' ' & Trim(a.LastName) AS employee_name, a.city, a.street & (' ' +a.housenum) AS address FROM Employees AS a  WHERE a.supervisor=' $tainted '"";</Code>
    <Justification>The code is directly embedding the `$tainted` variable (which originates from a shell command) into the SQL query without proper sanitization. This creates a high-risk SQL injection vulnerability.</Justification>
  </Issue>
  <Issue>
    <Type>Security</Type>
    <Weakness>CWE-477</Weakness>
    <Description>Use of Obsolete Function</Description>
    <Severity>Medium</Severity>
    <File>File 1</File>
    <Code>$conn = mysql_connect('localhost', 'mysql_user', 'mysql_password'); 
mysql_select_db('dbname') ;
echo ""query : "". $query .""&lt;br /&gt;&lt;br /&gt;"" ;

$res = mysql_query($query); </Code>
    <Justification>The code uses the `mysql_connect` and `mysql_query` functions, which are deprecated.  Using these functions can pose security risks, as they might not be actively maintained or patched for vulnerabilities.</Justification>
  </Issue>
</Issues>
```"
CWE-79,src/CWE_79__backticks__func_FILTER-CLEANING-email_filter__Use_untrusted_data_script-window_SetInterval.php,"<!-- 
Unsafe sample
input : backticks interpretation, reading the file /tmp/tainted.txt
Uses an email_filter via filter_var function
File : unsafe, use of untrusted data in the function setInterval
-->

<!--Copyright 2015 Bertrand STIVALET 

Permission is hereby granted, without written agreement or royalty fee, to

use, copy, modify, and distribute this software and its documentation for

any purpose, provided that the above copyright notice and the following

three paragraphs appear in all copies of this software.


IN NO EVENT SHALL AUTHORS BE LIABLE TO ANY PARTY FOR DIRECT,

INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES ARISING OUT OF THE 

USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF AUTHORS HAVE

BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.


AUTHORS SPECIFICALLY DISCLAIM ANY WARRANTIES INCLUDING, BUT NOT

LIMITED TO THE IMPLIED WARRANTIES OF MERCHANTABILITY, FITNESS FOR A

PARTICULAR PURPOSE, AND NON-INFRINGEMENT.


THE SOFTWARE IS PROVIDED ON AN ""AS-IS"" BASIS AND AUTHORS HAVE NO

OBLIGATION TO PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR

MODIFICATIONS.-->


<!DOCTYPE html>
<html>
<head>
<script>
<?php
$tainted = `cat /tmp/tainted.txt`;

$sanitized = filter_var($tainted, FILTER_SANITIZE_EMAIL);
if (filter_var($sanitized, FILTER_VALIDATE_EMAIL))
  $tainted = $sanitized ;
else
  $tainted = """" ;


echo ""window.setInterval('"". $tainted .""');"" ;
?>
 </script>
</head>
<body>
<h1>Hello World!</h1>
</body>
</html>","echo ""window.setInterval('"". $tainted .""');"" ;",True,True,"echo ""window.setInterval('"". $tainted .""');""","```xml
<Issues>
  <Issue>
    <Type>Security</Type>
    <Weakness>CWE-77</Weakness>
    <Description>Improper Neutralization of Special Elements used in a Command ('Command Injection')</Description>
    <Severity>High</Severity>
    <File>File 1</File>
    <Code>$tainted = `cat /tmp/tainted.txt`;</Code>
    <Justification>The code uses backticks to execute a shell command with user-controlled input. If the file /tmp/tainted.txt contains malicious characters, this could lead to command injection.</Justification>
  </Issue>
  <Issue>
    <Type>Security</Type>
    <Weakness>CWE-79</Weakness>
    <Description>Improper Neutralization of Input During Web Page Generation ('Cross-site Scripting')</Description>
    <Severity>High</Severity>
    <File>File 1</File>
    <Code>echo ""window.setInterval('"". $tainted .""');""</Code>
    <Justification>The code embeds unsanitized user input directly into a JavaScript setInterval function. This is vulnerable to cross-site scripting (XSS) because an attacker can inject arbitrary JavaScript code.</Justification>
  </Issue>
  <Issue>
    <Type>Reliability</Type>
    <Weakness>CWE-758</Weakness>
    <Description>Reliance on Undefined, Unspecified, or Implementation-Defined Behavior</Description>
    <Severity>Low</Severity>
    <File>File 1</File>
    <Code>echo ""window.setInterval('"". $tainted .""');""</Code>
    <Justification>The behavior of setInterval with untrusted input as its code argument is unspecified and can lead to unexpected errors if the input is not a valid javascript</Justification>
  </Issue>
</Issues>
```"
CWE-90,src/CWE_90__POST__func_FILTER-CLEANING-email_filter__userByMail-sprintf_%s_simple_quote.php,"<?php







$tainted = $_POST['UserData'];

$sanitized = filter_var($tainted, FILTER_SANITIZE_EMAIL);
if (filter_var($sanitized, FILTER_VALIDATE_EMAIL))
  $tainted = $sanitized ;
else
  $tainted = """" ;

$query = sprintf(""(&(objectCategory=person)(objectClass=user)(mail='%s'))"", $tainted);


$ds=ldap_connect(""localhost""); 
$r=ldap_bind($ds);
$sr=ldap_search($ds,""o=My Company, c=US"", $query);  
ldap_close($ds);

?>","$ds=ldap_connect(""localhost"");",True,False,"$query = sprintf(""(&(objectCategory=person)(objectClass=user)(mail='%s'))"", $tainted);","```xml
<Issues>
  <Issue>
    <Type>Security</Type>
    <Weakness>CWE-90</Weakness>
    <Description>Improper Neutralization of Special Elements used in an LDAP Query ('LDAP Injection')</Description>
    <Severity>High</Severity>
    <File>File 1</File>
    <Code>$query = sprintf(""(&(objectCategory=person)(objectClass=user)(mail='%s'))"", $tainted);</Code>
    <Justification>The code constructs an LDAP query using user-controlled input ($tainted) without proper neutralization of special elements. This can lead to LDAP injection vulnerabilities, allowing attackers to modify the query and potentially gain unauthorized access to sensitive information.</Justification>
  </Issue>
  <Issue>
    <Type>Security</Type>
    <Weakness>CWE-252</Weakness>
    <Description>Unchecked Return Value</Description>
    <Severity>Medium</Severity>
    <File>File 1</File>
    <Code>$ds=ldap_connect(""localhost"");</Code>
    <Justification>The code does not check the return value of `ldap_connect()`. If the connection fails, $ds will be false but the code will try to use the false value in `ldap_bind`, potentially causing an error and revealing information about the server. The same happens with ldap_bind and ldap_search.</Justification>
  </Issue>
  <Issue>
    <Type>Security</Type>
    <Weakness>CWE-252</Weakness>
    <Description>Unchecked Return Value</Description>
    <Severity>Medium</Severity>
    <File>File 1</File>
    <Code>$r=ldap_bind($ds);</Code>
    <Justification>The code does not check the return value of `ldap_bind()`. If the bind operation fails, the script might continue execution with incorrect assumptions, leading to potential security vulnerabilities.</Justification>
  </Issue>
  <Issue>
    <Type>Security</Type>
    <Weakness>CWE-252</Weakness>
    <Description>Unchecked Return Value</Description>
    <Severity>Medium</Severity>
    <File>File 1</File>
    <Code>$sr=ldap_search($ds,""o=My Company, c=US"", $query);</Code>
    <Justification>The code does not check the return value of `ldap_search()`. If the search operation fails, the script might continue execution with incorrect assumptions, leading to potential security vulnerabilities.</Justification>
  </Issue>
  <Issue>
    <Type>Security</Type>
    <Weakness>CWE-798</Weakness>
    <Description>Use of Hard-coded Credentials</Description>
    <Severity>Medium</Severity>
    <File>File 1</File>
    <Code>$ds=ldap_connect(""localhost""); 
$r=ldap_bind($ds);</Code>
    <Justification>The code might be using default or hardcoded credentials for ldap_bind, which increases the risk of unauthorized access if the credentials are compromised.</Justification>
  </Issue>
</Issues>
```"
CWE-90,src/CWE_90__POST__func_FILTER-CLEANING-magic_quotes_filter__userByMail-concatenation_simple_quote.php,"<?php







$tainted = $_POST['UserData'];

$sanitized = filter_var($tainted, FILTER_SANITIZE_MAGIC_QUOTES);
  $tainted = $sanitized ;
      

$query = ""(&(objectCategory=person)(objectClass=user)(mail='"". $tainted . ""'))"";


$ds=ldap_connect(""localhost""); 
$r=ldap_bind($ds);
$sr=ldap_search($ds,""o=My Company, c=US"", $query);  
ldap_close($ds);

?>","$ds=ldap_connect(""localhost"");",True,True,"$tainted = $_POST['UserData'];

$sanitized = filter_var($tainted, FILTER_SANITIZE_MAGIC_QUOTES);
  $tainted = $sanitized ;
      

$query = ""(&(objectCategory=person)(objectClass=user)(mail='"". $tainted . ""'))"";","```xml
<Issues>
  <Issue>
    <Type>Security</Type>
    <Weakness>CWE-90</Weakness>
    <Description>Improper Neutralization of Special Elements used in an LDAP Query ('LDAP Injection')</Description>
    <Severity>High</Severity>
    <File>File 1</File>
    <Code>$tainted = $_POST['UserData'];

$sanitized = filter_var($tainted, FILTER_SANITIZE_MAGIC_QUOTES);
  $tainted = $sanitized ;
      

$query = ""(&(objectCategory=person)(objectClass=user)(mail='"". $tainted . ""'))"";</Code>
    <Justification>The code directly uses user-controlled input ($tainted) within an LDAP query without proper escaping or parameterization, making it vulnerable to LDAP injection attacks. The `filter_var` with `FILTER_SANITIZE_MAGIC_QUOTES` does not provide sufficient protection against LDAP injection.</Justification>
  </Issue>
</Issues>
```"
CWE-90,src/CWE_90__fopen__func_FILTER-VALIDATION-email_filter__name-interpretation_simple_quote.php,"<?php







$handle = @fopen(""/tmp/tainted.txt"", ""r"");

if ($handle) {
  if(($tainted = fgets($handle, 4096)) == false) {
    $tainted = """";
  }
  fclose($handle);
} else {
  $tainted = """";
}

if (filter_var($sanitized, FILTER_VALIDATE_EMAIL))
  $tainted = $sanitized ;
else
  $tainted = """" ;

$query = ""name=' $tainted '"";


$ds=ldap_connect(""localhost""); 
$r=ldap_bind($ds);
$sr=ldap_search($ds,""o=My Company, c=US"", $query);  
ldap_close($ds);

?>","$ds=ldap_connect(""localhost"");",True,True,"$query = ""name=' $tainted '"";


$ds=ldap_connect(""localhost""); 
$r=ldap_bind($ds);
$sr=ldap_search($ds,""o=My Company, c=US"", $query);","```xml
<Issues>
  <Issue>
    <Type>Security</Type>
    <Weakness>CWE-90</Weakness>
    <Description>Improper Neutralization of Special Elements used in an LDAP Query ('LDAP Injection')</Description>
    <Severity>High</Severity>
    <File>File 1</File>
    <Code>$query = ""name=' $tainted '"";


$ds=ldap_connect(""localhost""); 
$r=ldap_bind($ds);
$sr=ldap_search($ds,""o=My Company, c=US"", $query);</Code>
    <Justification>The code constructs an LDAP query by directly embedding user-controlled data ($tainted) without proper sanitization. This makes the application vulnerable to LDAP injection attacks. An attacker can manipulate the $tainted variable to inject arbitrary LDAP code, potentially bypassing authentication, retrieving sensitive information, or modifying data in the LDAP directory.</Justification>
  </Issue>
  <Issue>
    <Type>Reliability</Type>
    <Weakness>CWE-252</Weakness>
    <Description>Unchecked Return Value</Description>
    <Severity>Medium</Severity>
    <File>File 1</File>
    <Code>$handle = @fopen(""/tmp/tainted.txt"", ""r"");

if ($handle) {
  if(($tainted = fgets($handle, 4096)) == false) {
...</Code>
    <Justification>The fopen function's return value is not checked for failure before attempting to read from the file with fgets. If fopen fails (e.g., due to permission issues or the file not existing), $handle will be false, and attempting to use it in fgets will lead to a runtime error. The @ operator suppresses error messages, which can hide this issue during testing. Similarly, ldap_bind and ldap_search are not checked</Justification>
  </Issue>
  <Issue>
    <Type>Reliability</Type>
    <Weakness>CWE-391</Weakness>
    <Description>Unchecked Error Condition</Description>
    <Severity>Medium</Severity>
    <File>File 1</File>
    <Code>$handle = @fopen(""/tmp/tainted.txt"", ""r"");

if ($handle) {
  if(($tainted = fgets($handle, 4096)) == false) {
...</Code>
    <Justification>The code uses the error suppression operator `@` before `fopen`, which prevents error messages from being displayed. This makes it difficult to diagnose potential issues related to file opening. Similarly, return values of `ldap_connect` and `ldap_bind` are not checked.</Justification>
  </Issue>
  <Issue>
    <Type>Security</Type>
    <Weakness>CWE-778</Weakness>
    <Description>Insufficient Logging</Description>
    <Severity>Low</Severity>
    <File>File 1</File>
    <Code>$handle = @fopen(""/tmp/tainted.txt"", ""r"");

if ($handle) {
  if(($tainted = fgets($handle, 4096)) == false) {
    $tainted = """";
  }
  fclose($handle);
} else {
  $tainted = """";
}

if (filter_var($sanitized, FILTER_VALIDATE_EMAIL))
  $tainted = $sanitized ;
else
  $tainted = """" ;

$query = ""name=' $tainted '"";


$ds=ldap_connect(""localhost""); 
$r=ldap_bind($ds);
$sr=ldap_search($ds,""o=My Company, c=US"", $query);  
ldap_close($ds);</Code>
    <Justification>The code does not log any security-relevant events, such as failed attempts to open the file or invalid input from the user. Insufficient logging makes it difficult to detect and respond to security incidents.</Justification>
  </Issue>
</Issues>
```"
CWE-79,src/CWE_79__exec__func_http_build_query__Use_untrusted_data_propertyValue_CSS-property_Value.php,"<!-- 
Unsafe sample
input : use exec to execute the script /tmp/tainted.php and store the output in $tainted
SANITIZE : use of http_build_query
File : use of untrusted data in a property value (CSS)
-->

<!--Copyright 2015 Bertrand STIVALET 

Permission is hereby granted, without written agreement or royalty fee, to

use, copy, modify, and distribute this software and its documentation for

any purpose, provided that the above copyright notice and the following

three paragraphs appear in all copies of this software.


IN NO EVENT SHALL AUTHORS BE LIABLE TO ANY PARTY FOR DIRECT,

INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES ARISING OUT OF THE 

USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF AUTHORS HAVE

BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.


AUTHORS SPECIFICALLY DISCLAIM ANY WARRANTIES INCLUDING, BUT NOT

LIMITED TO THE IMPLIED WARRANTIES OF MERCHANTABILITY, FITNESS FOR A

PARTICULAR PURPOSE, AND NON-INFRINGEMENT.


THE SOFTWARE IS PROVIDED ON AN ""AS-IS"" BASIS AND AUTHORS HAVE NO

OBLIGATION TO PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR

MODIFICATIONS.-->


<!DOCTYPE html>
<html>
<head>
<style>
<?php
$script = ""/tmp/tainted.php"";
exec($script, $result, $return);

$tainted = $result[0];

$tainted = http_build_query($tainted);


echo ""body { color :"". $tainted ."" ; }"" ;
?>
 </style> 
 </script>
</head>
<body>
<h1>Hello World!</h1>
</body>
</html>","echo ""body { color :"". $tainted ."" ; }"" ;",True,True,"$tainted = $result[0];

$tainted = http_build_query($tainted);


echo ""body { color :"". $tainted ."" ; }"" ;","```xml
<Issues>
  <Issue>
    <Type>Security</Type>
    <Weakness>CWE-77</Weakness>
    <Description>Improper Neutralization of Special Elements used in a Command ('Command Injection')</Description>
    <Severity>High</Severity>
    <File>File 1</File>
    <Code>$script = ""/tmp/tainted.php"";
exec($script, $result, $return);

$tainted = $result[0];

$tainted = http_build_query($tainted);</Code>
    <Justification>The code uses `exec` to execute a PHP script, which can lead to command injection if the script's path or its contents are controlled by an attacker. Even though the script name is hardcoded here, the executed script might contain vulnerabilities.</Justification>
  </Issue>
  <Issue>
    <Type>Security</Type>
    <Weakness>CWE-79</Weakness>
    <Description>Improper Neutralization of Input During Web Page Generation ('Cross-site Scripting')</Description>
    <Severity>Medium</Severity>
    <File>File 1</File>
    <Code>$tainted = $result[0];

$tainted = http_build_query($tainted);


echo ""body { color :"". $tainted ."" ; }"" ;</Code>
    <Justification>The code echoes the `$tainted` variable directly into the CSS style without proper sanitization beyond `http_build_query`. While `http_build_query` encodes certain characters, it doesn't guarantee complete neutralization against CSS injection or other XSS vulnerabilities, especially if the original script's output contains malicious CSS syntax.</Justification>
  </Issue>
  <Issue>
    <Type>Reliability</Type>
    <Weakness>CWE-252</Weakness>
    <Description>Unchecked Return Value</Description>
    <Severity>Low</Severity>
    <File>File 1</File>
    <Code>exec($script, $result, $return);</Code>
    <Justification>The code does not check the return value of the `exec` function. If the execution of the script fails, the `$result` variable might be empty or contain unexpected data, leading to unexpected behavior in subsequent code.</Justification>
  </Issue>
</Issues>
```"
CWE-79,src/CWE_79__SESSION__func_mysql_real_escape_string__Use_untrusted_data_propertyValue_CSS-double_Quoted_Property_Value.php,"<!-- 
Unsafe sample
input : get the UserData field of $_SESSION
SANITIZE : use of mysql_real_escape string
File : use of untrusted data in a double quoted property value (CSS)
-->

<!--Copyright 2015 Bertrand STIVALET 

Permission is hereby granted, without written agreement or royalty fee, to

use, copy, modify, and distribute this software and its documentation for

any purpose, provided that the above copyright notice and the following

three paragraphs appear in all copies of this software.


IN NO EVENT SHALL AUTHORS BE LIABLE TO ANY PARTY FOR DIRECT,

INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES ARISING OUT OF THE 

USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF AUTHORS HAVE

BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.


AUTHORS SPECIFICALLY DISCLAIM ANY WARRANTIES INCLUDING, BUT NOT

LIMITED TO THE IMPLIED WARRANTIES OF MERCHANTABILITY, FITNESS FOR A

PARTICULAR PURPOSE, AND NON-INFRINGEMENT.


THE SOFTWARE IS PROVIDED ON AN ""AS-IS"" BASIS AND AUTHORS HAVE NO

OBLIGATION TO PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR

MODIFICATIONS.-->


<!DOCTYPE html>
<html>
<head>
<style>
<?php
$tainted = $_SESSION['UserData'];

$tainted = mysql_real_escape_string($tainted);


echo ""body { color :\"""". $tainted .""\"" ; }"" ;
?>
</style> 
</head>
<body>
<h1>Hello World!</h1>
</body>
</html>","echo ""body { color :\"""". $tainted .""\"" ; }"" ;",True,True,"<style>
<?php
$tainted = $_SESSION['UserData'];

$tainted = mysql_real_escape_string($tainted);


echo ""body { color :\"""". $tainted .""\"" ; }"" ;
?>
</style>","```xml
<Issues>
  <Issue>
    <Type>Security</Type>
    <Weakness>CWE-79</Weakness>
    <Description>Improper Neutralization of Input During Web Page Generation ('Cross-site Scripting')</Description>
    <Severity>Medium</Severity>
    <File>File 1</File>
    <Code>&lt;style&gt;
&lt;?php
$tainted = $_SESSION['UserData'];

$tainted = mysql_real_escape_string($tainted);


echo ""body { color :\"""". $tainted .""\"" ; }"" ;
?&gt;
&lt;/style&gt;</Code>
    <Justification>The code uses user-controlled input ($_SESSION['UserData']) to dynamically generate CSS code, specifically setting the 'color' property of the 'body' element. Although mysql_real_escape_string is used, it's intended for SQL and not sufficient to neutralize characters harmful in CSS context.  An attacker could inject malicious CSS code, potentially leading to Cross-Site Scripting (XSS) if the CSS injection leads to JavaScript execution (e.g., using `expression()` in older IE versions or other browser-specific CSS features that allow code execution). While the direct impact might be limited to cosmetic changes in modern browsers, it's still an injection vulnerability that should be addressed with proper CSS escaping/sanitization.</Justification>
  </Issue>
  <Issue>
    <Type>Security</Type>
    <Weakness>CWE-477</Weakness>
    <Description>Use of Obsolete Function</Description>
    <Severity>Low</Severity>
    <File>File 1</File>
    <Code>$tainted = mysql_real_escape_string($tainted);</Code>
    <Justification>The code uses the 'mysql_real_escape_string' function, which is deprecated. This suggests that the code has not been actively reviewed or maintained. While it might function, it should be replaced with a modern alternative (e.g., using PDO or mysqli with prepared statements) for security and future compatibility.</Justification>
  </Issue>
</Issues>
```"
CWE-78,src/CWE_78__GET__func_FILTER-CLEANING-full_special_chars_filter__ls-sprintf_%s_simple_quote.php,"<?php







$tainted = $_GET['UserData'];

$sanitized = filter_var($tainted, FILTER_SANITIZE_FULL_SPECIAL_CHARS);
  $tainted = $sanitized ;
     

$query = sprintf(""ls '%s'"", $tainted);


$ret = system($query);


?>",$ret = system($query);,True,True,"$query = sprintf(""ls '%s'"", $tainted);

$ret = system($query);","```xml
<Issues>
  <Issue>
    <Type>Security</Type>
    <Weakness>CWE-78</Weakness>
    <Description>Improper Neutralization of Special Elements used in a Command ('Command Injection')</Description>
    <Severity>High</Severity>
    <File>File 1</File>
    <Code>$query = sprintf(""ls '%s'"", $tainted);

$ret = system($query);</Code>
    <Justification>The code uses sprintf to construct a shell command using user-provided input ($tainted) without proper sanitization, which can lead to command injection vulnerabilities. Even though filter_var with FILTER_SANITIZE_FULL_SPECIAL_CHARS is used, it might not be sufficient to prevent all possible command injection attacks since it will only encode specific characters and not prevent the injection of new commands.</Justification>
  </Issue>
</Issues>
```"
CWE-91,src/CWE_91__SESSION__no_sanitizing__data-interpretation_simple_quote.php,"<?php







$tainted = $_SESSION['UserData'];



$query = ""' $tainted '"";


$xml = simplexml_load_file(""users.xml"");
echo ""query : "". $query .""<br /><br />"" ;

$res=$xml->xpath($query);
print_r($res);
echo ""<br />"" ;

?>","$xml = simplexml_load_file(""users.xml"");",True,True,"$tainted = $_SESSION['UserData'];

$query = ""' $tainted '"";


$xml = simplexml_load_file(""users.xml"");
echo ""query : "". $query .""<br /><br />"" ;

$res=$xml->xpath($query);","```xml
<Issues>
  <Issue>
    <Type>Security</Type>
    <Weakness>CWE-91</Weakness>
    <Description>XML Injection (aka Blind XPath Injection)</Description>
    <Severity>High</Severity>
    <File>File 1</File>
    <Code>$tainted = $_SESSION['UserData'];

$query = ""' $tainted '"";


$xml = simplexml_load_file(""users.xml"");
echo ""query : "". $query .""&lt;br /&gt;&lt;br /&gt;"" ;

$res=$xml->xpath($query);</Code>
    <Justification>The code uses user-controlled data from $_SESSION['UserData'] to construct an XPath query without proper sanitization. An attacker could inject malicious XPath expressions to extract sensitive information or manipulate the XML data. Using single quotes to enclose the tainted data offers no protection against XPath injection.</Justification>
  </Issue>
</Issues>
```"
CWE-89,src/CWE_89__POST__no_sanitizing__select_from_where-interpretation.php,"<?php







$tainted = $_POST['UserData'];



$query = ""SELECT * FROM student where id= $tainted "";


$conn = mysql_connect('localhost', 'mysql_user', 'mysql_password'); 
mysql_select_db('dbname') ;
echo ""query : "". $query .""<br /><br />"" ;

$res = mysql_query($query); 

while($data =mysql_fetch_array($res)){
print_r($data) ;
echo ""<br />"" ;
} 
mysql_close($conn);

?>","$conn = mysql_connect('localhost', 'mysql_user', 'mysql_password'); ",True,False,"$tainted = $_POST['UserData'];\n\n\n\n$query = ""SELECT * FROM student where id= $tainted "";","```xml
<Issues>
  <Issue>
    <Type>Security</Type>
    <Weakness>CWE-89</Weakness>
    <Description>Improper Neutralization of Special Elements used in an SQL Command ('SQL Injection')</Description>
    <Severity>High</Severity>
    <File>File 1</File>
    <Code>$tainted = $_POST['UserData'];\n\n\n\n$query = ""SELECT * FROM student where id= $tainted "";</Code>
    <Justification>The code directly incorporates user-provided data ($tainted) into an SQL query without proper sanitization or parameterization, making it vulnerable to SQL injection attacks. An attacker could manipulate the input to execute arbitrary SQL commands, potentially compromising the database.</Justification>
  </Issue>
  <Issue>
    <Type>Security</Type>
    <Weakness>CWE-477</Weakness>
    <Description>Use of Obsolete Function</Description>
    <Severity>Medium</Severity>
    <File>File 1</File>
    <Code>$conn = mysql_connect('localhost', 'mysql_user', 'mysql_password'); \nmysql_select_db('dbname') ;</Code>
    <Justification>The code uses the `mysql_connect` and `mysql_select_db` functions, which are deprecated.  These functions are no longer maintained, lack security enhancements, and are removed in PHP7. This represents a potential security risk and a maintainability issue.</Justification>
  </Issue>
</Issues>
```"
CWE-79,src/CWE_79__object-indexArray__func_htmlspecialchars__Use_untrusted_data_propertyValue_CSS-span_Style_Property_Value.php,"<!-- 
Unsafe sample
input : get the field userData from the variable $_GET via an object, which store it in a array
sanitize : use of the function htmlspecialchars. Sanitizes the query but has a high chance to produce unexpected results
File : unsafe, use of untrusted data in a property value in a span tag(CSS)
-->

<!--Copyright 2015 Bertrand STIVALET 

Permission is hereby granted, without written agreement or royalty fee, to

use, copy, modify, and distribute this software and its documentation for

any purpose, provided that the above copyright notice and the following

three paragraphs appear in all copies of this software.


IN NO EVENT SHALL AUTHORS BE LIABLE TO ANY PARTY FOR DIRECT,

INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES ARISING OUT OF THE 

USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF AUTHORS HAVE

BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.


AUTHORS SPECIFICALLY DISCLAIM ANY WARRANTIES INCLUDING, BUT NOT

LIMITED TO THE IMPLIED WARRANTIES OF MERCHANTABILITY, FITNESS FOR A

PARTICULAR PURPOSE, AND NON-INFRINGEMENT.


THE SOFTWARE IS PROVIDED ON AN ""AS-IS"" BASIS AND AUTHORS HAVE NO

OBLIGATION TO PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR

MODIFICATIONS.-->


<!DOCTYPE html>
<html>
<head/>
<body>
<?php
class Input{
  private $input;

  public function getInput(){
    return $this->input['realOne'];
  }

  public  function __construct(){
    $this->input = array();
    $this->input['test']= 'safe' ;
    $this->input['realOne']= $_GET['UserData'] ;
    $this->input['trap']= 'safe' ;
  }
}
$temp = new Input();
$tainted =  $temp->getInput();

$tainted = htmlspecialchars($tainted, ENT_QUOTES);


echo ""<span style=\""color :"". checked_data .""\"">Hey</span>"" ;
?>
<h1>Hello World!</h1>
</body>
</html>","echo ""<span style=\""color :"". checked_data .""\"">Hey</span>"" ;",True,True,"$tainted = htmlspecialchars($tainted, ENT_QUOTES);


echo ""<span style=\""color :"". checked_data .""\"">Hey</span>"" ;
?>
<h1>Hello World!</h1>","```xml
<Issues>
  <Issue>
    <Type>Security</Type>
    <Weakness>CWE-79</Weakness>
    <Description>Improper Neutralization of Input During Web Page Generation ('Cross-site Scripting')</Description>
    <Severity>Medium</Severity>
    <File>File 1</File>
    <Code>
$tainted = htmlspecialchars($tainted, ENT_QUOTES);


echo ""&lt;span style=\""color :"". checked_data .""\""&gt;Hey&lt;/span&gt;"" ;
?>
&lt;h1&gt;Hello World!&lt;/h1&gt;
    </Code>
    <Justification>The variable $tainted, which originates from user-controlled input ($_GET['UserData']), is sanitized using htmlspecialchars, which encodes special HTML characters. However, the sanitized output is used within a CSS style attribute context.  While htmlspecialchars prevents direct HTML injection, it doesn't prevent CSS injection. If the user input contains CSS-related characters or escape sequences (e.g., expressions, url()), it can be used to inject arbitrary CSS code, potentially leading to information disclosure or other attacks. checked_data isn't sanitized, so is a security risk</Justification>
  </Issue>
  <Issue>
    <Type>Security</Type>
    <Weakness>CWE-79</Weakness>
    <Description>Improper Neutralization of Input During Web Page Generation ('Cross-site Scripting')</Description>
    <Severity>High</Severity>
    <File>File 1</File>
    <Code>
echo ""&lt;span style=\""color :"". checked_data .""\""&gt;Hey&lt;/span&gt;"" ;
?>
&lt;h1&gt;Hello World!&lt;/h1&gt;
    </Code>
    <Justification>The checked_data variable is not sanitized before being outputted to the page. If this variable contains any user-supplied input, it may be possible for an attacker to inject Javascript or malicious HTML into the page</Justification>
  </Issue>
</Issues>
```"
CWE-90,src/CWE_90__backticks__func_preg_match-no_filtering__name-concatenation_simple_quote.php,"<?php







$tainted = `cat /tmp/tainted.txt`;

$re = ""/^.*$/"";
if(preg_match($re, $tainted) == 1){
  $tainted = $tainted;
}
else{
  $tainted = """";
}

$query = ""name='"". $tainted . ""'"";


$ds=ldap_connect(""localhost""); 
$r=ldap_bind($ds);
$sr=ldap_search($ds,""o=My Company, c=US"", $query);  
ldap_close($ds);

?>","$ds=ldap_connect(""localhost"");",True,True,"$query = ""name='"". $tainted . ""'"";


$ds=ldap_connect(""localhost""); 
$r=ldap_bind($ds);
$sr=ldap_search($ds,""o=My Company, c=US"", $query);  
ldap_close($ds);","```xml
<Issues>
  <Issue>
    <Type>Security</Type>
    <Weakness>CWE-90</Weakness>
    <Description>Improper Neutralization of Special Elements used in an LDAP Query ('LDAP Injection')</Description>
    <Severity>High</Severity>
    <File>File 1</File>
    <Code>$query = ""name='"". $tainted . ""'"";


$ds=ldap_connect(""localhost""); 
$r=ldap_bind($ds);
$sr=ldap_search($ds,""o=My Company, c=US"", $query);  
ldap_close($ds);</Code>
    <Justification>The code constructs an LDAP query by concatenating user-controlled input ($tainted) directly into the query string.  Even though a regular expression check is performed, it is too broad and doesn't effectively neutralize special characters that could be used to inject malicious LDAP syntax, such as '*', '(', ')', or '\'. This allows an attacker to modify the LDAP query's meaning and potentially retrieve unauthorized information or perform other malicious actions.</Justification>
  </Issue>
  <Issue>
    <Type>Security</Type>
    <Weakness>CWE-77</Weakness>
    <Description>Improper Neutralization of Special Elements used in a Command ('Command Injection')</Description>
    <Severity>High</Severity>
    <File>File 1</File>
    <Code>$tainted = `cat /tmp/tainted.txt`;</Code>
    <Justification>The code uses backticks to execute the external command `cat /tmp/tainted.txt`. This allows an attacker to inject arbitrary commands if the contents of `/tmp/tainted.txt` are under their control. There is no sanitization or validation of the data read from the file, which could lead to command injection vulnerabilities.</Justification>
  </Issue>
  <Issue>
    <Type>Reliability</Type>
    <Weakness>CWE-252</Weakness>
    <Description>Unchecked Return Value</Description>
    <Severity>Medium</Severity>
    <File>File 1</File>
    <Code>$ds=ldap_connect(""localhost""); 
$r=ldap_bind($ds);
$sr=ldap_search($ds,""o=My Company, c=US"", $query);</Code>
    <Justification>The code does not check the return values of `ldap_connect`, `ldap_bind`, or `ldap_search`. If any of these functions fail, the subsequent code may operate on invalid resources or produce incorrect results. For example, if `ldap_connect` fails, `$ds` will be false, and using it in `ldap_bind` will cause an error. Similarly, failures in `ldap_bind` or `ldap_search` might result in the script proceeding with incomplete or incorrect data, leading to unexpected behaviour or even denial of service.</Justification>
  </Issue>
</Issues>
```"
CWE-89,src/CWE_89__exec__no_sanitizing__select_from_where-concatenation.php,"<?php







$script = ""/tmp/tainted.php"";
exec($script, $result, $return);

$tainted = $result[0];



$query = ""SELECT * FROM student where id="". $tainted . """";


$conn = mysql_connect('localhost', 'mysql_user', 'mysql_password'); 
mysql_select_db('dbname') ;
echo ""query : "". $query .""<br /><br />"" ;

$res = mysql_query($query); 

while($data =mysql_fetch_array($res)){
print_r($data) ;
echo ""<br />"" ;
} 
mysql_close($conn);

?>","$conn = mysql_connect('localhost', 'mysql_user', 'mysql_password'); ",True,False,"$query = ""SELECT * FROM student where id="". $tainted . """";","```xml
<Issues>
  <Issue>
    <Type>Security</Type>
    <Weakness>CWE-89</Weakness>
    <Description>Improper Neutralization of Special Elements used in an SQL Command ('SQL Injection')</Description>
    <Severity>Critical</Severity>
    <File>File 1</File>
    <Code>$query = ""SELECT * FROM student where id="". $tainted . """";</Code>
    <Justification>The code is vulnerable to SQL injection because it directly incorporates untrusted data ($tainted) into an SQL query without proper sanitization or parameterization. An attacker could manipulate the $tainted variable to inject malicious SQL code, potentially compromising the database.</Justification>
  </Issue>
  <Issue>
    <Type>Security</Type>
    <Weakness>CWE-77</Weakness>
    <Description>Improper Neutralization of Special Elements used in a Command ('Command Injection')</Description>
    <Severity>High</Severity>
    <File>File 1</File>
    <Code>$script = ""/tmp/tainted.php"";
exec($script, $result, $return);

$tainted = $result[0];</Code>
    <Justification>The code executes an external script using the `exec` function. If the `$script` path or the contents of `/tmp/tainted.php` are influenced by user input, it becomes vulnerable to command injection. An attacker could potentially execute arbitrary commands on the server by manipulating the script path or the script's contents.</Justification>
  </Issue>
  <Issue>
    <Type>Reliability</Type>
    <Weakness>CWE-252</Weakness>
    <Description>Unchecked Return Value</Description>
    <Severity>Medium</Severity>
    <File>File 1</File>
    <Code>$res = mysql_query($query);</Code>
    <Justification>The code does not check the return value of `mysql_query()`. If the query fails, `mysql_query()` will return FALSE. Without checking this return value, the code may proceed with a NULL $res causing potential issues like NULL pointer dereference or incorrect data processing in the while loop.</Justification>
  </Issue>
  <Issue>
    <Type>Reliability</Type>
    <Weakness>CWE-252</Weakness>
    <Description>Unchecked Return Value</Description>
    <Severity>Medium</Severity>
    <File>File 1</File>
    <Code>$conn = mysql_connect('localhost', 'mysql_user', 'mysql_password');</Code>
    <Justification>The code does not check the return value of `mysql_connect()`. If the connection fails, `mysql_connect()` will return FALSE. Without checking this return value, the code may proceed with a NULL $conn causing potential issues like NULL pointer dereference or errors when attempting to use the connection.</Justification>
  </Issue>
  <Issue>
    <Type>Reliability</Type>
    <Weakness>CWE-252</Weakness>
    <Description>Unchecked Return Value</Description>
    <Severity>Medium</Severity>
    <File>File 1</File>
    <Code>mysql_select_db('dbname') ;</Code>
    <Justification>The code does not check the return value of `mysql_select_db()`. If the database selection fails, `mysql_select_db()` will return FALSE. Without checking this return value, the code may proceed with incorrect database context causing potential issues during data access.</Justification>
  </Issue>
  <Issue>
    <Type>Maintainability</Type>
    <Weakness>CWE-477</Weakness>
    <Description>Use of Obsolete Function</Description>
    <Severity>Low</Severity>
    <File>File 1</File>
    <Code>$conn = mysql_connect('localhost', 'mysql_user', 'mysql_password'); 
mysql_select_db('dbname') ;
echo ""query : "". $query .""<br /><br />"" ;

$res = mysql_query($query); 

while($data =mysql_fetch_array($res)){
print_r($data) ;
echo ""<br />"" ;
} 
mysql_close($conn);</Code>
    <Justification>The code uses the `mysql_*` functions, which are deprecated. Using deprecated features decreases maintainability since these functions may be removed in future versions of PHP, requiring significant code changes.</Justification>
  </Issue>
</Issues>
```"
CWE-89,src/CWE_89__array-GET__no_sanitizing__multiple_AS-sprintf_%s_simple_quote.php,"<?php







$array = array();
$array[] = 'safe' ;
$array[] = $_GET['userData'] ;
$array[] = 'safe' ;
$tainted = $array[1] ;



$query = sprintf(""SELECT Trim(a.FirstName) & ' ' & Trim(a.LastName) AS employee_name, a.city, a.street & (' ' +a.housenum) AS address FROM Employees AS a  WHERE a.supervisor='%s'"", $tainted);


$conn = mysql_connect('localhost', 'mysql_user', 'mysql_password'); 
mysql_select_db('dbname') ;
echo ""query : "". $query .""<br /><br />"" ;

$res = mysql_query($query); 

while($data =mysql_fetch_array($res)){
print_r($data) ;
echo ""<br />"" ;
} 
mysql_close($conn);

?>","$conn = mysql_connect('localhost', 'mysql_user', 'mysql_password'); ",True,False,"$query = sprintf(""SELECT Trim(a.FirstName) & ' ' & Trim(a.LastName) AS employee_name, a.city, a.street & (' ' +a.housenum) AS address FROM Employees AS a  WHERE a.supervisor='%s'"", $tainted);","```xml
<Issues>
  <Issue>
    <Type>Security</Type>
    <Weakness>CWE-89</Weakness>
    <Description>Improper Neutralization of Special Elements used in an SQL Command ('SQL Injection')</Description>
    <Severity>High</Severity>
    <File>File 1</File>
    <Code>$query = sprintf(""SELECT Trim(a.FirstName) &amp; ' ' &amp; Trim(a.LastName) AS employee_name, a.city, a.street &amp; (' ' +a.housenum) AS address FROM Employees AS a  WHERE a.supervisor='%s'"", $tainted);</Code>
    <Justification>The code uses sprintf to construct an SQL query, directly embedding user-controlled data ($tainted) without proper sanitization. This allows for SQL injection, where an attacker can manipulate the query to extract or modify data.</Justification>
  </Issue>
  <Issue>
    <Type>Security</Type>
    <Weakness>CWE-477</Weakness>
    <Description>Use of Obsolete Function</Description>
    <Severity>Low</Severity>
    <File>File 1</File>
    <Code>$conn = mysql_connect('localhost', 'mysql_user', 'mysql_password'); 
mysql_select_db('dbname') ;
echo ""query : "". $query .""&lt;br /&gt;&lt;br /&gt;"" ;

$res = mysql_query($query); </Code>
    <Justification>The code uses the `mysql_connect` and `mysql_query` functions, which are deprecated.  These functions are no longer maintained and are inherently insecure.  The application should be updated to use `mysqli` or `PDO` with prepared statements.</Justification>
  </Issue>
</Issues>
```"
CWE-79,src/CWE_79__SESSION__func_FILTER-CLEANING-special_chars_filter__Use_untrusted_data_propertyValue_CSS-property_Value.php,"<!-- 
Unsafe sample
input : get the UserData field of $_SESSION
Uses a special_chars_filter via filter_var function
File : use of untrusted data in a property value (CSS)
-->

<!--Copyright 2015 Bertrand STIVALET 

Permission is hereby granted, without written agreement or royalty fee, to

use, copy, modify, and distribute this software and its documentation for

any purpose, provided that the above copyright notice and the following

three paragraphs appear in all copies of this software.


IN NO EVENT SHALL AUTHORS BE LIABLE TO ANY PARTY FOR DIRECT,

INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES ARISING OUT OF THE 

USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF AUTHORS HAVE

BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.


AUTHORS SPECIFICALLY DISCLAIM ANY WARRANTIES INCLUDING, BUT NOT

LIMITED TO THE IMPLIED WARRANTIES OF MERCHANTABILITY, FITNESS FOR A

PARTICULAR PURPOSE, AND NON-INFRINGEMENT.


THE SOFTWARE IS PROVIDED ON AN ""AS-IS"" BASIS AND AUTHORS HAVE NO

OBLIGATION TO PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR

MODIFICATIONS.-->


<!DOCTYPE html>
<html>
<head>
<style>
<?php
$tainted = $_SESSION['UserData'];

$sanitized = filter_var($tainted, FILTER_SANITIZE_SPECIAL_CHARS);
  $tainted = $sanitized ;
      


echo ""body { color :"". $tainted ."" ; }"" ;
?>
 </style> 
 </script>
</head>
<body>
<h1>Hello World!</h1>
</body>
</html>","echo ""body { color :"". $tainted ."" ; }"" ;",True,True,"<?php
$tainted = $_SESSION['UserData'];

$sanitized = filter_var($tainted, FILTER_SANITIZE_SPECIAL_CHARS);
  $tainted = $sanitized ;
      


echo ""body { color :"". $tainted ."" ; }"" ;
?>","```xml
<Issues>
  <Issue>
    <Type>Security</Type>
    <Weakness>CWE-79</Weakness>
    <Description>Improper Neutralization of Input During Web Page Generation ('Cross-site Scripting')</Description>
    <Severity>Medium</Severity>
    <File>File 1</File>
    <Code>&lt;?php
$tainted = $_SESSION['UserData'];

$sanitized = filter_var($tainted, FILTER_SANITIZE_SPECIAL_CHARS);
  $tainted = $sanitized ;
      


echo ""body { color :"". $tainted ."" ; }"" ;
?&gt;</Code>
    <Justification>The code retrieves user input from $_SESSION['UserData'], sanitizes it with FILTER_SANITIZE_SPECIAL_CHARS, and then echoes it directly into a CSS property value. Although the input is sanitized, it's still used within the style tag which can be exploited for XSS if the sanitization is not sufficient or if there are vulnerabilities in the CSS parser. An attacker could inject malicious CSS code.</Justification>
  </Issue>
</Issues>
```"
CWE-79,src/CWE_79__object-indexArray__func_mysql_real_escape_string__Unsafe_use_untrusted_data-style.php,"<!-- 
Unsafe sample
input : get the field userData from the variable $_GET via an object, which store it in a array
SANITIZE : use of mysql_real_escape string
File : unsafe, use of untrusted data in CSS
-->

<!--Copyright 2015 Bertrand STIVALET 

Permission is hereby granted, without written agreement or royalty fee, to

use, copy, modify, and distribute this software and its documentation for

any purpose, provided that the above copyright notice and the following

three paragraphs appear in all copies of this software.


IN NO EVENT SHALL AUTHORS BE LIABLE TO ANY PARTY FOR DIRECT,

INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES ARISING OUT OF THE 

USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF AUTHORS HAVE

BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.


AUTHORS SPECIFICALLY DISCLAIM ANY WARRANTIES INCLUDING, BUT NOT

LIMITED TO THE IMPLIED WARRANTIES OF MERCHANTABILITY, FITNESS FOR A

PARTICULAR PURPOSE, AND NON-INFRINGEMENT.


THE SOFTWARE IS PROVIDED ON AN ""AS-IS"" BASIS AND AUTHORS HAVE NO

OBLIGATION TO PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR

MODIFICATIONS.-->


<!DOCTYPE html>
<html>
<head>
<style>
<?php
class Input{
  private $input;

  public function getInput(){
    return $this->input['realOne'];
  }

  public  function __construct(){
    $this->input = array();
    $this->input['test']= 'safe' ;
    $this->input['realOne']= $_GET['UserData'] ;
    $this->input['trap']= 'safe' ;
  }
}
$temp = new Input();
$tainted =  $temp->getInput();

$tainted = mysql_real_escape_string($tainted);


echo $tainted ;
?>
</style>
</head>
<body>
<h1>Hello World!</h1>
</body>
</html>",echo $tainted ;,True,True,echo $tainted ;,"```xml
<Issues>
  <Issue>
    <Type>Security</Type>
    <Weakness>CWE-79</Weakness>
    <Description>Improper Neutralization of Input During Web Page Generation ('Cross-site Scripting')</Description>
    <Severity>Medium</Severity>
    <File>File 1</File>
    <Code>echo $tainted ;</Code>
    <Justification>The code echoes user-controlled input directly into the style section of the HTML page. Even though `mysql_real_escape_string` is used, it's designed for SQL escaping, not for CSS or HTML. Therefore, the code is vulnerable to CSS injection. An attacker could inject malicious CSS code by manipulating the UserData GET parameter. Note: mysql_real_escape_string is deprecated.</Justification>
  </Issue>
  <Issue>
    <Type>Security</Type>
    <Weakness>CWE-477</Weakness>
    <Description>Use of Obsolete Function</Description>
    <Severity>Low</Severity>
    <File>File 1</File>
    <Code>$tainted = mysql_real_escape_string($tainted);</Code>
    <Justification>The code uses the `mysql_real_escape_string` function, which is deprecated. Using deprecated functions can lead to security vulnerabilities and compatibility issues.</Justification>
  </Issue>
</Issues>
```"
CWE-90,src/CWE_90__unserialize__func_htmlspecialchars__name-interpretation_simple_quote.php,"<?php







$string = $_POST['UserData'] ;
$tainted = unserialize($string);
    

$tainted = htmlspecialchars($tainted, ENT_QUOTES);

$query = ""name=' $tainted '"";


$ds=ldap_connect(""localhost""); 
$r=ldap_bind($ds);
$sr=ldap_search($ds,""o=My Company, c=US"", $query);  
ldap_close($ds);

?>","$ds=ldap_connect(""localhost"");",True,True,"$tainted = htmlspecialchars($tainted, ENT_QUOTES);

$query = ""name=' $tainted '"";


$ds=ldap_connect(""localhost""); 
$r=ldap_bind($ds);
$sr=ldap_search($ds,""o=My Company, c=US"", $query);","```xml
<Issues>
  <Issue>
    <Type>Security</Type>
    <Weakness>CWE-502</Weakness>
    <Description>Deserialization of Untrusted Data</Description>
    <Severity>Critical</Severity>
    <File>File 1</File>
    <Code>$string = $_POST['UserData'] ;
$tainted = unserialize($string);</Code>
    <Justification>The code uses unserialize() on $_POST['UserData'] without any validation. This allows an attacker to inject arbitrary PHP objects, leading to potential remote code execution or other vulnerabilities.</Justification>
  </Issue>
  <Issue>
    <Type>Security</Type>
    <Weakness>CWE-90</Weakness>
    <Description>Improper Neutralization of Special Elements used in an LDAP Query ('LDAP Injection')</Description>
    <Severity>High</Severity>
    <File>File 1</File>
    <Code>$tainted = htmlspecialchars($tainted, ENT_QUOTES);

$query = ""name=' $tainted '"";


$ds=ldap_connect(""localhost""); 
$r=ldap_bind($ds);
$sr=ldap_search($ds,""o=My Company, c=US"", $query);</Code>
    <Justification>Although htmlspecialchars() is applied, it might not be sufficient to prevent LDAP injection as it primarily focuses on HTML entities. Depending on the LDAP implementation and configuration, other characters might still be used to manipulate the query.</Justification>
  </Issue>
  <Issue>
    <Type>Reliability</Type>
    <Weakness>CWE-252</Weakness>
    <Description>Unchecked Return Value</Description>
    <Severity>Medium</Severity>
    <File>File 1</File>
    <Code>$ds=ldap_connect(""localhost""); 
$r=ldap_bind($ds);
$sr=ldap_search($ds,""o=My Company, c=US"", $query);</Code>
    <Justification>The code does not check the return values of ldap_connect(), ldap_bind(), and ldap_search(). Failure to check these return values can lead to unexpected behavior or vulnerabilities if these functions fail.</Justification>
  </Issue>
  <Issue>
    <Type>Maintainability</Type>
    <Weakness>CWE-1051</Weakness>
    <Description>Initialization with Hard-Coded Network Resource Configuration Data</Description>
    <Severity>Low</Severity>
    <File>File 1</File>
    <Code>$ds=ldap_connect(""localhost"");</Code>
    <Justification>The LDAP server address ""localhost"" is hard-coded. This reduces maintainability and makes it harder to change the LDAP server without modifying the code.</Justification>
  </Issue>
</Issues>
```"
CWE-79,src/CWE_79__array-GET__func_http_build_query__Use_untrusted_data_propertyValue_CSS-quoted_Property_Value.php,"<!-- 
Unsafe sample
input : get the $_GET['userData'] in an array
SANITIZE : use of http_build_query
File : unsafe, use of untrusted data in a quoted property value (CSS)
-->

<!--Copyright 2015 Bertrand STIVALET 

Permission is hereby granted, without written agreement or royalty fee, to

use, copy, modify, and distribute this software and its documentation for

any purpose, provided that the above copyright notice and the following

three paragraphs appear in all copies of this software.


IN NO EVENT SHALL AUTHORS BE LIABLE TO ANY PARTY FOR DIRECT,

INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES ARISING OUT OF THE 

USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF AUTHORS HAVE

BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.


AUTHORS SPECIFICALLY DISCLAIM ANY WARRANTIES INCLUDING, BUT NOT

LIMITED TO THE IMPLIED WARRANTIES OF MERCHANTABILITY, FITNESS FOR A

PARTICULAR PURPOSE, AND NON-INFRINGEMENT.


THE SOFTWARE IS PROVIDED ON AN ""AS-IS"" BASIS AND AUTHORS HAVE NO

OBLIGATION TO PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR

MODIFICATIONS.-->


<!DOCTYPE html>
<html>
<head>
<style>
<?php
$array = array();
$array[] = 'safe' ;
$array[] = $_GET['userData'] ;
$array[] = 'safe' ;
$tainted = $array[1] ;

$tainted = http_build_query($tainted);


echo ""body { color :\'"". $tainted .""\' ; }"" ;
?>
</style> 
</head>
<body>
<h1>Hello World!</h1>
</body>
</html>","echo ""body { color :\'"". $tainted .""\' ; }"" ;",True,True,"$array = array();
$array[] = 'safe' ;
$array[] = $_GET['userData'] ;
$array[] = 'safe' ;
$tainted = $array[1] ;

$tainted = http_build_query($tainted);


echo ""body { color :\'"". $tainted .""\' ; }"" ;","```xml
<Issues>
  <Issue>
    <Type>Security</Type>
    <Weakness>CWE-79</Weakness>
    <Description>Improper Neutralization of Input During Web Page Generation ('Cross-site Scripting')</Description>
    <Severity>Medium</Severity>
    <File>File 1</File>
    <Code>$array = array();
$array[] = 'safe' ;
$array[] = $_GET['userData'] ;
$array[] = 'safe' ;
$tainted = $array[1] ;

$tainted = http_build_query($tainted);


echo ""body { color :\'"". $tainted .""\' ; }"" ;</Code>
    <Justification>The code retrieves user input from $_GET['userData'] and uses it within a CSS style attribute. Although http_build_query is used, it is intended for URL encoding, not sanitizing for CSS context.  Depending on the characters present in userData, this could allow injection of arbitrary CSS or potentially even XSS if the CSS injection can be leveraged to execute JavaScript (e.g., using expression() in older versions of IE, or other CSS injection techniques).</Justification>
  </Issue>
  <Issue>
    <Type>Maintainability</Type>
    <Weakness>CWE-1052</Weakness>
    <Description>Excessive Use of Hard-Coded Literals in Initialization</Description>
    <Severity>Low</Severity>
    <File>File 1</File>
    <Code>$array = array();
$array[] = 'safe' ;
$array[] = $_GET['userData'] ;
$array[] = 'safe' ;</Code>
    <Justification>The code initializes an array with hard-coded string literals ('safe'). While this specific instance might not be a major concern, repeated use of hard-coded literals throughout a codebase can decrease maintainability, making it harder to update or modify the application's behavior.</Justification>
  </Issue>
</Issues>
```"
CWE-90,src/CWE_90__proc_open__func_addslashes__name-sprintf_%s_simple_quote.php,"<?php







$descriptorspec = array(
  0 => array(""pipe"", ""r""),
  1 => array(""pipe"", ""w""),
  2 => array(""file"", ""/tmp/error-output.txt"", ""a"")
  );
$cwd = '/tmp';
$process = proc_open('more /tmp/tainted.txt', $descriptorspec, $pipes, $cwd, NULL);
if (is_resource($process)) {
  fclose($pipes[0]);
  $tainted = stream_get_contents($pipes[1]);
  fclose($pipes[1]);
  $return_value = proc_close($process);
}

$tainted = addslashes($tainted);

$query = sprintf(""name='%s'"", $tainted);


$ds=ldap_connect(""localhost""); 
$r=ldap_bind($ds);
$sr=ldap_search($ds,""o=My Company, c=US"", $query);  
ldap_close($ds);

?>","$ds=ldap_connect(""localhost"");",True,True,"$tainted = addslashes($tainted);

$query = sprintf(""name='%s'"", $tainted);


$ds=ldap_connect(""localhost""); 
$r=ldap_bind($ds);
$sr=ldap_search($ds,""o=My Company, c=US"", $query);  
ldap_close($ds);","```xml
<Issues>
  <Issue>
    <Type>Security</Type>
    <Weakness>CWE-90</Weakness>
    <Description>Improper Neutralization of Special Elements used in an LDAP Query ('LDAP Injection')</Description>
    <Severity>High</Severity>
    <File>File 1</File>
    <Code>$tainted = addslashes($tainted);

$query = sprintf(""name='%s'"", $tainted);


$ds=ldap_connect(""localhost""); 
$r=ldap_bind($ds);
$sr=ldap_search($ds,""o=My Company, c=US"", $query);  
ldap_close($ds);</Code>
    <Justification>The code constructs an LDAP query using user-controlled input ($tainted) without proper sanitization. Although addslashes() is used, it is insufficient to prevent LDAP injection attacks.  An attacker could inject arbitrary LDAP syntax, potentially bypassing authentication or retrieving sensitive information.</Justification>
  </Issue>
  <Issue>
    <Type>Reliability</Type>
    <Weakness>CWE-252</Weakness>
    <Description>Unchecked Return Value</Description>
    <Severity>Medium</Severity>
    <File>File 1</File>
    <Code>$ds=ldap_connect(""localhost""); 
$r=ldap_bind($ds);
$sr=ldap_search($ds,""o=My Company, c=US"", $query);  
ldap_close($ds);</Code>
    <Justification>The code does not check the return values of ldap_connect, ldap_bind, and ldap_search. If any of these functions fail, the script will continue to execute, potentially leading to errors or unexpected behavior. For example, if ldap_connect fails, $ds will not be a valid resource, and subsequent calls to ldap_bind and ldap_search will result in errors. Similarly, a failure in ldap_bind might leave the connection unauthenticated, while continuing with the search.</Justification>
  </Issue>
  <Issue>
    <Type>Security</Type>
    <Weakness>CWE-22</Weakness>
    <Description>Improper Limitation of a Pathname to a Restricted Directory ('Path Traversal')</Description>
    <Severity>Medium</Severity>
    <File>File 1</File>
    <Code>$process = proc_open('more /tmp/tainted.txt', $descriptorspec, $pipes, $cwd, NULL);
if (is_resource($process)) {
  fclose($pipes[0]);
  $tainted = stream_get_contents($pipes[1]);
  fclose($pipes[1]);
  $return_value = proc_close($process);
}

$tainted = addslashes($tainted);</Code>
    <Justification>The program uses `proc_open` to execute the `more` command on `/tmp/tainted.txt`. While the code doesn't directly control the path, it reads its content and uses it later for an LDAP query. If the content of `tainted.txt` is attacker-controlled, the attacker can place path traversal sequences (e.g., `../../`) within the file. When the `more` command is executed, if `tainted.txt` contains such sequences, it could potentially disclose or otherwise manipulate files outside of the intended `/tmp` directory, even though this code itself doesn't directly handle user-supplied pathnames. This is because the contents of the file being read influences the execution of the `more` command.</Justification>
  </Issue>
</Issues>
```"
CWE-78,src/CWE_78__object-directGet__func_preg_match-no_filtering__cat-interpretation_simple_quote.php,"<?php







class Input{
  public function getInput(){
    return $_GET['UserData'] ;
  }
}

$temp = new Input();
$tainted =  $temp->getInput();

$re = ""/^.*$/"";
if(preg_match($re, $tainted) == 1){
  $tainted = $tainted;
}
else{
  $tainted = """";
}

$query = ""cat ' $tainted '"";


$ret = system($query);


?>",$ret = system($query);,True,True,"$query = ""cat ' $tainted '"";


$ret = system($query);","```xml
<Issues>
  <Issue>
    <Type>Security</Type>
    <Weakness>CWE-78</Weakness>
    <Description>Improper Neutralization of Special Elements used in an OS Command ('OS Command Injection')</Description>
    <Severity>Critical</Severity>
    <File>File 1</File>
    <Code>$query = ""cat ' $tainted '"";


$ret = system($query);</Code>
    <Justification>The code constructs an OS command using user-controlled input ($tainted) without proper neutralization of special elements. This allows an attacker to inject arbitrary OS commands.</Justification>
  </Issue>
  <Issue>
    <Type>Security</Type>
    <Weakness>CWE-22</Weakness>
    <Description>Improper Limitation of a Pathname to a Restricted Directory ('Path Traversal')</Description>
    <Severity>High</Severity>
    <File>File 1</File>
    <Code>$query = ""cat ' $tainted '"";


$ret = system($query);</Code>
    <Justification>The code uses external input ($tainted) to construct a pathname for the 'cat' command without proper validation. This can lead to path traversal vulnerabilities, allowing attackers to access files outside the intended directory.</Justification>
  </Issue>
</Issues>
```"
CWE-89,src/CWE_89__GET__no_sanitizing__join-interpretation_simple_quote.php,"<?php







$tainted = $_GET['UserData'];



$query = ""SELECT lastname, firstname FROM drivers, vehicles WHERE drivers.id = vehicles.ownerid AND vehicles.tag=' $tainted '"";


$conn = mysql_connect('localhost', 'mysql_user', 'mysql_password'); 
mysql_select_db('dbname') ;
echo ""query : "". $query .""<br /><br />"" ;

$res = mysql_query($query); 

while($data =mysql_fetch_array($res)){
print_r($data) ;
echo ""<br />"" ;
} 
mysql_close($conn);

?>","$conn = mysql_connect('localhost', 'mysql_user', 'mysql_password'); ",True,True,"$tainted = $_GET['UserData'];

$query = ""SELECT lastname, firstname FROM drivers, vehicles WHERE drivers.id = vehicles.ownerid AND vehicles.tag=' $tainted '"";","```xml
<Issues>
  <Issue>
    <Type>Security</Type>
    <Weakness>CWE-89</Weakness>
    <Description>Improper Neutralization of Special Elements used in an SQL Command ('SQL Injection')</Description>
    <Severity>Critical</Severity>
    <File>File 1</File>
    <Code>$tainted = $_GET['UserData'];

$query = ""SELECT lastname, firstname FROM drivers, vehicles WHERE drivers.id = vehicles.ownerid AND vehicles.tag=' $tainted '"";</Code>
    <Justification>The code is vulnerable to SQL injection because it directly uses unsanitized user input ($tainted) within the SQL query. An attacker could manipulate the query to extract or modify sensitive data.</Justification>
  </Issue>
  <Issue>
    <Type>Maintainability</Type>
    <Weakness>CWE-477</Weakness>
    <Description>Use of Obsolete Function</Description>
    <Severity>High</Severity>
    <File>File 1</File>
    <Code>$conn = mysql_connect('localhost', 'mysql_user', 'mysql_password'); 
mysql_select_db('dbname') ;

$res = mysql_query($query);</Code>
    <Justification>The code uses the `mysql_connect` and `mysql_query` functions, which are deprecated. This makes the code less maintainable and potentially insecure, as these functions are no longer actively maintained and may have known vulnerabilities.</Justification>
  </Issue>
</Issues>
```"
CWE-79,src/CWE_79__proc_open__func_FILTER-CLEANING-special_chars_filter__Use_untrusted_data_propertyValue_CSS-span_Style_Property_Value.php,"<!-- 
Unsafe sample
input : use proc_open to read /tmp/tainted.txt
Uses a special_chars_filter via filter_var function
File : unsafe, use of untrusted data in a property value in a span tag(CSS)
-->

<!--Copyright 2015 Bertrand STIVALET 

Permission is hereby granted, without written agreement or royalty fee, to

use, copy, modify, and distribute this software and its documentation for

any purpose, provided that the above copyright notice and the following

three paragraphs appear in all copies of this software.


IN NO EVENT SHALL AUTHORS BE LIABLE TO ANY PARTY FOR DIRECT,

INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES ARISING OUT OF THE 

USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF AUTHORS HAVE

BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.


AUTHORS SPECIFICALLY DISCLAIM ANY WARRANTIES INCLUDING, BUT NOT

LIMITED TO THE IMPLIED WARRANTIES OF MERCHANTABILITY, FITNESS FOR A

PARTICULAR PURPOSE, AND NON-INFRINGEMENT.


THE SOFTWARE IS PROVIDED ON AN ""AS-IS"" BASIS AND AUTHORS HAVE NO

OBLIGATION TO PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR

MODIFICATIONS.-->


<!DOCTYPE html>
<html>
<head/>
<body>
<?php
$descriptorspec = array(
  0 => array(""pipe"", ""r""),
  1 => array(""pipe"", ""w""),
  2 => array(""file"", ""/tmp/error-output.txt"", ""a"")
  );
$cwd = '/tmp';
$process = proc_open('more /tmp/tainted.txt', $descriptorspec, $pipes, $cwd, NULL);
if (is_resource($process)) {
  fclose($pipes[0]);
  $tainted = stream_get_contents($pipes[1]);
  fclose($pipes[1]);
  $return_value = proc_close($process);
}

$sanitized = filter_var($tainted, FILTER_SANITIZE_SPECIAL_CHARS);
  $tainted = $sanitized ;
      


echo ""<span style=\""color :"". checked_data .""\"">Hey</span>"" ;
?>
<h1>Hello World!</h1>
</body>
</html>","echo ""<span style=\""color :"". checked_data .""\"">Hey</span>"" ;",True,True,"echo ""<span style=\""color :"". checked_data .""\"">Hey</span>"" ;
?>
<h1>Hello World!</h1>","```xml
<Issues>
  <Issue>
    <Type>Security</Type>
    <Weakness>CWE-79</Weakness>
    <Description>Improper Neutralization of Input During Web Page Generation ('Cross-site Scripting')</Description>
    <Severity>Medium</Severity>
    <File>File 1</File>
    <Code>

echo ""&lt;span style=\""color :"". checked_data .""\""&gt;Hey&lt;/span&gt;"" ;
?>
&lt;h1&gt;Hello World!&lt;/h1&gt;</Code>
    <Justification>The code is using a variable checked_data, whose content depends on user-controlled input, directly in an HTML attribute context without proper output encoding. An attacker could inject malicious code (e.g., Javascript) by manipulating the input in /tmp/tainted.txt, potentially leading to XSS vulnerability.</Justification>
  </Issue>
  <Issue>
    <Type>Security</Type>
    <Weakness>CWE-22</Weakness>
    <Description>Improper Limitation of a Pathname to a Restricted Directory ('Path Traversal')</Description>
    <Severity>Medium</Severity>
    <File>File 1</File>
    <Code>$process = proc_open('more /tmp/tainted.txt', $descriptorspec, $pipes, $cwd, NULL);
if (is_resource($process)) {
  fclose($pipes[0]);
  $tainted = stream_get_contents($pipes[1]);
  fclose($pipes[1]);</Code>
    <Justification>The application reads data from the file `/tmp/tainted.txt`. Although it's a fixed path, if the application intends to restrict file access within a specific directory, this could be considered a path traversal if `/tmp` is outside the intended directory and an attacker can influence the contents or existence of `tainted.txt`.</Justification>
  </Issue>
  <Issue>
    <Type>Security</Type>
    <Weakness>CWE-77</Weakness>
    <Description>Improper Neutralization of Special Elements used in a Command ('Command Injection')</Description>
    <Severity>High</Severity>
    <File>File 1</File>
    <Code>$process = proc_open('more /tmp/tainted.txt', $descriptorspec, $pipes, $cwd, NULL);
if (is_resource($process)) {
  fclose($pipes[0]);
  $tainted = stream_get_contents($pipes[1]);
  fclose($pipes[1]);</Code>
    <Justification>The application executes the external command `more /tmp/tainted.txt` using `proc_open`. Although the path to `tainted.txt` is fixed, an attacker who can influence the contents of this file could inject shell commands within it (e.g., using backticks or other command injection techniques) that are then executed by `more`, leading to command injection.</Justification>
  </Issue>
  <Issue>
    <Type>Security</Type>
    <Weakness>CWE-252</Weakness>
    <Description>Unchecked Return Value</Description>
    <Severity>Low</Severity>
    <File>File 1</File>
    <Code>  $return_value = proc_close($process);
}

$sanitized = filter_var($tainted, FILTER_SANITIZE_SPECIAL_CHARS);
  $tainted = $sanitized ;</Code>
    <Justification>The code calls `proc_close` but doesn't check its return value (`$return_value`). If `proc_close` fails, the application might not be aware of the failure, which could lead to resource leaks or other unexpected behavior.</Justification>
  </Issue>
  <Issue>
    <Type>Security</Type>
    <Weakness>CWE-477</Weakness>
    <Description>Use of Obsolete Function</Description>
    <Severity>Low</Severity>
    <File>File 1</File>
    <Code>  $return_value = proc_close($process);
}

$sanitized = filter_var($tainted, FILTER_SANITIZE_SPECIAL_CHARS);
  $tainted = $sanitized ;</Code>
    <Justification>Although not strictly obsolete, relying solely on `FILTER_SANITIZE_SPECIAL_CHARS` for sanitization might be insufficient, especially when dealing with untrusted data intended for use in contexts beyond basic HTML. Consider using more robust and context-aware sanitization/encoding methods.</Justification>
  </Issue>
  <Issue>
    <Type>Reliability</Type>
    <Weakness>CWE-252</Weakness>
    <Description>Unchecked Return Value</Description>
    <Severity>Low</Severity>
    <File>File 1</File>
    <Code>if (is_resource($process)) {
  fclose($pipes[0]);
  $tainted = stream_get_contents($pipes[1]);
  fclose($pipes[1]);
  $return_value = proc_close($process);
}</Code>
    <Justification>The code does not check the return values of `fclose()` and `stream_get_contents()`. These functions can fail, and not checking their return values can lead to unhandled errors and unexpected behavior.</Justification>
  </Issue>
  <Issue>
    <Type>Performance Efficiency</Type>
    <Weakness>CWE-1050</Weakness>
    <Description>Excessive Platform Resource Consumption within a Loop</Description>
    <Severity>Low</Severity>
    <File>File 1</File>
    <Code>if (is_resource($process)) {
  fclose($pipes[0]);
  $tainted = stream_get_contents($pipes[1]);
  fclose($pipes[1]);
  $return_value = proc_close($process);
}</Code>
    <Justification>While this code isn't directly within a loop, creating a process and reading its output can be a relatively expensive operation. Repeatedly calling this code could lead to performance issues if not handled carefully.</Justification>
  </Issue>
</Issues>
```"
CWE-79,src/CWE_79__unserialize__func_mysql_real_escape_string__Use_untrusted_data_propertyValue_CSS-span_Style_Property_Value.php,"<!-- 
Unsafe sample
input : Get a serialize string in POST and unserialize it
SANITIZE : use of mysql_real_escape string
File : unsafe, use of untrusted data in a property value in a span tag(CSS)
-->

<!--Copyright 2015 Bertrand STIVALET 

Permission is hereby granted, without written agreement or royalty fee, to

use, copy, modify, and distribute this software and its documentation for

any purpose, provided that the above copyright notice and the following

three paragraphs appear in all copies of this software.


IN NO EVENT SHALL AUTHORS BE LIABLE TO ANY PARTY FOR DIRECT,

INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES ARISING OUT OF THE 

USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF AUTHORS HAVE

BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.


AUTHORS SPECIFICALLY DISCLAIM ANY WARRANTIES INCLUDING, BUT NOT

LIMITED TO THE IMPLIED WARRANTIES OF MERCHANTABILITY, FITNESS FOR A

PARTICULAR PURPOSE, AND NON-INFRINGEMENT.


THE SOFTWARE IS PROVIDED ON AN ""AS-IS"" BASIS AND AUTHORS HAVE NO

OBLIGATION TO PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR

MODIFICATIONS.-->


<!DOCTYPE html>
<html>
<head/>
<body>
<?php
$string = $_POST['UserData'] ;
$tainted = unserialize($string);
    

$tainted = mysql_real_escape_string($tainted);


echo ""<span style=\""color :"". checked_data .""\"">Hey</span>"" ;
?>
<h1>Hello World!</h1>
</body>
</html>","echo ""<span style=\""color :"". checked_data .""\"">Hey</span>"" ;",True,True,"$tainted = unserialize($string);
    

$tainted = mysql_real_escape_string($tainted);


echo ""<span style=\""color :"". checked_data .""\"">Hey</span>"" ;","```xml
<Issues>
  <Issue>
    <Type>Security</Type>
    <Weakness>CWE-502</Weakness>
    <Description>Deserialization of Untrusted Data</Description>
    <Severity>High</Severity>
    <File>File 1</File>
    <Code>$string = $_POST['UserData'] ;
$tainted = unserialize($string);</Code>
    <Justification>The code uses unserialize() on user-provided data from $_POST['UserData'], which can lead to arbitrary code execution. Deserialization of untrusted data is a critical security vulnerability.</Justification>
  </Issue>
  <Issue>
    <Type>Security</Type>
    <Weakness>CWE-79</Weakness>
    <Description>Improper Neutralization of Input During Web Page Generation ('Cross-site Scripting')</Description>
    <Severity>Medium</Severity>
    <File>File 1</File>
    <Code>
$tainted = unserialize($string);
    

$tainted = mysql_real_escape_string($tainted);


echo ""&lt;span style=\""color :"". checked_data .""\""&gt;Hey&lt;/span&gt;"" ;
</Code>
    <Justification>The code attempts to sanitize user input using mysql_real_escape_string(). However, this function is intended for escaping data to be used in MySQL queries, not for preventing Cross-Site Scripting (XSS). The variable `checked_data` within the style attribute is vulnerable, since the serialized data (after being un-serialized and 'sanitized' with mysql_real_escape_string) is injected directly into the HTML output within a style attribute. This can lead to XSS if the data contains malicious code.</Justification>
  </Issue>
  <Issue>
    <Type>Security</Type>
    <Weakness>CWE-477</Weakness>
    <Description>Use of Obsolete Function</Description>
    <Severity>Low</Severity>
    <File>File 1</File>
    <Code>$tainted = mysql_real_escape_string($tainted);</Code>
    <Justification>The code uses the function `mysql_real_escape_string`, which is deprecated. It's recommended to use `mysqli_real_escape_string` or prepared statements with PDO instead for security reasons and future compatibility.</Justification>
  </Issue>
</Issues>
```"
CWE-91,src/CWE_91__GET__func_FILTER-VALIDATION-email_filter__username_text-sprintf_%s_simple_quote.php,"<?php







$tainted = $_GET['UserData'];

if (filter_var($sanitized, FILTER_VALIDATE_EMAIL))
  $tainted = $sanitized ;
else
  $tainted = """" ;

$query = sprintf(""


$xml = simplexml_load_file(""users.xml"");
echo ""query : "". $query .""<br /><br />"" ;

$res=$xml->xpath($query);
print_r($res);
echo ""<br />"" ;

?>","$xml = simplexml_load_file(""users.xml"");",True,True,"$tainted = $_GET['UserData'];

if (filter_var($sanitized, FILTER_VALIDATE_EMAIL))
  $tainted = $sanitized ;
else
  $tainted = """" ;

$query = sprintf(""
...","```xml
<Issues>
  <Issue>
    <Type>Security</Type>
    <Weakness>CWE-91</Weakness>
    <Description>XML Injection (aka Blind XPath Injection)</Description>
    <Severity>High</Severity>
    <File>File 1</File>
    <Code>$tainted = $_GET['UserData'];

if (filter_var($sanitized, FILTER_VALIDATE_EMAIL))
  $tainted = $sanitized ;
else
  $tainted = """" ;

$query = sprintf(""
...</Code>
    <Justification>The code uses user-controlled input ($tainted) to construct an XPath query without proper neutralization of special elements. This allows attackers to modify the syntax, content, or commands of the XML before it is processed, leading to potential data extraction or denial-of-service attacks. The filter_var function is being used on $sanitized, but it's never initialized, and therefore doesn't sanitize $tainted.</Justification>
  </Issue>
  <Issue>
    <Type>Reliability</Type>
    <Weakness>CWE-457</Weakness>
    <Description>Use of uninitialized variable</Description>
    <Severity>Medium</Severity>
    <File>File 1</File>
    <Code>$tainted = $_GET['UserData'];

if (filter_var($sanitized, FILTER_VALIDATE_EMAIL))
  $tainted = $sanitized ;
else
  $tainted = """" ;</Code>
    <Justification>The variable '$sanitized' is used within the 'filter_var' function without being initialized, leading to unpredictable behavior. The if statement will always evaluate to false as $sanitized is undefined.</Justification>
  </Issue>
  <Issue>
    <Type>Security</Type>
    <Weakness>CWE-570</Weakness>
    <Description>Expression is Always False</Description>
    <Severity>Low</Severity>
    <File>File 1</File>
    <Code>$tainted = $_GET['UserData'];

if (filter_var($sanitized, FILTER_VALIDATE_EMAIL))
  $tainted = $sanitized ;
else
  $tainted = """" ;</Code>
    <Justification>The if statement will always evaluate to false as $sanitized is undefined. Thus, the true branch will never execute.</Justification>
  </Issue>
</Issues>
```"
CWE-79,src/CWE_79__system__func_rawurlencode__Unsafe_use_untrusted_data-style.php,"<!-- 
Unsafe sample
input : execute a ls command using the function system, and put the last result in $tainted
SANITIZE : use of rawurlencode
File : unsafe, use of untrusted data in CSS
-->

<!--Copyright 2015 Bertrand STIVALET 

Permission is hereby granted, without written agreement or royalty fee, to

use, copy, modify, and distribute this software and its documentation for

any purpose, provided that the above copyright notice and the following

three paragraphs appear in all copies of this software.


IN NO EVENT SHALL AUTHORS BE LIABLE TO ANY PARTY FOR DIRECT,

INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES ARISING OUT OF THE 

USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF AUTHORS HAVE

BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.


AUTHORS SPECIFICALLY DISCLAIM ANY WARRANTIES INCLUDING, BUT NOT

LIMITED TO THE IMPLIED WARRANTIES OF MERCHANTABILITY, FITNESS FOR A

PARTICULAR PURPOSE, AND NON-INFRINGEMENT.


THE SOFTWARE IS PROVIDED ON AN ""AS-IS"" BASIS AND AUTHORS HAVE NO

OBLIGATION TO PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR

MODIFICATIONS.-->


<!DOCTYPE html>
<html>
<head>
<style>
<?php
$tainted = system('ls', $retval);

$tainted = rawurlencode($tainted);


echo $tainted ;
?>
</style>
</head>
<body>
<h1>Hello World!</h1>
</body>
</html>",echo $tainted ;,True,True,"echo $tainted ;
?>","```xml
<Issues>
  <Issue>
    <Type>Security</Type>
    <Weakness>CWE-78</Weakness>
    <Description>Improper Neutralization of Special Elements used in a Command ('Command Injection')</Description>
    <Severity>High</Severity>
    <File>File 1</File>
    <Code>$tainted = system('ls', $retval);</Code>
    <Justification>The code uses the `system()` function to execute an external command ('ls'). Although the output of the command is later encoded using `rawurlencode()`, the initial execution of the command itself is vulnerable to command injection if the arguments passed to `ls` were to originate from an untrusted source (which is not the case here but represents potential for misuse). Even though retval is used, the initial command is still executed.</Justification>
  </Issue>
  <Issue>
    <Type>Security</Type>
    <Weakness>CWE-79</Weakness>
    <Description>Improper Neutralization of Input During Web Page Generation ('Cross-site Scripting')</Description>
    <Severity>Medium</Severity>
    <File>File 1</File>
    <Code>
echo $tainted ;
?>
</Code>
    <Justification>The code outputs the `$tainted` variable directly into the &lt;style&gt; tag. Even though rawurlencode is used, this is inadequate for CSS context, since rawurlencode is designed for encoding URL parameters. An attacker might inject malicious CSS code that could be executed when the page is rendered.
</Justification>
  </Issue>
  <Issue>
    <Type>Maintainability</Type>
    <Weakness>CWE-477</Weakness>
    <Description>Use of Obsolete Function</Description>
    <Severity>Low</Severity>
    <File>File 1</File>
    <Code>$tainted = system('ls', $retval);</Code>
    <Justification>The `system()` function is generally discouraged due to security concerns and potential lack of control over the execution environment. More secure and maintainable alternatives, such as `proc_open()` or `shell_exec()`, should be considered.</Justification>
  </Issue>
</Issues>
```"
CWE-78,src/CWE_78__POST__func_FILTER-CLEANING-full_special_chars_filter__ls-sprintf_%s_simple_quote.php,"<?php







$tainted = $_POST['UserData'];

$sanitized = filter_var($tainted, FILTER_SANITIZE_FULL_SPECIAL_CHARS);
  $tainted = $sanitized ;
     

$query = sprintf(""ls '%s'"", $tainted);


$ret = system($query);


?>",$ret = system($query);,True,True,"$tainted = $_POST['UserData'];

$sanitized = filter_var($tainted, FILTER_SANITIZE_FULL_SPECIAL_CHARS);
  $tainted = $sanitized ;
     
...","```xml
<Issues>
  <Issue>
    <Type>Security</Type>
    <Weakness>CWE-78</Weakness>
    <Description>Improper Neutralization of Special Elements used in a Command ('Command Injection')</Description>
    <Severity>High</Severity>
    <File>File 1</File>
    <Code>$tainted = $_POST['UserData'];

$sanitized = filter_var($tainted, FILTER_SANITIZE_FULL_SPECIAL_CHARS);
  $tainted = $sanitized ;
     
...</Code>
    <Justification>The code takes user input from $_POST['UserData'], sanitizes it using filter_var with FILTER_SANITIZE_FULL_SPECIAL_CHARS, and then uses it in a system() call. Even though the input is sanitized, it might not be sufficient to prevent command injection, as system() executes a shell command, which can interpret shell metacharacters even after the sanitization. Therefore, it's possible for an attacker to inject arbitrary commands.</Justification>
  </Issue>
</Issues>
```"
CWE-91,src/CWE_91__POST__no_sanitizing__username_text-sprintf_%s_simple_quote.php,"<?php







$tainted = $_POST['UserData'];



$query = sprintf(""


$xml = simplexml_load_file(""users.xml"");
echo ""query : "". $query .""<br /><br />"" ;

$res=$xml->xpath($query);
print_r($res);
echo ""<br />"" ;

?>","$xml = simplexml_load_file(""users.xml"");",True,True,"$tainted = $_POST['UserData'];\n\n\n\n$query = sprintf(""</Description>\n    <Severity>High</Severity>
    <File>File 1</File>
    <Code>$xml = simplexml_load_file(""users.xml"");\necho ""query : "". $query .""<br /><br />"" ;\n\n$res=$xml->xpath($query);","```xml
<Issues>
  <Issue>
    <Type>Security</Type>
    <Weakness>CWE-91</Weakness>
    <Description>XML Injection (aka Blind XPath Injection)</Description>
    <Severity>High</Severity>
    <File>File 1</File>
    <Code>$tainted = $_POST['UserData'];\n\n\n\n$query = sprintf(""</Description>\n    <Severity>High</Severity>
    <File>File 1</File>
    <Code>$xml = simplexml_load_file(""users.xml"");\necho ""query : "". $query .""<br /><br />"" ;\n\n$res=$xml->xpath($query);</Code>
    <Justification>The code uses user-controlled data ($query) in an xpath query without proper neutralization.  This allows an attacker to control the structure of the query and potentially extract sensitive information or cause other unintended behavior.</Justification>
  </Issue>
</Issues>
```"
CWE-79,src/CWE_79__fopen__whitelist_using_array__Unsafe_use_untrusted_data-attribute_Name.php,"<!-- 
Unsafe sample
input : use fopen to read /tmp/tainted.txt and put the first line in $tainted
SANITIZE : use in_array to check if $tainted is in the white list
File : unsafe, use of untrusted data in an attribute name
-->

<!--Copyright 2015 Bertrand STIVALET 

Permission is hereby granted, without written agreement or royalty fee, to

use, copy, modify, and distribute this software and its documentation for

any purpose, provided that the above copyright notice and the following

three paragraphs appear in all copies of this software.


IN NO EVENT SHALL AUTHORS BE LIABLE TO ANY PARTY FOR DIRECT,

INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES ARISING OUT OF THE 

USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF AUTHORS HAVE

BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.


AUTHORS SPECIFICALLY DISCLAIM ANY WARRANTIES INCLUDING, BUT NOT

LIMITED TO THE IMPLIED WARRANTIES OF MERCHANTABILITY, FITNESS FOR A

PARTICULAR PURPOSE, AND NON-INFRINGEMENT.


THE SOFTWARE IS PROVIDED ON AN ""AS-IS"" BASIS AND AUTHORS HAVE NO

OBLIGATION TO PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR

MODIFICATIONS.-->


<!DOCTYPE html>
<html>
<body>
<?php
$handle = @fopen(""/tmp/tainted.txt"", ""r"");

if ($handle) {
  if(($tainted = fgets($handle, 4096)) == false) {
    $tainted = """";
  }
  fclose($handle);
} else {
  $tainted = """";
}

$legal_table = array(""safe1"", ""safe2"");
if (in_array($tainted, $legal_table, true)) {
  $tainted = $tainted;
} else {
  $tainted = $legal_table[0];
}


echo ""<div "". $tainted .""= bob />"" ;
?>
<h1>Hello World!</h1>
</div>
</body>
</html>","echo ""<div "". $tainted .""= bob />"" ;",True,True,"echo ""<div "". $tainted .""= bob />"" ;","```xml
<Issues>
  <Issue>
    <Type>Security</Type>
    <Weakness>CWE-79</Weakness>
    <Description>Improper Neutralization of Input During Web Page Generation ('Cross-site Scripting')</Description>
    <Severity>Medium</Severity>
    <File>File 1</File>
    <Code>echo ""&lt;div "". $tainted .""= bob />"" ;</Code>
    <Justification>The code uses unsanitized input $tainted directly in an HTML attribute name. Although the code attempts to sanitize by whitelisting, it is insufficient. An attacker could craft an input that bypasses the intended check (e.g., inject javascript). This can lead to XSS vulnerability.</Justification>
  </Issue>
  <Issue>
    <Type>Reliability</Type>
    <Weakness>CWE-252</Weakness>
    <Description>Unchecked Return Value</Description>
    <Severity>Low</Severity>
    <File>File 1</File>
    <Code>  if(($tainted = fgets($handle, 4096)) == false) {
    $tainted = """";
  }</Code>
    <Justification>The code does not properly check if fgets fails. While a default value is assigned if fgets fails, the failure itself isn't handled, which might lead to unexpected behavior in subsequent logic.</Justification>
  </Issue>
</Issues>
```"
CWE-90,src/CWE_90__GET__no_sanitizing__userByMail-sprintf_%s_simple_quote.php,"<?php







$tainted = $_GET['UserData'];



$query = sprintf(""(&(objectCategory=person)(objectClass=user)(mail='%s'))"", $tainted);


$ds=ldap_connect(""localhost""); 
$r=ldap_bind($ds);
$sr=ldap_search($ds,""o=My Company, c=US"", $query);  
ldap_close($ds);

?>","$ds=ldap_connect(""localhost"");",True,True,"$tainted = $_GET['UserData'];

$query = sprintf(""(&(objectCategory=person)(objectClass=user)(mail='%s'))"", $tainted);","```xml
<Issues>
  <Issue>
    <Type>Security</Type>
    <Weakness>CWE-90</Weakness>
    <Description>Improper Neutralization of Special Elements used in an LDAP Query ('LDAP Injection')</Description>
    <Severity>High</Severity>
    <File>File 1</File>
    <Code>$tainted = $_GET['UserData'];

$query = sprintf(""(&(objectCategory=person)(objectClass=user)(mail='%s'))"", $tainted);</Code>
    <Justification>The code directly incorporates user-supplied data into an LDAP query without proper sanitization. This allows an attacker to inject malicious LDAP syntax, potentially bypassing authentication or retrieving sensitive information.</Justification>
  </Issue>
</Issues>
```"
CWE-78,src/CWE_78__GET__func_FILTER-CLEANING-email_filter__ls-sprintf_%s_simple_quote.php,"<?php







$tainted = $_GET['UserData'];

$sanitized = filter_var($tainted, FILTER_SANITIZE_EMAIL);
if (filter_var($sanitized, FILTER_VALIDATE_EMAIL))
  $tainted = $sanitized ;
else
  $tainted = """" ;

$query = sprintf(""ls '%s'"", $tainted);


$ret = system($query);


?>",$ret = system($query);,True,True,"$tainted = $_GET['UserData'];

$sanitized = filter_var($tainted, FILTER_SANITIZE_EMAIL);
if (filter_var($sanitized, FILTER_VALIDATE_EMAIL))
  $tainted = $sanitized ;
else
  $tainted = """" ;

$query = sprintf(""ls '%s'"", $tainted);


$ret = system($query);","```xml
<Issues>
  <Issue>
    <Type>Security</Type>
    <Weakness>CWE-78</Weakness>
    <Description>Improper Neutralization of Special Elements used in a Command ('Command Injection')</Description>
    <Severity>High</Severity>
    <File>File 1</File>
    <Code>$tainted = $_GET['UserData'];

$sanitized = filter_var($tainted, FILTER_SANITIZE_EMAIL);
if (filter_var($sanitized, FILTER_VALIDATE_EMAIL))
  $tainted = $sanitized ;
else
  $tainted = """" ;

$query = sprintf(""ls '%s'"", $tainted);


$ret = system($query);</Code>
    <Justification>The code is vulnerable to command injection because it uses user-supplied data ($tainted) directly in a system command without proper sanitization. Although the code attempts to sanitize the input as an email address, this is insufficient to prevent command injection, as an attacker can still inject shell metacharacters. Using sprintf to construct the command and then executing it with system() allows arbitrary commands to be executed on the server.</Justification>
  </Issue>
</Issues>
```"
CWE-79,src/CWE_79__SESSION__func_FILTER-CLEANING-magic_quotes_filter__Use_untrusted_data_propertyValue_CSS-quoted_Property_Value.php,"<!-- 
Unsafe sample
input : get the UserData field of $_SESSION
Uses a magic_quotes_filter via filter_var function
File : unsafe, use of untrusted data in a quoted property value (CSS)
-->

<!--Copyright 2015 Bertrand STIVALET 

Permission is hereby granted, without written agreement or royalty fee, to

use, copy, modify, and distribute this software and its documentation for

any purpose, provided that the above copyright notice and the following

three paragraphs appear in all copies of this software.


IN NO EVENT SHALL AUTHORS BE LIABLE TO ANY PARTY FOR DIRECT,

INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES ARISING OUT OF THE 

USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF AUTHORS HAVE

BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.


AUTHORS SPECIFICALLY DISCLAIM ANY WARRANTIES INCLUDING, BUT NOT

LIMITED TO THE IMPLIED WARRANTIES OF MERCHANTABILITY, FITNESS FOR A

PARTICULAR PURPOSE, AND NON-INFRINGEMENT.


THE SOFTWARE IS PROVIDED ON AN ""AS-IS"" BASIS AND AUTHORS HAVE NO

OBLIGATION TO PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR

MODIFICATIONS.-->


<!DOCTYPE html>
<html>
<head>
<style>
<?php
$tainted = $_SESSION['UserData'];

$sanitized = filter_var($tainted, FILTER_SANITIZE_MAGIC_QUOTES);
  $tainted = $sanitized ;
      


echo ""body { color :\'"". $tainted .""\' ; }"" ;
?>
</style> 
</head>
<body>
<h1>Hello World!</h1>
</body>
</html>","echo ""body { color :\'"". $tainted .""\' ; }"" ;",True,True,"echo ""body { color :\'"". $tainted .""\' ; }"" ;","```xml
<Issues>
  <Issue>
    <Type>Security</Type>
    <Weakness>CWE-79</Weakness>
    <Description>Improper Neutralization of Input During Web Page Generation ('Cross-site Scripting')</Description>
    <Severity>Medium</Severity>
    <File>File 1</File>
    <Code>echo ""body { color :\'"". $tainted .""\' ; }"" ;</Code>
    <Justification>The code uses untrusted data ($tainted) directly in the CSS output without proper neutralization, which can lead to Cross-Site Scripting (XSS) vulnerabilities. Although magic quotes are applied, they are deprecated and do not provide sufficient protection against XSS in all cases.</Justification>
  </Issue>
  <Issue>
    <Type>Security</Type>
    <Weakness>CWE-477</Weakness>
    <Description>Use of Obsolete Function</Description>
    <Severity>Low</Severity>
    <File>File 1</File>
    <Code>$sanitized = filter_var($tainted, FILTER_SANITIZE_MAGIC_QUOTES);</Code>
    <Justification>The code uses FILTER_SANITIZE_MAGIC_QUOTES, which relies on magic_quotes_gpc. magic_quotes_gpc is deprecated and has been removed from PHP, making this usage obsolete and ineffective, reducing the overall security of the application.</Justification>
  </Issue>
</Issues>
```"
CWE-90,src/CWE_90__popen__func_FILTER-VALIDATION-email_filter__name-interpretation_simple_quote.php,"<?php







$handle = popen('/bin/cat /tmp/tainted.txt', 'r');
$tainted = fread($handle, 4096);
pclose($handle);

if (filter_var($sanitized, FILTER_VALIDATE_EMAIL))
  $tainted = $sanitized ;
else
  $tainted = """" ;

$query = ""name=' $tainted '"";


$ds=ldap_connect(""localhost""); 
$r=ldap_bind($ds);
$sr=ldap_search($ds,""o=My Company, c=US"", $query);  
ldap_close($ds);

?>","$ds=ldap_connect(""localhost"");",True,True,"$tainted = fread($handle, 4096);
pclose($handle);

if (filter_var($sanitized, FILTER_VALIDATE_EMAIL))
  $tainted = $sanitized ;
else
  $tainted = """" ;

$query = ""name=' $tainted '"";


$ds=ldap_connect(""localhost""); 
$r=ldap_bind($ds);
$sr=ldap_search($ds,""o=My Company, c=US"", $query);  
ldap_close($ds);","```xml
<Issues>
  <Issue>
    <Type>Security</Type>
    <Weakness>CWE-77</Weakness>
    <Description>Improper Neutralization of Special Elements used in a Command ('Command Injection')</Description>
    <Severity>High</Severity>
    <File>File 1</File>
    <Code>$handle = popen('/bin/cat /tmp/tainted.txt', 'r');
$tainted = fread($handle, 4096);
pclose($handle);</Code>
    <Justification>The code uses popen to execute a command. The command includes a hardcoded path '/bin/cat /tmp/tainted.txt'. Although the path is hardcoded, the popen function itself can be a potential command injection vulnerability if the first argument is derived from an external source.</Justification>
  </Issue>
  <Issue>
    <Type>Security</Type>
    <Weakness>CWE-90</Weakness>
    <Description>Improper Neutralization of Special Elements used in an LDAP Query ('LDAP Injection')</Description>
    <Severity>High</Severity>
    <File>File 1</File>
    <Code>$tainted = fread($handle, 4096);
pclose($handle);

if (filter_var($sanitized, FILTER_VALIDATE_EMAIL))
  $tainted = $sanitized ;
else
  $tainted = """" ;

$query = ""name=' $tainted '"";


$ds=ldap_connect(""localhost""); 
$r=ldap_bind($ds);
$sr=ldap_search($ds,""o=My Company, c=US"", $query);  
ldap_close($ds);</Code>
    <Justification>The code constructs an LDAP query by directly embedding user-controlled data ($tainted) into the query string.  Even if $tainted is an empty string, it is still being concatenated. This can lead to LDAP injection vulnerabilities if $tainted contains malicious LDAP control characters.</Justification>
  </Issue>
</Issues>
```"
CWE-79,src/CWE_79__object-indexArray__func_FILTER-VALIDATION-email_filter__Use_untrusted_data-div.php,"<!-- 
Unsafe sample
input : get the field userData from the variable $_GET via an object, which store it in a array
Flushes content of $sanitized if the filter email_filter is not applied
File : use of untrusted data in a div tag
-->

<!--Copyright 2015 Bertrand STIVALET 

Permission is hereby granted, without written agreement or royalty fee, to

use, copy, modify, and distribute this software and its documentation for

any purpose, provided that the above copyright notice and the following

three paragraphs appear in all copies of this software.


IN NO EVENT SHALL AUTHORS BE LIABLE TO ANY PARTY FOR DIRECT,

INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES ARISING OUT OF THE 

USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF AUTHORS HAVE

BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.


AUTHORS SPECIFICALLY DISCLAIM ANY WARRANTIES INCLUDING, BUT NOT

LIMITED TO THE IMPLIED WARRANTIES OF MERCHANTABILITY, FITNESS FOR A

PARTICULAR PURPOSE, AND NON-INFRINGEMENT.


THE SOFTWARE IS PROVIDED ON AN ""AS-IS"" BASIS AND AUTHORS HAVE NO

OBLIGATION TO PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR

MODIFICATIONS.-->


<!DOCTYPE html>
<html>
<head/>
<body>
<div>
<?php
class Input{
  private $input;

  public function getInput(){
    return $this->input['realOne'];
  }

  public  function __construct(){
    $this->input = array();
    $this->input['test']= 'safe' ;
    $this->input['realOne']= $_GET['UserData'] ;
    $this->input['trap']= 'safe' ;
  }
}
$temp = new Input();
$tainted =  $temp->getInput();

if (filter_var($sanitized, FILTER_VALIDATE_EMAIL))
  $tainted = $sanitized ;
else
  $tainted = """" ;


echo $tainted ;
?>
</div>
<h1>Hello World!</h1>
</body>
</html>",echo $tainted ;,True,True,echo $tainted ;,"```xml
<Issues>
  <Issue>
    <Type>Security</Type>
    <Weakness>CWE-79</Weakness>
    <Description>Improper Neutralization of Input During Web Page Generation ('Cross-site Scripting')</Description>
    <Severity>Medium</Severity>
    <File>File 1</File>
    <Code>echo $tainted ;</Code>
    <Justification>The code directly echoes the variable $tainted, which is derived from user input ($_GET['UserData']), into the HTML output. This can lead to cross-site scripting (XSS) vulnerabilities if the input is not properly sanitized to neutralize or escape HTML metacharacters. The filter `FILTER_VALIDATE_EMAIL` is applied to `$sanitized` variable, but the code uses the tainted variable instead, so XSS is possible.</Justification>
  </Issue>
</Issues>
```"
CWE-79,src/CWE_79__backticks__func_urlencode__Use_untrusted_data_propertyValue_CSS-span_Style_Property_Value.php,"<!-- 
Unsafe sample
input : backticks interpretation, reading the file /tmp/tainted.txt
SANITIZE : use of urlencode
File : unsafe, use of untrusted data in a property value in a span tag(CSS)
-->

<!--Copyright 2015 Bertrand STIVALET 

Permission is hereby granted, without written agreement or royalty fee, to

use, copy, modify, and distribute this software and its documentation for

any purpose, provided that the above copyright notice and the following

three paragraphs appear in all copies of this software.


IN NO EVENT SHALL AUTHORS BE LIABLE TO ANY PARTY FOR DIRECT,

INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES ARISING OUT OF THE 

USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF AUTHORS HAVE

BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.


AUTHORS SPECIFICALLY DISCLAIM ANY WARRANTIES INCLUDING, BUT NOT

LIMITED TO THE IMPLIED WARRANTIES OF MERCHANTABILITY, FITNESS FOR A

PARTICULAR PURPOSE, AND NON-INFRINGEMENT.


THE SOFTWARE IS PROVIDED ON AN ""AS-IS"" BASIS AND AUTHORS HAVE NO

OBLIGATION TO PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR

MODIFICATIONS.-->


<!DOCTYPE html>
<html>
<head/>
<body>
<?php
$tainted = `cat /tmp/tainted.txt`;

$tainted = urlencode($tainted);


echo ""<span style=\""color :"". checked_data .""\"">Hey</span>"" ;
?>
<h1>Hello World!</h1>
</body>
</html>","echo ""<span style=\""color :"". checked_data .""\"">Hey</span>"" ;",True,True,"$tainted = urlencode($tainted);


echo ""<span style=\""color :"". checked_data .""\"">Hey</span>"" ;","```xml
<Issues>
  <Issue>
    <Type>Security</Type>
    <Weakness>CWE-77</Weakness>
    <Description>Improper Neutralization of Special Elements used in a Command ('Command Injection')</Description>
    <Severity>High</Severity>
    <File>File 1</File>
    <Code>$tainted = `cat /tmp/tainted.txt`;</Code>
    <Justification>The code uses backticks to execute a shell command.  If the filename `/tmp/tainted.txt` is controlled by a malicious user, they can inject arbitrary commands to be executed on the system.</Justification>
  </Issue>
  <Issue>
    <Type>Security</Type>
    <Weakness>CWE-79</Weakness>
    <Description>Improper Neutralization of Input During Web Page Generation ('Cross-site Scripting')</Description>
    <Severity>Medium</Severity>
    <File>File 1</File>
    <Code>
$tainted = urlencode($tainted);


echo ""&lt;span style=\""color :"". checked_data .""\""&gt;Hey&lt;/span&gt;"" ;
</Code>
    <Justification>The code uses unsanitized data `checked_data` directly within the HTML. Even with url encoding of `$tainted`, the `checked_data` variable is not sanitized, which can cause cross-site scripting (XSS) if `$tainted` or the `checked_data` variable contains malicious code.</Justification>
  </Issue>
  <Issue>
    <Type>Security</Type>
    <Weakness>CWE-79</Weakness>
    <Description>Improper Neutralization of Input During Web Page Generation ('Cross-site Scripting')</Description>
    <Severity>Medium</Severity>
    <File>File 1</File>
    <Code>
$tainted = `cat /tmp/tainted.txt`;

$tainted = urlencode($tainted);
</Code>
    <Justification>The urlencode function is used on the tainted variable but it is not sufficient because there still exists potential vulnerabilities in the context the variable is used in</Justification>
  </Issue>
</Issues>
```"
CWE-79,src/CWE_79__popen__func_http_build_query__Use_untrusted_data_attribute-unquoted_Attr.php,"<!-- 
Unsafe sample
input : Uses popen to read the file /tmp/tainted.txt using cat command
SANITIZE : use of http_build_query
File : use of untrusted data in a unquoted attribute
-->

<!--Copyright 2015 Bertrand STIVALET 

Permission is hereby granted, without written agreement or royalty fee, to

use, copy, modify, and distribute this software and its documentation for

any purpose, provided that the above copyright notice and the following

three paragraphs appear in all copies of this software.


IN NO EVENT SHALL AUTHORS BE LIABLE TO ANY PARTY FOR DIRECT,

INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES ARISING OUT OF THE 

USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF AUTHORS HAVE

BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.


AUTHORS SPECIFICALLY DISCLAIM ANY WARRANTIES INCLUDING, BUT NOT

LIMITED TO THE IMPLIED WARRANTIES OF MERCHANTABILITY, FITNESS FOR A

PARTICULAR PURPOSE, AND NON-INFRINGEMENT.


THE SOFTWARE IS PROVIDED ON AN ""AS-IS"" BASIS AND AUTHORS HAVE NO

OBLIGATION TO PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR

MODIFICATIONS.-->


<!DOCTYPE html>
<html>
<head/>
<body>
<?php
$handle = popen('/bin/cat /tmp/tainted.txt', 'r');
$tainted = fread($handle, 4096);
pclose($handle);

$tainted = http_build_query($tainted);


echo ""<div id="". $tainted ."">content</div>"" ;
?>
<h1>Hello World!</h1>
</body>
</html>","echo ""<div id="". $tainted ."">content</div>"" ;",True,True,"$tainted = http_build_query($tainted);


echo ""<div id="". $tainted ."">content</div>"" ;","```xml
<Issues>
  <Issue>
    <Type>Security</Type>
    <Weakness>CWE-79</Weakness>
    <Description>Improper Neutralization of Input During Web Page Generation ('Cross-site Scripting')</Description>
    <Severity>Medium</Severity>
    <File>File 1</File>
    <Code>$tainted = http_build_query($tainted);


echo ""&lt;div id="". $tainted ."">content&lt;/div>"" ;</Code>
    <Justification>The code uses http_build_query on tainted data and then uses this data directly in an HTML attribute without proper escaping. An attacker could inject malicious HTML or JavaScript code through the tainted data, leading to Cross-Site Scripting (XSS).</Justification>
  </Issue>
  <Issue>
    <Type>Security</Type>
    <Weakness>CWE-78</Weakness>
    <Description>Improper Neutralization of Special Elements used in an OS Command ('OS Command Injection')</Description>
    <Severity>High</Severity>
    <File>File 1</File>
    <Code>$handle = popen('/bin/cat /tmp/tainted.txt', 'r');
$tainted = fread($handle, 4096);
pclose($handle);</Code>
    <Justification>The code uses popen to execute the 'cat' command on a file named '/tmp/tainted.txt'. While the command itself is not directly using user input, the content of the file '/tmp/tainted.txt' is being read and subsequently used in the application, effectively treating the file's content as tainted input. If an attacker can control the content of '/tmp/tainted.txt', they could inject malicious commands that get executed by the popen function when other parts of the application use $tainted</Justification>
  </Issue>
</Issues>
```"
CWE-91,src/CWE_91__array-GET__func_FILTER-CLEANING-special_chars_filter__data-sprintf_%s_simple_quote.php,"<?php







$array = array();
$array[] = 'safe' ;
$array[] = $_GET['userData'] ;
$array[] = 'safe' ;
$tainted = $array[1] ;

$sanitized = filter_var($tainted, FILTER_SANITIZE_SPECIAL_CHARS);
  $tainted = $sanitized ;
      

$query = sprintf(""'%s'"", $tainted);


$xml = simplexml_load_file(""users.xml"");
echo ""query : "". $query .""<br /><br />"" ;

$res=$xml->xpath($query);
print_r($res);
echo ""<br />"" ;

?>","$xml = simplexml_load_file(""users.xml"");",False,False,,"```xml
<Issues>
  <Issue>
    <Type>Security</Type>
    <Weakness>CWE-643</Weakness>
    <Description>Improper Neutralization of Data within XPath Expressions ('XPath Injection')</Description>
    <Severity>High</Severity>
    <File>File 1</File>
    <Code>$query = sprintf(""'%s'"", $tainted);


$xml = simplexml_load_file(""users.xml"");
echo ""query : "". $query .""&lt;br /&gt;&lt;br /&gt;"" ;

$res=$xml->xpath($query);</Code>
    <Justification>The code is vulnerable to XPath injection. The $tainted variable, derived from user-supplied $_GET['userData'], is used to construct an XPath query without proper neutralization. Although the input is sanitized using FILTER_SANITIZE_SPECIAL_CHARS, this is insufficient to prevent XPath injection because it only encodes some characters. An attacker could inject malicious XPath expressions to extract sensitive information or manipulate the XML data. The sprintf function provides no protection against the injection.</Justification>
  </Issue>
</Issues>
```"
CWE-79,src/CWE_79__fopen__func_FILTER-CLEANING-special_chars_filter__Use_untrusted_data_script-window_SetInterval.php,"<!-- 
Unsafe sample
input : use fopen to read /tmp/tainted.txt and put the first line in $tainted
Uses a special_chars_filter via filter_var function
File : unsafe, use of untrusted data in the function setInterval
-->

<!--Copyright 2015 Bertrand STIVALET 

Permission is hereby granted, without written agreement or royalty fee, to

use, copy, modify, and distribute this software and its documentation for

any purpose, provided that the above copyright notice and the following

three paragraphs appear in all copies of this software.


IN NO EVENT SHALL AUTHORS BE LIABLE TO ANY PARTY FOR DIRECT,

INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES ARISING OUT OF THE 

USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF AUTHORS HAVE

BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.


AUTHORS SPECIFICALLY DISCLAIM ANY WARRANTIES INCLUDING, BUT NOT

LIMITED TO THE IMPLIED WARRANTIES OF MERCHANTABILITY, FITNESS FOR A

PARTICULAR PURPOSE, AND NON-INFRINGEMENT.


THE SOFTWARE IS PROVIDED ON AN ""AS-IS"" BASIS AND AUTHORS HAVE NO

OBLIGATION TO PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR

MODIFICATIONS.-->


<!DOCTYPE html>
<html>
<head>
<script>
<?php
$handle = @fopen(""/tmp/tainted.txt"", ""r"");

if ($handle) {
  if(($tainted = fgets($handle, 4096)) == false) {
    $tainted = """";
  }
  fclose($handle);
} else {
  $tainted = """";
}

$sanitized = filter_var($tainted, FILTER_SANITIZE_SPECIAL_CHARS);
  $tainted = $sanitized ;
      


echo ""window.setInterval('"". $tainted .""');"" ;
?>
 </script>
</head>
<body>
<h1>Hello World!</h1>
</body>
</html>","echo ""window.setInterval('"". $tainted .""');"" ;",True,True,"echo ""window.setInterval('"". $tainted .""');""","```xml
<Issues>
  <Issue>
    <Type>Security</Type>
    <Weakness>CWE-79</Weakness>
    <Description>Improper Neutralization of Input During Web Page Generation ('Cross-site Scripting')</Description>
    <Severity>High</Severity>
    <File>File 1</File>
    <Code>echo ""window.setInterval('"". $tainted .""');""</Code>
    <Justification>The code uses user-controlled input ($tainted) within the setInterval function without proper neutralization. While FILTER_SANITIZE_SPECIAL_CHARS is used, it might not be sufficient to prevent all XSS attacks, especially if the context requires more stringent encoding.  This allows for potential injection of arbitrary JavaScript code, leading to Cross-Site Scripting (XSS).</Justification>
  </Issue>
  <Issue>
    <Type>Reliability</Type>
    <Weakness>CWE-252</Weakness>
    <Description>Unchecked Return Value</Description>
    <Severity>Low</Severity>
    <File>File 1</File>
    <Code>if(($tainted = fgets($handle, 4096)) == false)</Code>
    <Justification>The code checks if `fgets` returns `false`, but it does not explicitly check for other potential errors.  `fgets` can return `false` on an error or if the end of the file is reached before any data is read.  While the code handles the `false` case, it doesn't distinguish between errors and end-of-file, potentially masking issues during file reading.</Justification>
  </Issue>
  <Issue>
    <Type>Reliability</Type>
    <Weakness>CWE-391</Weakness>
    <Description>Unchecked Error Condition</Description>
    <Severity>Low</Severity>
    <File>File 1</File>
    <Code>
$handle = @fopen(""/tmp/tainted.txt"", ""r"");

if ($handle) {
  if(($tainted = fgets($handle, 4096)) == false) {
    $tainted = """";
  }
  fclose($handle);
} else {
  $tainted = """";
}
</Code>
    <Justification>The code uses the `@` symbol to suppress errors when opening the file. If `fopen` fails, the error is suppressed, and the code proceeds as if the file was opened successfully. This can lead to unexpected behavior if the program relies on the file being opened, or if later operations assume a valid file handle.</Justification>
  </Issue>
  <Issue>
    <Type>Security</Type>
    <Weakness>CWE-477</Weakness>
    <Description>Use of Obsolete Function</Description>
    <Severity>Low</Severity>
    <File>File 1</File>
    <Code>
$handle = @fopen(""/tmp/tainted.txt"", ""r"");

if ($handle) {
  if(($tainted = fgets($handle, 4096)) == false) {
    $tainted = """";
  }
  fclose($handle);
} else {
  $tainted = """";
}
</Code>
    <Justification>`fopen`, `fgets`, and `fclose` are not inherently obsolete but their usage without proper error handling and resource management can lead to security issues. Modern alternatives might offer more robust error reporting or security features. While not a direct violation, it indicates a lack of up-to-date coding practices.</Justification>
  </Issue>
</Issues>
```"
CWE-90,src/CWE_90__object-Array__func_FILTER-CLEANING-email_filter__userByCN-sprintf_%s_simple_quote.php,"<?php







class Input{
  private $input;

  public function getInput(){
    return $this->input[1];
  }

  public  function __construct(){
    $this->input = array();
    $this->input[0]= 'safe' ;
    $this->input[1]= $_GET['UserData'] ;
    $this->input[2]= 'safe' ;
  }
}
$temp = new Input();
$tainted =  $temp->getInput();

$sanitized = filter_var($tainted, FILTER_SANITIZE_EMAIL);
if (filter_var($sanitized, FILTER_VALIDATE_EMAIL))
  $tainted = $sanitized ;
else
  $tainted = """" ;

$query = sprintf(""(&(objectCategory=person)(objectClass=user)(cn='%s'))"", $tainted);


$ds=ldap_connect(""localhost""); 
$r=ldap_bind($ds);
$sr=ldap_search($ds,""o=My Company, c=US"", $query);  
ldap_close($ds);

?>","$ds=ldap_connect(""localhost"");",True,False,"$query = sprintf(""(&(objectCategory=person)(objectClass=user)(cn='%s'))"", $tainted);","```xml
<Issues>
  <Issue>
    <Type>Security</Type>
    <Weakness>CWE-90</Weakness>
    <Description>Improper Neutralization of Special Elements used in an LDAP Query ('LDAP Injection')</Description>
    <Severity>High</Severity>
    <File>File 1</File>
    <Code>$query = sprintf(""(&(objectCategory=person)(objectClass=user)(cn='%s'))"", $tainted);</Code>
    <Justification>The code constructs an LDAP query using unsanitized user input ($tainted) directly within the sprintf function. This can lead to LDAP injection vulnerabilities where an attacker can manipulate the LDAP query to bypass authentication or access sensitive information.</Justification>
  </Issue>
  <Issue>
    <Type>Reliability</Type>
    <Weakness>CWE-252</Weakness>
    <Description>Unchecked Return Value</Description>
    <Severity>Medium</Severity>
    <File>File 1</File>
    <Code>$ds=ldap_connect(""localhost""); 
$r=ldap_bind($ds);
$sr=ldap_search($ds,""o=My Company, c=US"", $query);  
ldap_close($ds);</Code>
    <Justification>The code does not check the return values of ldap_connect, ldap_bind and ldap_search, which could lead to unexpected behavior or errors if the LDAP server is unavailable or the bind operation fails. It is possible for ldap_connect to return false, in which case, calling ldap_bind on it will cause an error.</Justification>
  </Issue>
  <Issue>
    <Type>Security</Type>
    <Weakness>CWE-252</Weakness>
    <Description>Unchecked Return Value</Description>
    <Severity>Medium</Severity>
    <File>File 1</File>
    <Code>$ds=ldap_connect(""localhost""); 
$r=ldap_bind($ds);
$sr=ldap_search($ds,""o=My Company, c=US"", $query);  
ldap_close($ds);</Code>
    <Justification>The code does not check the return values of ldap_connect, ldap_bind and ldap_search, which could lead to unexpected behavior or errors if the LDAP server is unavailable or the bind operation fails. This is a security issue because a failure to connect or authenticate may result in the application continuing with incorrect assumptions.</Justification>
  </Issue>
  <Issue>
    <Type>Reliability</Type>
    <Weakness>CWE-404</Weakness>
    <Description>Improper Resource Shutdown or Release</Description>
    <Severity>Low</Severity>
    <File>File 1</File>
    <Code>ldap_close($ds);</Code>
    <Justification>If ldap_connect fails and returns false, $ds will be false. Calling ldap_close on a non-resource may cause an error. It's better to check if ldap_connect was successful before attempting to close the connection.</Justification>
  </Issue>
</Issues>
```"
CWE-79,src/CWE_79__array-GET__func_rawurlencode__Unsafe_use_untrusted_data-script.php,"<!-- 
Unsafe sample
input : get the $_GET['userData'] in an array
SANITIZE : use of rawurlencode
File : unsafe, use of untrusted data in a script
-->

<!--Copyright 2015 Bertrand STIVALET 

Permission is hereby granted, without written agreement or royalty fee, to

use, copy, modify, and distribute this software and its documentation for

any purpose, provided that the above copyright notice and the following

three paragraphs appear in all copies of this software.


IN NO EVENT SHALL AUTHORS BE LIABLE TO ANY PARTY FOR DIRECT,

INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES ARISING OUT OF THE 

USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF AUTHORS HAVE

BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.


AUTHORS SPECIFICALLY DISCLAIM ANY WARRANTIES INCLUDING, BUT NOT

LIMITED TO THE IMPLIED WARRANTIES OF MERCHANTABILITY, FITNESS FOR A

PARTICULAR PURPOSE, AND NON-INFRINGEMENT.


THE SOFTWARE IS PROVIDED ON AN ""AS-IS"" BASIS AND AUTHORS HAVE NO

OBLIGATION TO PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR

MODIFICATIONS.-->


<!DOCTYPE html>
<html>
<head>
<script>
<?php
$array = array();
$array[] = 'safe' ;
$array[] = $_GET['userData'] ;
$array[] = 'safe' ;
$tainted = $array[1] ;

$tainted = rawurlencode($tainted);


echo $tainted ;
?>
</script>
</head>
<body onload=""xss()"">
<h1>Hello World!</h1>
</body>
</html>",echo $tainted ;,True,True,"<![CDATA[<?php
$array = array();
$array[] = 'safe' ;
$array[] = $_GET['userData'] ;
$array[] = 'safe' ;
$tainted = $array[1] ;

$tainted = rawurlencode($tainted);


echo $tainted ;
?>]]>","```xml
<Issues>
  <Issue>
    <Type>Security</Type>
    <Weakness>CWE-79</Weakness>
    <Description>Improper Neutralization of Input During Web Page Generation ('Cross-site Scripting')</Description>
    <Severity>High</Severity>
    <File>File 1</File>
    <Code><![CDATA[<?php
$array = array();
$array[] = 'safe' ;
$array[] = $_GET['userData'] ;
$array[] = 'safe' ;
$tainted = $array[1] ;

$tainted = rawurlencode($tainted);


echo $tainted ;
?>]]></Code>
    <Justification>The code uses rawurlencode on user-controlled input from $_GET['userData']. Although rawurlencode encodes characters to prevent URL interpretation, it does not prevent XSS when the encoded string is later used in a &lt;script> tag. The user input is directly echoed into the script block, which is then executed. An attacker can inject malicious JavaScript code by crafting the userData parameter, leading to Cross-Site Scripting (XSS). The rawurlencode function is insufficient to neutralize XSS vulnerabilities in this context.</Justification>
  </Issue>
</Issues>
```"
CWE-79,src/CWE_79__shell_exec__func_rawurlencode__Use_untrusted_data_propertyValue_CSS-quoted_Property_Value.php,"<!-- 
Unsafe sample
input : use shell_exec to cat /tmp/tainted.txt
SANITIZE : use of rawurlencode
File : unsafe, use of untrusted data in a quoted property value (CSS)
-->

<!--Copyright 2015 Bertrand STIVALET 

Permission is hereby granted, without written agreement or royalty fee, to

use, copy, modify, and distribute this software and its documentation for

any purpose, provided that the above copyright notice and the following

three paragraphs appear in all copies of this software.


IN NO EVENT SHALL AUTHORS BE LIABLE TO ANY PARTY FOR DIRECT,

INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES ARISING OUT OF THE 

USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF AUTHORS HAVE

BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.


AUTHORS SPECIFICALLY DISCLAIM ANY WARRANTIES INCLUDING, BUT NOT

LIMITED TO THE IMPLIED WARRANTIES OF MERCHANTABILITY, FITNESS FOR A

PARTICULAR PURPOSE, AND NON-INFRINGEMENT.


THE SOFTWARE IS PROVIDED ON AN ""AS-IS"" BASIS AND AUTHORS HAVE NO

OBLIGATION TO PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR

MODIFICATIONS.-->


<!DOCTYPE html>
<html>
<head>
<style>
<?php
$tainted = shell_exec('cat /tmp/tainted.txt');

$tainted = rawurlencode($tainted);


echo ""body { color :\'"". $tainted .""\' ; }"" ;
?>
</style> 
</head>
<body>
<h1>Hello World!</h1>
</body>
</html>","echo ""body { color :\'"". $tainted .""\' ; }"" ;",True,True,"echo ""body { color :\'"". $tainted .""\' ; }"" ;","```xml
<Issues>
  <Issue>
    <Type>Security</Type>
    <Weakness>CWE-77</Weakness>
    <Description>Improper Neutralization of Special Elements used in a Command ('Command Injection')</Description>
    <Severity>High</Severity>
    <File>File 1</File>
    <Code>$tainted = shell_exec('cat /tmp/tainted.txt');</Code>
    <Justification>The code uses shell_exec to execute a command based on user input (indirectly via /tmp/tainted.txt). If the content of /tmp/tainted.txt is controlled by an attacker, they can inject arbitrary commands.</Justification>
  </Issue>
  <Issue>
    <Type>Security</Type>
    <Weakness>CWE-79</Weakness>
    <Description>Improper Neutralization of Input During Web Page Generation ('Cross-site Scripting')</Description>
    <Severity>Medium</Severity>
    <File>File 1</File>
    <Code>echo ""body { color :\'"". $tainted .""\' ; }"" ;</Code>
    <Justification>The code echoes a tainted variable $tainted directly into the CSS style block. Although rawurlencode is applied, it's used in a context (CSS) where other injection attacks are still possible, potentially leading to XSS or CSS injection vulnerabilities, such as using ""*/ property: expression(\x22evil_code\x22); /*"" which is not properly escaped by rawurlencode. It is possible to inject arbitrary CSS rules, leading to potential visual defacement or information disclosure.</Justification>
  </Issue>
</Issues>
```"
CWE-79,src/CWE_79__proc_open__func_FILTER-CLEANING-number_float_filter__Use_untrusted_data_propertyValue_CSS-double_Quoted_Property_Value.php,"<!-- 
Unsafe sample
input : use proc_open to read /tmp/tainted.txt
Uses a number_float_filter via filter_var function
File : use of untrusted data in a double quoted property value (CSS)
-->

<!--Copyright 2015 Bertrand STIVALET 

Permission is hereby granted, without written agreement or royalty fee, to

use, copy, modify, and distribute this software and its documentation for

any purpose, provided that the above copyright notice and the following

three paragraphs appear in all copies of this software.


IN NO EVENT SHALL AUTHORS BE LIABLE TO ANY PARTY FOR DIRECT,

INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES ARISING OUT OF THE 

USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF AUTHORS HAVE

BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.


AUTHORS SPECIFICALLY DISCLAIM ANY WARRANTIES INCLUDING, BUT NOT

LIMITED TO THE IMPLIED WARRANTIES OF MERCHANTABILITY, FITNESS FOR A

PARTICULAR PURPOSE, AND NON-INFRINGEMENT.


THE SOFTWARE IS PROVIDED ON AN ""AS-IS"" BASIS AND AUTHORS HAVE NO

OBLIGATION TO PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR

MODIFICATIONS.-->


<!DOCTYPE html>
<html>
<head>
<style>
<?php
$descriptorspec = array(
  0 => array(""pipe"", ""r""),
  1 => array(""pipe"", ""w""),
  2 => array(""file"", ""/tmp/error-output.txt"", ""a"")
  );
$cwd = '/tmp';
$process = proc_open('more /tmp/tainted.txt', $descriptorspec, $pipes, $cwd, NULL);
if (is_resource($process)) {
  fclose($pipes[0]);
  $tainted = stream_get_contents($pipes[1]);
  fclose($pipes[1]);
  $return_value = proc_close($process);
}

$sanitized = filter_var($tainted, FILTER_SANITIZE_NUMBER_FLOAT);
if (filter_var($sanitized, FILTER_VALIDATE_FLOAT))
  $tainted = $sanitized ;
else
  $tainted = """" ;


echo ""body { color :\"""". $tainted .""\"" ; }"" ;
?>
</style> 
</head>
<body>
<h1>Hello World!</h1>
</body>
</html>","echo ""body { color :\"""". $tainted .""\"" ; }"" ;",True,True,"echo ""body { color :\"""". $tainted .""\"" ; }"" ;","```xml
<Issues>
  <Issue>
    <Type>Security</Type>
    <Weakness>CWE-79</Weakness>
    <Description>Improper Neutralization of Input During Web Page Generation ('Cross-site Scripting')</Description>
    <Severity>Medium</Severity>
    <File>File 1</File>
    <Code>echo ""body { color :\"""". $tainted .""\"" ; }"" ;</Code>
    <Justification>The code echoes user-controlled input ($tainted) directly into the CSS style section of an HTML page. If $tainted contains malicious code (e.g., CSS injection), it will be executed by the browser, leading to a cross-site scripting (XSS) vulnerability.</Justification>
  </Issue>
  <Issue>
    <Type>Security</Type>
    <Weakness>CWE-22</Weakness>
    <Description>Improper Limitation of a Pathname to a Restricted Directory ('Path Traversal')</Description>
    <Severity>High</Severity>
    <File>File 1</File>
    <Code>$process = proc_open('more /tmp/tainted.txt', $descriptorspec, $pipes, $cwd, NULL);
if (is_resource($process)) {
  fclose($pipes[0]);
  $tainted = stream_get_contents($pipes[1]);
  fclose($pipes[1]);
  $return_value = proc_close($process);
}</Code>
    <Justification>The code directly includes the content of `/tmp/tainted.txt` without proper sanitization. An attacker could potentially modify `/tmp/tainted.txt` to contain path traversal characters (e.g., ../../) to access files outside of the intended directory.</Justification>
  </Issue>
  <Issue>
    <Type>Reliability</Type>
    <Weakness>CWE-252</Weakness>
    <Description>Unchecked Return Value</Description>
    <Severity>Low</Severity>
    <File>File 1</File>
    <Code>$return_value = proc_close($process);</Code>
    <Justification>The code calls `proc_close()` but does not check its return value. If `proc_close()` fails, the script will continue execution as if the process closed successfully, which could lead to unpredictable behavior.</Justification>
  </Issue>
</Issues>
```"
CWE-90,src/CWE_90__shell_exec__func_preg_replace2__name-concatenation_simple_quote.php,"<?php







$tainted = shell_exec('cat /tmp/tainted.txt');

$tainted = preg_replace('/\W/si','',$tainted);

$query = ""name='"". $tainted . ""'"";


$ds=ldap_connect(""localhost""); 
$r=ldap_bind($ds);
$sr=ldap_search($ds,""o=My Company, c=US"", $query);  
ldap_close($ds);

?>","$ds=ldap_connect(""localhost"");",True,True,"$tainted = preg_replace('/\W/si','',$tainted);

$query = ""name='"". $tainted . ""'"";

$sr=ldap_search($ds,""o=My Company, c=US"", $query);","```xml
<Issues>
  <Issue>
    <Type>Security</Type>
    <Weakness>CWE-77</Weakness>
    <Description>Improper Neutralization of Special Elements used in a Command ('Command Injection')</Description>
    <Severity>High</Severity>
    <File>File 1</File>
    <Code>$tainted = shell_exec('cat /tmp/tainted.txt');</Code>
    <Justification>The code uses shell_exec to execute a command based on external input. This is vulnerable to command injection because special characters in the /tmp/tainted.txt file can be used to execute arbitrary commands on the system.</Justification>
  </Issue>
  <Issue>
    <Type>Security</Type>
    <Weakness>CWE-90</Weakness>
    <Description>Improper Neutralization of Special Elements used in an LDAP Query ('LDAP Injection')</Description>
    <Severity>High</Severity>
    <File>File 1</File>
    <Code>$tainted = preg_replace('/\W/si','',$tainted);

$query = ""name='"". $tainted . ""'"";

$sr=ldap_search($ds,""o=My Company, c=US"", $query);</Code>
    <Justification>Although the code attempts to sanitize the input with preg_replace, removing non-alphanumeric characters, it is still vulnerable to LDAP injection. The sanitization might not be sufficient to prevent all malicious LDAP queries. An attacker can still manipulate the query structure to bypass authentication or access unauthorized data. It is highly recommended to use parameterized queries or proper escaping mechanisms provided by the LDAP library.</Justification>
  </Issue>
</Issues>
```"
CWE-79,src/CWE_79__exec__func_urlencode__Use_untrusted_data_propertyValue_CSS-double_Quoted_Property_Value.php,"<!-- 
Unsafe sample
input : use exec to execute the script /tmp/tainted.php and store the output in $tainted
SANITIZE : use of urlencode
File : use of untrusted data in a double quoted property value (CSS)
-->

<!--Copyright 2015 Bertrand STIVALET 

Permission is hereby granted, without written agreement or royalty fee, to

use, copy, modify, and distribute this software and its documentation for

any purpose, provided that the above copyright notice and the following

three paragraphs appear in all copies of this software.


IN NO EVENT SHALL AUTHORS BE LIABLE TO ANY PARTY FOR DIRECT,

INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES ARISING OUT OF THE 

USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF AUTHORS HAVE

BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.


AUTHORS SPECIFICALLY DISCLAIM ANY WARRANTIES INCLUDING, BUT NOT

LIMITED TO THE IMPLIED WARRANTIES OF MERCHANTABILITY, FITNESS FOR A

PARTICULAR PURPOSE, AND NON-INFRINGEMENT.


THE SOFTWARE IS PROVIDED ON AN ""AS-IS"" BASIS AND AUTHORS HAVE NO

OBLIGATION TO PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR

MODIFICATIONS.-->


<!DOCTYPE html>
<html>
<head>
<style>
<?php
$script = ""/tmp/tainted.php"";
exec($script, $result, $return);

$tainted = $result[0];

$tainted = urlencode($tainted);


echo ""body { color :\"""". $tainted .""\"" ; }"" ;
?>
</style> 
</head>
<body>
<h1>Hello World!</h1>
</body>
</html>","echo ""body { color :\"""". $tainted .""\"" ; }"" ;",True,True,"$tainted = urlencode($tainted);


echo ""body { color :\"""". $tainted .""\"" ; }"" ;","```xml
<Issues>
  <Issue>
    <Type>Security</Type>
    <Weakness>CWE-77</Weakness>
    <Description>Improper Neutralization of Special Elements used in a Command ('Command Injection')</Description>
    <Severity>High</Severity>
    <File>File 1</File>
    <Code>$script = ""/tmp/tainted.php"";
exec($script, $result, $return);</Code>
    <Justification>The code uses exec() to execute an external script. If the script path is derived from an untrusted source, it is vulnerable to command injection.</Justification>
  </Issue>
  <Issue>
    <Type>Security</Type>
    <Weakness>CWE-79</Weakness>
    <Description>Improper Neutralization of Input During Web Page Generation ('Cross-site Scripting')</Description>
    <Severity>Medium</Severity>
    <File>File 1</File>
    <Code>$tainted = urlencode($tainted);


echo ""body { color :\"""". $tainted .""\"" ; }"" ;</Code>
    <Justification>The code uses urlencode to sanitize the input. Although urlencode can prevent some XSS attacks, it's not sufficient for all cases, especially when the output context is CSS. The urlencoded data is directly embedded into the CSS property value within double quotes, this may be vulnerable to XSS.</Justification>
  </Issue>
</Issues>
```"
CWE-90,src/CWE_90__shell_exec__func_FILTER-CLEANING-magic_quotes_filter__userByCN-sprintf_%s_simple_quote.php,"<?php







$tainted = shell_exec('cat /tmp/tainted.txt');

$sanitized = filter_var($tainted, FILTER_SANITIZE_MAGIC_QUOTES);
  $tainted = $sanitized ;
      

$query = sprintf(""(&(objectCategory=person)(objectClass=user)(cn='%s'))"", $tainted);


$ds=ldap_connect(""localhost""); 
$r=ldap_bind($ds);
$sr=ldap_search($ds,""o=My Company, c=US"", $query);  
ldap_close($ds);

?>","$ds=ldap_connect(""localhost"");",True,True,"$tainted = shell_exec('cat /tmp/tainted.txt');

$sanitized = filter_var($tainted, FILTER_SANITIZE_MAGIC_QUOTES);
  $tainted = $sanitized ;
      

$query = sprintf(""(&(objectCategory=person)(objectClass=user)(cn='%s'))"", $tainted);","```xml
<Issues>
  <Issue>
    <Type>Security</Type>
    <Weakness>CWE-90</Weakness>
    <Description>Improper Neutralization of Special Elements used in an LDAP Query ('LDAP Injection')</Description>
    <Severity>High</Severity>
    <File>File 1</File>
    <Code>$tainted = shell_exec('cat /tmp/tainted.txt');

$sanitized = filter_var($tainted, FILTER_SANITIZE_MAGIC_QUOTES);
  $tainted = $sanitized ;
      

$query = sprintf(""(&(objectCategory=person)(objectClass=user)(cn='%s'))"", $tainted);</Code>
    <Justification>The code constructs an LDAP query using sprintf() with user-controlled input ($tainted) without proper sanitization, making it vulnerable to LDAP injection. Although filter_var with FILTER_SANITIZE_MAGIC_QUOTES is used, it's insufficient for preventing LDAP injection because it only escapes quotes. An attacker can manipulate the query logic, potentially gaining unauthorized access to sensitive information.</Justification>
  </Issue>
  <Issue>
    <Type>Security</Type>
    <Weakness>CWE-78</Weakness>
    <Description>Improper Neutralization of Special Elements used in an OS Command ('OS Command Injection')</Description>
    <Severity>High</Severity>
    <File>File 1</File>
    <Code>$tainted = shell_exec('cat /tmp/tainted.txt');</Code>
    <Justification>The code uses shell_exec to execute a command. If the contents of '/tmp/tainted.txt' are controlled by an attacker, it could lead to OS command injection. This is because shell_exec will execute the contents of the file as a system command, regardless of its origin or validity.</Justification>
  </Issue>
</Issues>
```"
CWE-90,src/CWE_90__POST__func_htmlentities__userByMail-interpretation_simple_quote.php,"<?php







$tainted = $_POST['UserData'];

$tainted = htmlentities($tainted, ENT_QUOTES);

$query = ""(&(objectCategory=person)(objectClass=user)(mail=' $tainted '))"";


$ds=ldap_connect(""localhost""); 
$r=ldap_bind($ds);
$sr=ldap_search($ds,""o=My Company, c=US"", $query);  
ldap_close($ds);

?>","$ds=ldap_connect(""localhost"");",True,True,"$tainted = htmlentities($tainted, ENT_QUOTES);

$query = ""(&(objectCategory=person)(objectClass=user)(mail=' $tainted '))"";


$ds=ldap_connect(""localhost"");","```xml
<Issues>
  <Issue>
    <Type>Security</Type>
    <Weakness>CWE-90</Weakness>
    <Description>Improper Neutralization of Special Elements used in an LDAP Query ('LDAP Injection')</Description>
    <Severity>High</Severity>
    <File>File 1</File>
    <Code>$tainted = htmlentities($tainted, ENT_QUOTES);

$query = ""(&(objectCategory=person)(objectClass=user)(mail=' $tainted '))"";


$ds=ldap_connect(""localhost"");</Code>
    <Justification>The code constructs an LDAP query by embedding user-controlled data without proper sanitization. Even after using htmlentities, LDAP injection is still possible. Although htmlentities escapes HTML entities, it doesn't prevent LDAP injection vulnerabilities, as LDAP uses different special characters for its queries. A malicious user can inject LDAP control characters to modify the query and potentially access or modify unauthorized information.</Justification>
  </Issue>
</Issues>
```"
CWE-79,src/CWE_79__object-Array__func_FILTER-VALIDATION-number_float_filter__Unsafe_use_untrusted_data-style.php,"<!-- 
Unsafe sample
input : get the field userData from the variable $_GET via an object, which store it in a array
Flushes content of $sanitized if the filter number_float_filter is not applied
File : unsafe, use of untrusted data in CSS
-->

<!--Copyright 2015 Bertrand STIVALET 

Permission is hereby granted, without written agreement or royalty fee, to

use, copy, modify, and distribute this software and its documentation for

any purpose, provided that the above copyright notice and the following

three paragraphs appear in all copies of this software.


IN NO EVENT SHALL AUTHORS BE LIABLE TO ANY PARTY FOR DIRECT,

INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES ARISING OUT OF THE 

USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF AUTHORS HAVE

BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.


AUTHORS SPECIFICALLY DISCLAIM ANY WARRANTIES INCLUDING, BUT NOT

LIMITED TO THE IMPLIED WARRANTIES OF MERCHANTABILITY, FITNESS FOR A

PARTICULAR PURPOSE, AND NON-INFRINGEMENT.


THE SOFTWARE IS PROVIDED ON AN ""AS-IS"" BASIS AND AUTHORS HAVE NO

OBLIGATION TO PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR

MODIFICATIONS.-->


<!DOCTYPE html>
<html>
<head>
<style>
<?php
class Input{
  private $input;

  public function getInput(){
    return $this->input[1];
  }

  public  function __construct(){
    $this->input = array();
    $this->input[0]= 'safe' ;
    $this->input[1]= $_GET['UserData'] ;
    $this->input[2]= 'safe' ;
  }
}
$temp = new Input();
$tainted =  $temp->getInput();

if (filter_var($sanitized, FILTER_VALIDATE_FLOAT))
  $tainted = $sanitized ;
else
  $tainted = """" ;


echo $tainted ;
?>
</style>
</head>
<body>
<h1>Hello World!</h1>
</body>
</html>",echo $tainted ;,True,False,$this->input[1]= $_GET['UserData'] ;,"```xml
<Issues>
  <Issue>
    <Type>Security</Type>
    <Weakness>CWE-79</Weakness>
    <Description>Improper Neutralization of Input During Web Page Generation ('Cross-site Scripting')</Description>
    <Severity>Medium</Severity>
    <File>File 1</File>
    <Code>$this->input[1]= $_GET['UserData'] ;</Code>
    <Justification>The code retrieves user input from the $_GET['UserData'] parameter and stores it in the $this->input[1] variable without any sanitization. This tainted data is then echoed directly into the &lt;style&gt; tag, allowing for potential Cross-Site Scripting (XSS) attacks.</Justification>
  </Issue>
  <Issue>
    <Type>Security</Type>
    <Weakness>CWE-571</Weakness>
    <Description>Expression is Always True</Description>
    <Severity>Low</Severity>
    <File>File 1</File>
    <Code>if (filter_var($sanitized, FILTER_VALIDATE_FLOAT))
  $tainted = $sanitized ;
else
  $tainted = """" ;</Code>
    <Justification>The variable `$sanitized` is not initialized before being used in `filter_var`. If `filter_var` is passed an uninitialized variable, PHP will likely throw a warning but might continue execution depending on error reporting levels. The condition will always evaluate to the else block, assigning an empty string to `$tainted`.</Justification>
  </Issue>
  <Issue>
    <Type>Security</Type>
    <Weakness>CWE-477</Weakness>
    <Description>Use of Obsolete Function</Description>
    <Severity>Low</Severity>
    <File>File 1</File>
    <Code>if (filter_var($sanitized, FILTER_VALIDATE_FLOAT))
  $tainted = $sanitized ;
else
  $tainted = """" ;</Code>
    <Justification>The use of `filter_var` without proper sanitization is risky and should be replaced with a proper validation to prevent any injection.</Justification>
  </Issue>
</Issues>
```"
CWE-90,src/CWE_90__popen__func_FILTER-VALIDATION-email_filter__userByMail-interpretation_simple_quote.php,"<?php







$handle = popen('/bin/cat /tmp/tainted.txt', 'r');
$tainted = fread($handle, 4096);
pclose($handle);

if (filter_var($sanitized, FILTER_VALIDATE_EMAIL))
  $tainted = $sanitized ;
else
  $tainted = """" ;

$query = ""(&(objectCategory=person)(objectClass=user)(mail=' $tainted '))"";


$ds=ldap_connect(""localhost""); 
$r=ldap_bind($ds);
$sr=ldap_search($ds,""o=My Company, c=US"", $query);  
ldap_close($ds);

?>","$ds=ldap_connect(""localhost"");",True,True,"$query = ""(&(objectCategory=person)(objectClass=user)(mail=' $tainted '))"";


$ds=ldap_connect(""localhost""); 
$r=ldap_bind($ds);
$sr=ldap_search($ds,""o=My Company, c=US"", $query);  
ldap_close($ds);","```xml
<Issues>
  <Issue>
    <Type>Security</Type>
    <Weakness>CWE-78</Weakness>
    <Description>Improper Neutralization of Special Elements used in a Command ('Command Injection')</Description>
    <Severity>High</Severity>
    <File>File 1</File>
    <Code>$handle = popen('/bin/cat /tmp/tainted.txt', 'r');
$tainted = fread($handle, 4096);
pclose($handle);</Code>
    <Justification>The code uses popen to execute a command. Even though the command itself is hardcoded, the initial source of $tainted is from a file, which could be controlled by an attacker. While the contents of /tmp/tainted.txt are later sanitized via filter_var, the initial popen execution is still vulnerable because there may be other code paths that lead to popen being executed without sanitation.
</Justification>
  </Issue>
  <Issue>
    <Type>Security</Type>
    <Weakness>CWE-90</Weakness>
    <Description>Improper Neutralization of Special Elements used in an LDAP Query ('LDAP Injection')</Description>
    <Severity>High</Severity>
    <File>File 1</File>
    <Code>$query = ""(&(objectCategory=person)(objectClass=user)(mail=' $tainted '))"";


$ds=ldap_connect(""localhost""); 
$r=ldap_bind($ds);
$sr=ldap_search($ds,""o=My Company, c=US"", $query);  
ldap_close($ds);</Code>
    <Justification>The code constructs an LDAP query by directly embedding the `$tainted` variable, which originates from a file. Even with email validation, it is still vulnerable to LDAP injection. An attacker could manipulate the `$tainted` variable (even within the confines of a valid email format) to inject malicious LDAP syntax, potentially bypassing authentication or accessing sensitive information. The validation is insufficient to prevent LDAP injection.</Justification>
  </Issue>
  <Issue>
    <Type>Reliability</Type>
    <Weakness>CWE-252</Weakness>
    <Description>Unchecked Return Value</Description>
    <Severity>Medium</Severity>
    <File>File 1</File>
    <Code>$ds=ldap_connect(""localhost""); 
$r=ldap_bind($ds);
$sr=ldap_search($ds,""o=My Company, c=US"", $query);  
ldap_close($ds);</Code>
    <Justification>The code does not check the return values of `ldap_connect`, `ldap_bind`, and `ldap_search`. If any of these functions fail, the script will continue to execute, potentially leading to unexpected behavior or security vulnerabilities. For example, if `ldap_connect` fails, `$ds` might be null, leading to a null pointer dereference when passed to subsequent LDAP functions. Similar issues can arise if the other functions fail.</Justification>
  </Issue>
  <Issue>
    <Type>Security</Type>
    <Weakness>CWE-424</Weakness>
    <Description>Improper Protection of Alternate Path</Description>
    <Severity>Medium</Severity>
    <File>File 1</File>
    <Code>if (filter_var($sanitized, FILTER_VALIDATE_EMAIL))
  $tainted = $sanitized ;
else
  $tainted = """" ;</Code>
    <Justification>The conditional statement appears to attempt sanitization of input. However, if the input `$sanitized` is not a valid email, `$tainted` is set to an empty string. This may unintentionally expose an alternate execution path which may lead to other weaknesses being triggered, or may not handle all possible states/values as intended.</Justification>
  </Issue>
</Issues>
```"
CWE-89,src/CWE_89__exec__func_preg_match-no_filtering__select_from-interpretation_simple_quote.php,"<?php







$script = ""/tmp/tainted.php"";
exec($script, $result, $return);

$tainted = $result[0];

$re = ""/^.*$/"";
if(preg_match($re, $tainted) == 1){
  $tainted = $tainted;
}
else{
  $tainted = """";
}

$query = ""SELECT * FROM ' $tainted '"";


$conn = mysql_connect('localhost', 'mysql_user', 'mysql_password'); 
mysql_select_db('dbname') ;
echo ""query : "". $query .""<br /><br />"" ;

$res = mysql_query($query); 

while($data =mysql_fetch_array($res)){
print_r($data) ;
echo ""<br />"" ;
} 
mysql_close($conn);

?>","$conn = mysql_connect('localhost', 'mysql_user', 'mysql_password'); ",True,True,"$script = ""/tmp/tainted.php"";
exec($script, $result, $return);

$tainted = $result[0];

$re = ""/^.*$/"";
if(preg_match($re, $tainted) == 1){
  $tainted = $tainted;
}
else{
  $tainted = """";
}

$query = ""SELECT * FROM ' $tainted '"";","```xml
<Issues>
  <Issue>
    <Type>Security</Type>
    <Weakness>CWE-89</Weakness>
    <Description>Improper Neutralization of Special Elements used in an SQL Command ('SQL Injection')</Description>
    <Severity>Critical</Severity>
    <File>File 1</File>
    <Code>$script = ""/tmp/tainted.php"";
exec($script, $result, $return);

$tainted = $result[0];

$re = ""/^.*$/"";
if(preg_match($re, $tainted) == 1){
  $tainted = $tainted;
}
else{
  $tainted = """";
}

$query = ""SELECT * FROM ' $tainted '"";</Code>
    <Justification>The code executes an external script and uses its output in an SQL query without proper sanitization. Even with the regex, the code is still vulnerable to SQL injection because the regex ""/^.*$/"" will match any string. This allows an attacker to inject malicious SQL code.</Justification>
  </Issue>
  <Issue>
    <Type>Security</Type>
    <Weakness>CWE-78</Weakness>
    <Description>Improper Neutralization of Special Elements used in a Command ('Command Injection')</Description>
    <Severity>High</Severity>
    <File>File 1</File>
    <Code>$script = ""/tmp/tainted.php"";
exec($script, $result, $return);</Code>
    <Justification>The code uses the `exec` function to execute a script. If the script path or any input to the script is derived from an external source, this code is vulnerable to command injection.</Justification>
  </Issue>
  <Issue>
    <Type>Reliability</Type>
    <Weakness>CWE-252</Weakness>
    <Description>Unchecked Return Value</Description>
    <Severity>Medium</Severity>
    <File>File 1</File>
    <Code>$conn = mysql_connect('localhost', 'mysql_user', 'mysql_password'); 
mysql_select_db('dbname') ;</Code>
    <Justification>The code does not check the return values of `mysql_connect` and `mysql_select_db`. If the connection fails or the database selection fails, the script will continue to execute, potentially leading to errors and unexpected behavior.</Justification>
  </Issue>
  <Issue>
    <Type>Reliability</Type>
    <Weakness>CWE-252</Weakness>
    <Description>Unchecked Return Value</Description>
    <Severity>Medium</Severity>
    <File>File 1</File>
    <Code>$res = mysql_query($query); </Code>
    <Justification>The code does not check the return value of `mysql_query`. If the query fails, the script will continue to execute, potentially leading to errors and unexpected behavior. It is also important to note the mysql_* functions are deprecated.</Justification>
  </Issue>
  <Issue>
    <Type>Maintainability</Type>
    <Weakness>CWE-477</Weakness>
    <Description>Use of Obsolete Function</Description>
    <Severity>Low</Severity>
    <File>File 1</File>
    <Code>$conn = mysql_connect('localhost', 'mysql_user', 'mysql_password'); 
mysql_select_db('dbname') ;
echo ""query : "". $query .""&lt;br /&gt;&lt;br /&gt;"" ;

$res = mysql_query($query); 

while($data =mysql_fetch_array($res)){
print_r($data) ;
echo ""&lt;br /&gt;"" ;
} 
mysql_close($conn);</Code>
    <Justification>The code uses the `mysql_*` functions, which are deprecated. Using deprecated functions makes the code harder to maintain and potentially less secure. It is recommended to migrate to `mysqli_*` or PDO.</Justification>
  </Issue>
</Issues>
```"
CWE-89,src/CWE_89__proc_open__no_sanitizing__select_from_where-concatenation_simple_quote.php,"<?php







$descriptorspec = array(
  0 => array(""pipe"", ""r""),
  1 => array(""pipe"", ""w""),
  2 => array(""file"", ""/tmp/error-output.txt"", ""a"")
  );
$cwd = '/tmp';
$process = proc_open('more /tmp/tainted.txt', $descriptorspec, $pipes, $cwd, NULL);
if (is_resource($process)) {
  fclose($pipes[0]);
  $tainted = stream_get_contents($pipes[1]);
  fclose($pipes[1]);
  $return_value = proc_close($process);
}



$query = ""SELECT * FROM student where id='"". $tainted . ""'"";


$conn = mysql_connect('localhost', 'mysql_user', 'mysql_password'); 
mysql_select_db('dbname') ;
echo ""query : "". $query .""<br /><br />"" ;

$res = mysql_query($query); 

while($data =mysql_fetch_array($res)){
print_r($data) ;
echo ""<br />"" ;
} 
mysql_close($conn);

?>","$conn = mysql_connect('localhost', 'mysql_user', 'mysql_password'); ",True,False,"$query = ""SELECT * FROM student where id='"". $tainted . ""'"";","```xml
<Issues>
  <Issue>
    <Type>Security</Type>
    <Weakness>CWE-89</Weakness>
    <Description>Improper Neutralization of Special Elements used in an SQL Command ('SQL Injection')</Description>
    <Severity>High</Severity>
    <File>File 1</File>
    <Code>$query = ""SELECT * FROM student where id='"". $tainted . ""'"";</Code>
    <Justification>The code directly incorporates user-controlled input ($tainted) into an SQL query without proper sanitization, making it vulnerable to SQL injection attacks. An attacker could manipulate the $tainted variable to inject malicious SQL code, potentially leading to unauthorized data access, modification, or deletion.</Justification>
  </Issue>
  <Issue>
    <Type>Reliability</Type>
    <Weakness>CWE-252</Weakness>
    <Description>Unchecked Return Value</Description>
    <Severity>Medium</Severity>
    <File>File 1</File>
    <Code>$conn = mysql_connect('localhost', 'mysql_user', 'mysql_password');</Code>
    <Justification>The code does not check the return value of mysql_connect. If the connection fails, $conn will be false, and subsequent operations will result in errors.</Justification>
  </Issue>
  <Issue>
    <Type>Reliability</Type>
    <Weakness>CWE-252</Weakness>
    <Description>Unchecked Return Value</Description>
    <Severity>Medium</Severity>
    <File>File 1</File>
    <Code>$res = mysql_query($query);</Code>
    <Justification>The code does not check the return value of mysql_query. If the query fails, $res will be false, and subsequent operations will result in errors.</Justification>
  </Issue>
  <Issue>
    <Type>Security</Type>
    <Weakness>CWE-477</Weakness>
    <Description>Use of Obsolete Function</Description>
    <Severity>Medium</Severity>
    <File>File 1</File>
    <Code>$conn = mysql_connect('localhost', 'mysql_user', 'mysql_password');</Code>
    <Justification>The function mysql_connect is deprecated and insecure. It should not be used as it poses security risks.</Justification>
  </Issue>
  <Issue>
    <Type>Security</Type>
    <Weakness>CWE-477</Weakness>
    <Description>Use of Obsolete Function</Description>
    <Severity>Medium</Severity>
    <File>File 1</File>
    <Code>$conn = mysql_connect('localhost', 'mysql_user', 'mysql_password'); 
mysql_select_db('dbname') ;
echo ""query : "". $query .""&lt;br /&gt;&lt;br /&gt;"" ;

$res = mysql_query($query); </Code>
    <Justification>The function mysql_query is deprecated and insecure. It should not be used as it poses security risks.</Justification>
  </Issue>
  <Issue>
    <Type>Security</Type>
    <Weakness>CWE-477</Weakness>
    <Description>Use of Obsolete Function</Description>
    <Severity>Medium</Severity>
    <File>File 1</File>
    <Code>mysql_select_db('dbname') ;</Code>
    <Justification>The function mysql_select_db is deprecated and insecure. It should not be used as it poses security risks.</Justification>
  </Issue>
  <Issue>
    <Type>Security</Type>
    <Weakness>CWE-798</Weakness>
    <Description>Use of Hard-coded Credentials</Description>
    <Severity>Critical</Severity>
    <File>File 1</File>
    <Code>$conn = mysql_connect('localhost', 'mysql_user', 'mysql_password');</Code>
    <Justification>The code uses hard-coded credentials ('mysql_user', 'mysql_password') for database connection, which is a significant security risk. If the code is compromised, attackers can easily gain unauthorized access to the database.</Justification>
  </Issue>
</Issues>
```"
CWE-90,src/CWE_90__POST__func_preg_replace__userByCN-sprintf_%s_simple_quote.php,"<?php







$tainted = $_POST['UserData'];

$tainted = preg_replace('/\'/', '', $tainted);

$query = sprintf(""(&(objectCategory=person)(objectClass=user)(cn='%s'))"", $tainted);


$ds=ldap_connect(""localhost""); 
$r=ldap_bind($ds);
$sr=ldap_search($ds,""o=My Company, c=US"", $query);  
ldap_close($ds);

?>","$ds=ldap_connect(""localhost"");",True,True,"$tainted = $_POST['UserData'];

$tainted = preg_replace('/\'/', '', $tainted);

$query = sprintf(""(&(objectCategory=person)(objectClass=user)(cn='%s'))"", $tainted);","```xml
<Issues>
  <Issue>
    <Type>Security</Type>
    <Weakness>CWE-90</Weakness>
    <Description>Improper Neutralization of Special Elements used in an LDAP Query ('LDAP Injection')</Description>
    <Severity>High</Severity>
    <File>File 1</File>
    <Code>$tainted = $_POST['UserData'];

$tainted = preg_replace('/\'/', '', $tainted);

$query = sprintf(""(&(objectCategory=person)(objectClass=user)(cn='%s'))"", $tainted);</Code>
    <Justification>The code is vulnerable to LDAP injection because it directly incorporates user-provided data ($tainted) into an LDAP query. While the code attempts to sanitize the input by removing single quotes, this is insufficient to prevent all forms of LDAP injection. An attacker could still manipulate the query logic by injecting other special characters or sequences, potentially bypassing authentication or extracting sensitive information.</Justification>
  </Issue>
</Issues>
```"
CWE-79,src/CWE_79__unserialize__whitelist_using_array__Use_untrusted_data_script-side_DoubleQuoted_Expr.php,"<!-- 
Unsafe sample
input : Get a serialize string in POST and unserialize it
SANITIZE : use in_array to check if $tainted is in the white list
File : use of untrusted data in one side of a double quoted expression in a script
-->

<!--Copyright 2015 Bertrand STIVALET 

Permission is hereby granted, without written agreement or royalty fee, to

use, copy, modify, and distribute this software and its documentation for

any purpose, provided that the above copyright notice and the following

three paragraphs appear in all copies of this software.


IN NO EVENT SHALL AUTHORS BE LIABLE TO ANY PARTY FOR DIRECT,

INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES ARISING OUT OF THE 

USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF AUTHORS HAVE

BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.


AUTHORS SPECIFICALLY DISCLAIM ANY WARRANTIES INCLUDING, BUT NOT

LIMITED TO THE IMPLIED WARRANTIES OF MERCHANTABILITY, FITNESS FOR A

PARTICULAR PURPOSE, AND NON-INFRINGEMENT.


THE SOFTWARE IS PROVIDED ON AN ""AS-IS"" BASIS AND AUTHORS HAVE NO

OBLIGATION TO PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR

MODIFICATIONS.-->


<!DOCTYPE html>
<html>
<head>
<script>
<?php
$string = $_POST['UserData'] ;
$tainted = unserialize($string);
    

$legal_table = array(""safe1"", ""safe2"");
if (in_array($tainted, $legal_table, true)) {
  $tainted = $tainted;
} else {
  $tainted = $legal_table[0];
}


echo ""x=\"""". $tainted.""\"""" ;
?>
</script>
</head>
<body>
<h1>Hello World!</h1>
</body>
</html>","echo ""x=\"""". $tainted.""\"""" ;",True,True,"echo ""x=\"""". $tainted.""\"""" ;","```xml
<Issues>
  <Issue>
    <Type>Security</Type>
    <Weakness>CWE-79</Weakness>
    <Description>Improper Neutralization of Input During Web Page Generation ('Cross-site Scripting')</Description>
    <Severity>Medium</Severity>
    <File>File 1</File>
    <Code>echo ""x=\"""". $tainted.""\"""" ;</Code>
    <Justification>The code echoes user-controlled data ($tainted) directly into the Javascript section of the HTML page without proper neutralization. Although the code uses in_array to check if the tainted data is in a whitelist, this doesn't prevent the injection of arbitrary Javascript code if the unserialized data contains characters that break out of the string context.
The data is used in double quotes context. If the $tainted string contains \"" it's possible to inject an XSS payload.
</Justification>
  </Issue>
  <Issue>
    <Type>Security</Type>
    <Weakness>CWE-502</Weakness>
    <Description>Deserialization of Untrusted Data</Description>
    <Severity>High</Severity>
    <File>File 1</File>
    <Code>$string = $_POST['UserData'] ;
$tainted = unserialize($string);</Code>
    <Justification>The code uses unserialize() on user-provided data from $_POST['UserData']. Deserializing untrusted data can lead to arbitrary code execution if the serialized data contains malicious objects or exploits known vulnerabilities in the application's classes or libraries. Although there is a whitelist check with in_array this is not sufficient protection, because the deserialized data can be a malicious object not a simple string.</Justification>
  </Issue>
</Issues>
```"
CWE-79,src/CWE_79__unserialize__func_FILTER-CLEANING-special_chars_filter__Unsafe_use_untrusted_data-tag_Name.php,"<!-- 
Unsafe sample
input : Get a serialize string in POST and unserialize it
Uses a special_chars_filter via filter_var function
File : unsafe, use of untrusted data in an tag name
-->

<!--Copyright 2015 Bertrand STIVALET 

Permission is hereby granted, without written agreement or royalty fee, to

use, copy, modify, and distribute this software and its documentation for

any purpose, provided that the above copyright notice and the following

three paragraphs appear in all copies of this software.


IN NO EVENT SHALL AUTHORS BE LIABLE TO ANY PARTY FOR DIRECT,

INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES ARISING OUT OF THE 

USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF AUTHORS HAVE

BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.


AUTHORS SPECIFICALLY DISCLAIM ANY WARRANTIES INCLUDING, BUT NOT

LIMITED TO THE IMPLIED WARRANTIES OF MERCHANTABILITY, FITNESS FOR A

PARTICULAR PURPOSE, AND NON-INFRINGEMENT.


THE SOFTWARE IS PROVIDED ON AN ""AS-IS"" BASIS AND AUTHORS HAVE NO

OBLIGATION TO PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR

MODIFICATIONS.-->


<!DOCTYPE html>
<html>
<head/>
<body>
<?php
$string = $_POST['UserData'] ;
$tainted = unserialize($string);
    

$sanitized = filter_var($tainted, FILTER_SANITIZE_SPECIAL_CHARS);
  $tainted = $sanitized ;
      


echo ""<"".  $tainted ."" href= \""/bob\"" />"" ;
?>
<h1>Hello World!</h1>
</body>
</html>","echo ""<"".  $tainted ."" href= \""/bob\"" />"" ;",True,True,"echo ""<"".  $tainted ."" href= \""/bob\"" />"" ;","```xml
<Issues>
  <Issue>
    <Type>Security</Type>
    <Weakness>CWE-79</Weakness>
    <Description>Improper Neutralization of Input During Web Page Generation ('Cross-site Scripting')</Description>
    <Severity>High</Severity>
    <File>File 1</File>
    <Code>echo ""&lt;"".  $tainted ."" href= \""/bob\"" /&gt;"" ;</Code>
    <Justification>The code uses unsanitized user-supplied data ($tainted) directly in the tag name of an HTML element. Although the data has been filtered with FILTER_SANITIZE_SPECIAL_CHARS, this filter is not sufficient to prevent XSS attacks in all contexts, especially when used directly as a tag name. An attacker could inject malicious HTML or script by crafting a string that bypasses the filter and injects an unsafe tag.</Justification>
  </Issue>
  <Issue>
    <Type>Security</Type>
    <Weakness>CWE-502</Weakness>
    <Description>Deserialization of Untrusted Data</Description>
    <Severity>Critical</Severity>
    <File>File 1</File>
    <Code>$string = $_POST['UserData'] ;
$tainted = unserialize($string);</Code>
    <Justification>The code uses unserialize() on user-provided data ($_POST['UserData']). This is extremely dangerous because unserialize() can be exploited to achieve arbitrary code execution if the serialized data is maliciously crafted. Deserialization of untrusted data should be avoided whenever possible.</Justification>
  </Issue>
</Issues>
```"
CWE-79,src/CWE_79__fopen__func_preg_replace__Use_untrusted_data_propertyValue_CSS-span_Style_Property_Value.php,"<!-- 
Unsafe sample
input : use fopen to read /tmp/tainted.txt and put the first line in $tainted
SANITIZE : use of preg_replace
File : unsafe, use of untrusted data in a property value in a span tag(CSS)
-->

<!--Copyright 2015 Bertrand STIVALET 

Permission is hereby granted, without written agreement or royalty fee, to

use, copy, modify, and distribute this software and its documentation for

any purpose, provided that the above copyright notice and the following

three paragraphs appear in all copies of this software.


IN NO EVENT SHALL AUTHORS BE LIABLE TO ANY PARTY FOR DIRECT,

INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES ARISING OUT OF THE 

USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF AUTHORS HAVE

BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.


AUTHORS SPECIFICALLY DISCLAIM ANY WARRANTIES INCLUDING, BUT NOT

LIMITED TO THE IMPLIED WARRANTIES OF MERCHANTABILITY, FITNESS FOR A

PARTICULAR PURPOSE, AND NON-INFRINGEMENT.


THE SOFTWARE IS PROVIDED ON AN ""AS-IS"" BASIS AND AUTHORS HAVE NO

OBLIGATION TO PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR

MODIFICATIONS.-->


<!DOCTYPE html>
<html>
<head/>
<body>
<?php
$handle = @fopen(""/tmp/tainted.txt"", ""r"");

if ($handle) {
  if(($tainted = fgets($handle, 4096)) == false) {
    $tainted = """";
  }
  fclose($handle);
} else {
  $tainted = """";
}

$tainted = preg_replace('/\'/', '', $tainted);


echo ""<span style=\""color :"". checked_data .""\"">Hey</span>"" ;
?>
<h1>Hello World!</h1>
</body>
</html>","echo ""<span style=\""color :"". checked_data .""\"">Hey</span>"" ;",True,True,"echo ""<span style=\""color :"". checked_data .""\"">Hey</span>"" ;","```xml
<Issues>
  <Issue>
    <Type>Security</Type>
    <Weakness>CWE-79</Weakness>
    <Description>Improper Neutralization of Input During Web Page Generation ('Cross-site Scripting')</Description>
    <Severity>Medium</Severity>
    <File>File 1</File>
    <Code>echo ""&lt;span style=\""color :"". checked_data .""\"">Hey&lt;/span>"" ;</Code>
    <Justification>The code is using unchecked data as CSS property, which is susceptible to XSS attacks. The variable checked_data is not defined in the code. If it contains user-controlled data, CSS injection is possible, because the code does not neutralize or incorrectly neutralizes user-controllable input before it is placed in output that is used as a web page that is served to other users.</Justification>
  </Issue>
  <Issue>
    <Type>Security</Type>
    <Weakness>CWE-22</Weakness>
    <Description>Improper Limitation of a Pathname to a Restricted Directory ('Path Traversal')</Description>
    <Severity>Medium</Severity>
    <File>File 1</File>
    <Code>$handle = @fopen(""/tmp/tainted.txt"", ""r"");</Code>
    <Justification>The code reads from a file with a hardcoded path. Although unlikely, if the application has permissions to access sensitive files in /tmp and the file tainted.txt contains a path traversal string, this could lead to information disclosure.</Justification>
  </Issue>
</Issues>
```"
CWE-79,src/CWE_79__unserialize__func_preg_replace__Unsafe_use_untrusted_data-script.php,"<!-- 
Unsafe sample
input : Get a serialize string in POST and unserialize it
SANITIZE : use of preg_replace
File : unsafe, use of untrusted data in a script
-->

<!--Copyright 2015 Bertrand STIVALET 

Permission is hereby granted, without written agreement or royalty fee, to

use, copy, modify, and distribute this software and its documentation for

any purpose, provided that the above copyright notice and the following

three paragraphs appear in all copies of this software.


IN NO EVENT SHALL AUTHORS BE LIABLE TO ANY PARTY FOR DIRECT,

INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES ARISING OUT OF THE 

USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF AUTHORS HAVE

BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.


AUTHORS SPECIFICALLY DISCLAIM ANY WARRANTIES INCLUDING, BUT NOT

LIMITED TO THE IMPLIED WARRANTIES OF MERCHANTABILITY, FITNESS FOR A

PARTICULAR PURPOSE, AND NON-INFRINGEMENT.


THE SOFTWARE IS PROVIDED ON AN ""AS-IS"" BASIS AND AUTHORS HAVE NO

OBLIGATION TO PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR

MODIFICATIONS.-->


<!DOCTYPE html>
<html>
<head>
<script>
<?php
$string = $_POST['UserData'] ;
$tainted = unserialize($string);
    

$tainted = preg_replace('/\'/', '', $tainted);


echo $tainted ;
?>
</script>
</head>
<body onload=""xss()"">
<h1>Hello World!</h1>
</body>
</html>",echo $tainted ;,True,True,"<script>
<?php
$string = $_POST['UserData'] ;
$tainted = unserialize($string);
    

$tainted = preg_replace('/\'/', '', $tainted);


echo $tainted ;
?>
</script>","```xml
<Issues>
  <Issue>
    <Type>Security</Type>
    <Weakness>CWE-79</Weakness>
    <Description>Improper Neutralization of Input During Web Page Generation ('Cross-site Scripting')</Description>
    <Severity>High</Severity>
    <File>File 1</File>
    <Code>&lt;script&gt;
&lt;?php
$string = $_POST['UserData'] ;
$tainted = unserialize($string);
    

$tainted = preg_replace('/\'/', '', $tainted);


echo $tainted ;
?&gt;
&lt;/script&gt;</Code>
    <Justification>The code directly outputs the value of $tainted, which is derived from user-controlled input ($_POST['UserData']) after being unserialized and processed with preg_replace('/\'/', '', $tainted'). While the preg_replace attempts to remove single quotes, this is insufficient to prevent XSS attacks. An attacker can inject arbitrary JavaScript code into the $_POST['UserData'] parameter, which, after unserialization and the single quote replacement, will be executed in the user's browser. The output is directly embedded within the &lt;script&gt; tag, exacerbating the risk.</Justification>
  </Issue>
  <Issue>
    <Type>Security</Type>
    <Weakness>CWE-502</Weakness>
    <Description>Deserialization of Untrusted Data</Description>
    <Severity>Critical</Severity>
    <File>File 1</File>
    <Code>$string = $_POST['UserData'] ;
$tainted = unserialize($string);</Code>
    <Justification>The code uses the `unserialize()` function to convert a serialized string from user input ($_POST['UserData']) into a PHP variable. This is extremely dangerous because `unserialize()` can be exploited to perform arbitrary code execution if the serialized string is maliciously crafted.  An attacker could inject a serialized object that, when unserialized, executes arbitrary PHP code on the server.</Justification>
  </Issue>
  <Issue>
    <Type>Reliability</Type>
    <Weakness>CWE-252</Weakness>
    <Description>Unchecked Return Value</Description>
    <Severity>Medium</Severity>
    <File>File 1</File>
    <Code>$string = $_POST['UserData'] ;
$tainted = unserialize($string);
    

$tainted = preg_replace('/\'/', '', $tainted);</Code>
    <Justification>The code does not check the return value of `unserialize()`. If `unserialize()` fails (e.g., due to an invalid serialized string), it will return `false`. Using this `false` value later in `preg_replace()` could lead to unexpected behavior or errors. Similarly, it does not verify the return value of preg_replace, which might result in NULL and unexpected behavior.
    </Justification>
  </Issue>
</Issues>
```"
CWE-89,src/CWE_89__GET__func_mysql_real_escape_string__multiple_AS-interpretation.php,"<?php







$tainted = $_GET['UserData'];

$tainted = mysql_real_escape_string($tainted);

$query = ""SELECT Trim(a.FirstName) & ' ' & Trim(a.LastName) AS employee_name, a.city, a.street & (' ' +a.housenum) AS address FROM Employees AS a  WHERE a.supervisor= $tainted "";


$conn = mysql_connect('localhost', 'mysql_user', 'mysql_password'); 
mysql_select_db('dbname') ;
echo ""query : "". $query .""<br /><br />"" ;

$res = mysql_query($query); 

while($data =mysql_fetch_array($res)){
print_r($data) ;
echo ""<br />"" ;
} 
mysql_close($conn);

?>","$conn = mysql_connect('localhost', 'mysql_user', 'mysql_password'); ",True,True,"$tainted = $_GET['UserData'];

$tainted = mysql_real_escape_string($tainted);

$query = ""SELECT Trim(a.FirstName) & ' ' & Trim(a.LastName) AS employee_name, a.city, a.street & (' ' +a.housenum) AS address FROM Employees AS a  WHERE a.supervisor= $tainted "";","```xml
<Issues>
  <Issue>
    <Type>Security</Type>
    <Weakness>CWE-89</Weakness>
    <Description>Improper Neutralization of Special Elements used in an SQL Command ('SQL Injection')</Description>
    <Severity>High</Severity>
    <File>File 1</File>
    <Code>$tainted = $_GET['UserData'];

$tainted = mysql_real_escape_string($tainted);

$query = ""SELECT Trim(a.FirstName) & ' ' & Trim(a.LastName) AS employee_name, a.city, a.street & (' ' +a.housenum) AS address FROM Employees AS a  WHERE a.supervisor= $tainted "";</Code>
    <Justification>The code constructs an SQL query using externally-influenced input ($tainted) without proper neutralization of special elements. Although mysql_real_escape_string is used, it is insufficient to prevent SQL injection in all cases, especially with the &amp; operator which is not escaped by this function. Also, the query is directly embedding the variable in the SQL statement, leading to potential SQL injection vulnerabilities.</Justification>
  </Issue>
  <Issue>
    <Type>Security</Type>
    <Weakness>CWE-477</Weakness>
    <Description>Use of Obsolete Function</Description>
    <Severity>Low</Severity>
    <File>File 1</File>
    <Code>$tainted = mysql_real_escape_string($tainted);

$query = ""SELECT Trim(a.FirstName) & ' ' & Trim(a.LastName) AS employee_name, a.city, a.street &amp; (' ' +a.housenum) AS address FROM Employees AS a  WHERE a.supervisor= $tainted "";


$conn = mysql_connect('localhost', 'mysql_user', 'mysql_password'); 
mysql_select_db('dbname') ;
echo ""query : "". $query .""&lt;br /&gt;&lt;br /&gt;"" ;

$res = mysql_query($query); 

while($data =mysql_fetch_array($res)){
print_r($data) ;
echo ""&lt;br /&gt;"" ;
} 
mysql_close($conn);</Code>
    <Justification>The code uses the `mysql_connect`, `mysql_select_db`, `mysql_query`, `mysql_fetch_array`, and `mysql_close` functions, which are deprecated. Using deprecated functions can lead to security vulnerabilities as they may not be actively maintained or patched.</Justification>
  </Issue>
</Issues>
```"
CWE-89,src/CWE_89__unserialize__no_sanitizing__multiple_AS-interpretation_simple_quote.php,"<?php







$string = $_POST['UserData'] ;
$tainted = unserialize($string);
    



$query = ""SELECT Trim(a.FirstName) & ' ' & Trim(a.LastName) AS employee_name, a.city, a.street & (' ' +a.housenum) AS address FROM Employees AS a  WHERE a.supervisor=' $tainted '"";


$conn = mysql_connect('localhost', 'mysql_user', 'mysql_password'); 
mysql_select_db('dbname') ;
echo ""query : "". $query .""<br /><br />"" ;

$res = mysql_query($query); 

while($data =mysql_fetch_array($res)){
print_r($data) ;
echo ""<br />"" ;
} 
mysql_close($conn);

?>","$conn = mysql_connect('localhost', 'mysql_user', 'mysql_password'); ",True,False,"$query = ""SELECT Trim(a.FirstName) & ' ' & Trim(a.LastName) AS employee_name, a.city, a.street & (' ' +a.housenum) AS address FROM Employees AS a  WHERE a.supervisor=' $tainted '"";","```xml
<Issues>
  <Issue>
    <Type>Security</Type>
    <Weakness>CWE-89</Weakness>
    <Description>Improper Neutralization of Special Elements used in an SQL Command ('SQL Injection')</Description>
    <Severity>High</Severity>
    <File>File 1</File>
    <Code>$query = ""SELECT Trim(a.FirstName) &amp; ' ' &amp; Trim(a.LastName) AS employee_name, a.city, a.street &amp; (' ' +a.housenum) AS address FROM Employees AS a  WHERE a.supervisor=' $tainted '"";</Code>
    <Justification>The code is vulnerable to SQL injection because it directly embeds the potentially attacker-controlled variable $tainted into the SQL query. An attacker could manipulate this variable to inject malicious SQL code, potentially allowing them to read, modify, or delete data in the database.</Justification>
  </Issue>
  <Issue>
    <Type>Security</Type>
    <Weakness>CWE-477</Weakness>
    <Description>Use of Obsolete Function</Description>
    <Severity>High</Severity>
    <File>File 1</File>
    <Code>$conn = mysql_connect('localhost', 'mysql_user', 'mysql_password');</Code>
    <Justification>The mysql_connect function is deprecated and considered obsolete. It's best to use mysqli or PDO for database connections.</Justification>
  </Issue>
  <Issue>
    <Type>Security</Type>
    <Weakness>CWE-502</Weakness>
    <Description>Deserialization of Untrusted Data</Description>
    <Severity>Critical</Severity>
    <File>File 1</File>
    <Code>$string = $_POST['UserData'] ;
$tainted = unserialize($string);</Code>
    <Justification>The code uses unserialize() on user-provided data ($_POST['UserData']). This is extremely dangerous as it allows arbitrary code execution. An attacker could craft a serialized string that, when unserialized, executes malicious code on the server.</Justification>
  </Issue>
</Issues>
```"
CWE-79,src/CWE_79__object-directGet__func_htmlspecialchars__Unsafe_use_untrusted_data-comment.php,"<!-- 
Unsafe sample
input : get the field userData from the variable $_GET via an object
sanitize : use of the function htmlspecialchars. Sanitizes the query but has a high chance to produce unexpected results
File : unsafe, use of untrusted data in a comment
-->

<!--Copyright 2015 Bertrand STIVALET 

Permission is hereby granted, without written agreement or royalty fee, to

use, copy, modify, and distribute this software and its documentation for

any purpose, provided that the above copyright notice and the following

three paragraphs appear in all copies of this software.


IN NO EVENT SHALL AUTHORS BE LIABLE TO ANY PARTY FOR DIRECT,

INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES ARISING OUT OF THE 

USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF AUTHORS HAVE

BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.


AUTHORS SPECIFICALLY DISCLAIM ANY WARRANTIES INCLUDING, BUT NOT

LIMITED TO THE IMPLIED WARRANTIES OF MERCHANTABILITY, FITNESS FOR A

PARTICULAR PURPOSE, AND NON-INFRINGEMENT.


THE SOFTWARE IS PROVIDED ON AN ""AS-IS"" BASIS AND AUTHORS HAVE NO

OBLIGATION TO PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR

MODIFICATIONS.-->


<!DOCTYPE html>
<html>
<head>
<!--
<?php
class Input{
  public function getInput(){
    return $_GET['UserData'] ;
  }
}

$temp = new Input();
$tainted =  $temp->getInput();

$tainted = htmlspecialchars($tainted, ENT_QUOTES);


echo $tainted ;
?>
-->
</head>
<body>
<h1>Hello World!</h1>
</body>
</html>",echo $tainted ;,True,True,"class Input{
  public function getInput(){
    return $_GET['UserData'] ;
  }
}

$temp = new Input();
$tainted =  $temp->getInput();

$tainted = htmlspecialchars($tainted, ENT_QUOTES);


echo $tainted ;","```xml
<Issues>
  <Issue>
    <Type>Security</Type>
    <Weakness>CWE-79</Weakness>
    <Description>Improper Neutralization of Input During Web Page Generation ('Cross-site Scripting')</Description>
    <Severity>Medium</Severity>
    <File>File 1</File>
    <Code>class Input{
  public function getInput(){
    return $_GET['UserData'] ;
  }
}

$temp = new Input();
$tainted =  $temp->getInput();

$tainted = htmlspecialchars($tainted, ENT_QUOTES);


echo $tainted ;</Code>
    <Justification>The code retrieves user input from $_GET['UserData'] and sanitizes it using htmlspecialchars. However, this sanitized input is then directly echoed within an HTML comment (&lt;!-- ... --&gt;). While htmlspecialchars encodes certain characters to prevent HTML injection, it doesn't prevent injection within HTML comments. An attacker could inject characters that prematurely close the HTML comment, allowing arbitrary HTML/JavaScript to be injected outside the comment and become executable.</Justification>
  </Issue>
  <Issue>
    <Type>Security</Type>
    <Weakness>CWE-477</Weakness>
    <Description>Use of Obsolete Function</Description>
    <Severity>Low</Severity>
    <File>File 1</File>
    <Code>$tainted = htmlspecialchars($tainted, ENT_QUOTES);</Code>
    <Justification>The use of htmlspecialchars with ENT_QUOTES is a valid and common method for sanitizing input, but might be considered less secure than more modern methods depending on the context. This is because it may not cover all possible injection vectors depending on the specific character encoding and browser being used. While not directly vulnerable, it could be considered an obsolete function in the context of modern web security best practices.</Justification>
  </Issue>
</Issues>
```"
CWE-79,src/CWE_79__GET__whitelist_using_array__Use_untrusted_data_script-window_SetInterval.php,"<!-- 
Unsafe sample
input : reads the field UserData from the variable $_GET
SANITIZE : use in_array to check if $tainted is in the white list
File : unsafe, use of untrusted data in the function setInterval
-->

<!--Copyright 2015 Bertrand STIVALET 

Permission is hereby granted, without written agreement or royalty fee, to

use, copy, modify, and distribute this software and its documentation for

any purpose, provided that the above copyright notice and the following

three paragraphs appear in all copies of this software.


IN NO EVENT SHALL AUTHORS BE LIABLE TO ANY PARTY FOR DIRECT,

INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES ARISING OUT OF THE 

USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF AUTHORS HAVE

BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.


AUTHORS SPECIFICALLY DISCLAIM ANY WARRANTIES INCLUDING, BUT NOT

LIMITED TO THE IMPLIED WARRANTIES OF MERCHANTABILITY, FITNESS FOR A

PARTICULAR PURPOSE, AND NON-INFRINGEMENT.


THE SOFTWARE IS PROVIDED ON AN ""AS-IS"" BASIS AND AUTHORS HAVE NO

OBLIGATION TO PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR

MODIFICATIONS.-->


<!DOCTYPE html>
<html>
<head>
<script>
<?php
$tainted = $_GET['UserData'];

$legal_table = array(""safe1"", ""safe2"");
if (in_array($tainted, $legal_table, true)) {
  $tainted = $tainted;
} else {
  $tainted = $legal_table[0];
}


echo ""window.setInterval('"". $tainted .""');"" ;
?>
 </script>
</head>
<body>
<h1>Hello World!</h1>
</body>
</html>","echo ""window.setInterval('"". $tainted .""');"" ;",True,True,"echo ""window.setInterval('"". $tainted .""');"" ;","```xml
<Issues>
  <Issue>
    <Type>Security</Type>
    <Weakness>CWE-79</Weakness>
    <Description>Improper Neutralization of Input During Web Page Generation ('Cross-site Scripting')</Description>
    <Severity>Medium</Severity>
    <File>File 1</File>
    <Code>echo ""window.setInterval('"". $tainted .""');"" ;</Code>
    <Justification>The code uses untrusted data from $_GET['UserData'] to generate javascript code. Even though the code uses in_array to check if the tainted data is in the white list, this is not enough to prevent XSS. The setInterval function can execute arbitrary javascript code, so an attacker can inject malicious javascript code into the $tainted variable.</Justification>
  </Issue>
</Issues>
```"
CWE-90,src/CWE_90__object-directGet__func_FILTER-CLEANING-magic_quotes_filter__userByCN-sprintf_%s_simple_quote.php,"<?php







class Input{
  public function getInput(){
    return $_GET['UserData'] ;
  }
}

$temp = new Input();
$tainted =  $temp->getInput();

$sanitized = filter_var($tainted, FILTER_SANITIZE_MAGIC_QUOTES);
  $tainted = $sanitized ;
      

$query = sprintf(""(&(objectCategory=person)(objectClass=user)(cn='%s'))"", $tainted);


$ds=ldap_connect(""localhost""); 
$r=ldap_bind($ds);
$sr=ldap_search($ds,""o=My Company, c=US"", $query);  
ldap_close($ds);

?>","$ds=ldap_connect(""localhost"");",True,False,"$query = sprintf(""(&(objectCategory=person)(objectClass=user)(cn='%s'))"", $tainted);","```xml
<Issues>
  <Issue>
    <Type>Security</Type>
    <Weakness>CWE-90</Weakness>
    <Description>Improper Neutralization of Special Elements used in an LDAP Query ('LDAP Injection')</Description>
    <Severity>High</Severity>
    <File>File 1</File>
    <Code>$query = sprintf(""(&(objectCategory=person)(objectClass=user)(cn='%s'))"", $tainted);</Code>
    <Justification>The code constructs an LDAP query using user-supplied input ($tainted) without proper neutralization of special elements.  Even with the use of filter_var with FILTER_SANITIZE_MAGIC_QUOTES, this is insufficient to prevent LDAP injection attacks, as it does not handle all potentially malicious characters and patterns that could be used to modify the query's intent.</Justification>
  </Issue>
</Issues>
```"
CWE-79,src/CWE_79__shell_exec__func_FILTER-CLEANING-email_filter__Use_untrusted_data-body.php,"<!-- 
Unsafe sample
input : use shell_exec to cat /tmp/tainted.txt
Uses an email_filter via filter_var function
File : use of untrusted data in the body
-->

<!--Copyright 2015 Bertrand STIVALET 

Permission is hereby granted, without written agreement or royalty fee, to

use, copy, modify, and distribute this software and its documentation for

any purpose, provided that the above copyright notice and the following

three paragraphs appear in all copies of this software.


IN NO EVENT SHALL AUTHORS BE LIABLE TO ANY PARTY FOR DIRECT,

INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES ARISING OUT OF THE 

USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF AUTHORS HAVE

BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.


AUTHORS SPECIFICALLY DISCLAIM ANY WARRANTIES INCLUDING, BUT NOT

LIMITED TO THE IMPLIED WARRANTIES OF MERCHANTABILITY, FITNESS FOR A

PARTICULAR PURPOSE, AND NON-INFRINGEMENT.


THE SOFTWARE IS PROVIDED ON AN ""AS-IS"" BASIS AND AUTHORS HAVE NO

OBLIGATION TO PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR

MODIFICATIONS.-->


<!DOCTYPE html>
<html>
<head/>
<body>
<?php
$tainted = shell_exec('cat /tmp/tainted.txt');

$sanitized = filter_var($tainted, FILTER_SANITIZE_EMAIL);
if (filter_var($sanitized, FILTER_VALIDATE_EMAIL))
  $tainted = $sanitized ;
else
  $tainted = """" ;


echo $tainted ;
?>
<h1>Hello World!</h1>
</body>
</html>
",echo $tainted ;,True,True,echo $tainted ;,"```xml
<Issues>
  <Issue>
    <Type>Security</Type>
    <Weakness>CWE-77</Weakness>
    <Description>Improper Neutralization of Special Elements used in a Command ('Command Injection')</Description>
    <Severity>High</Severity>
    <File>File 1</File>
    <Code>$tainted = shell_exec('cat /tmp/tainted.txt');</Code>
    <Justification>The code uses shell_exec to execute a command. If the contents of /tmp/tainted.txt are controlled by an attacker, they can inject arbitrary commands into the shell, leading to command injection.</Justification>
  </Issue>
  <Issue>
    <Type>Security</Type>
    <Weakness>CWE-79</Weakness>
    <Description>Improper Neutralization of Input During Web Page Generation ('Cross-site Scripting')</Description>
    <Severity>Medium</Severity>
    <File>File 1</File>
    <Code>echo $tainted ;</Code>
    <Justification>The code echoes the variable $tainted without proper sanitization, after it has potentially been modified by a command injection. If an attacker injects malicious code through the earlier command injection vulnerability, it can be executed in the user's browser, leading to Cross-Site Scripting (XSS).</Justification>
  </Issue>
</Issues>
```"
CWE-90,src/CWE_90__object-Array__no_sanitizing__name-sprintf_%s_simple_quote.php,"<?php







class Input{
  private $input;

  public function getInput(){
    return $this->input[1];
  }

  public  function __construct(){
    $this->input = array();
    $this->input[0]= 'safe' ;
    $this->input[1]= $_GET['UserData'] ;
    $this->input[2]= 'safe' ;
  }
}
$temp = new Input();
$tainted =  $temp->getInput();



$query = sprintf(""name='%s'"", $tainted);


$ds=ldap_connect(""localhost""); 
$r=ldap_bind($ds);
$sr=ldap_search($ds,""o=My Company, c=US"", $query);  
ldap_close($ds);

?>","$ds=ldap_connect(""localhost"");",True,True,"$query = sprintf(""name='%s'"", $tainted);


$ds=ldap_connect(""localhost""); 
$r=ldap_bind($ds);
$sr=ldap_search($ds,""o=My Company, c=US"", $query);","```xml
<Issues>
  <Issue>
    <Type>Security</Type>
    <Weakness>CWE-90</Weakness>
    <Description>Improper Neutralization of Special Elements used in an LDAP Query ('LDAP Injection')</Description>
    <Severity>High</Severity>
    <File>File 1</File>
    <Code>$query = sprintf(""name='%s'"", $tainted);


$ds=ldap_connect(""localhost""); 
$r=ldap_bind($ds);
$sr=ldap_search($ds,""o=My Company, c=US"", $query);</Code>
    <Justification>The code is vulnerable to LDAP injection because it uses sprintf to construct an LDAP query with unsanitized user input ($tainted). An attacker could manipulate the 'UserData' GET parameter to inject arbitrary LDAP code, potentially gaining unauthorized access to sensitive information or modifying directory entries. The use of sprintf without proper escaping allows malicious characters to be included in the LDAP query.</Justification>
  </Issue>
</Issues>
```"
CWE-78,src/CWE_78__array-GET__func_FILTER-VALIDATION-email_filter__ls-sprintf_%s_simple_quote.php,"<?php







$array = array();
$array[] = 'safe' ;
$array[] = $_GET['userData'] ;
$array[] = 'safe' ;
$tainted = $array[1] ;

if (filter_var($sanitized, FILTER_VALIDATE_EMAIL))
  $tainted = $sanitized ;
else
  $tainted = """" ;

$query = sprintf(""ls '%s'"", $tainted);


$ret = system($query);


?>",$ret = system($query);,True,True,"$tainted = $array[1] ;

if (filter_var($sanitized, FILTER_VALIDATE_EMAIL))
  $tainted = $sanitized ;
else
  $tainted = """" ;

$query = sprintf(""ls '%s'"", $tainted);


$ret = system($query);","```xml
<Issues>
  <Issue>
    <Type>Security</Type>
    <Weakness>CWE-78</Weakness>
    <Description>Improper Neutralization of Special Elements used in a Command ('Command Injection')</Description>
    <Severity>High</Severity>
    <File>File 1</File>
    <Code>$tainted = $array[1] ;

if (filter_var($sanitized, FILTER_VALIDATE_EMAIL))
  $tainted = $sanitized ;
else
  $tainted = """" ;

$query = sprintf(""ls '%s'"", $tainted);


$ret = system($query);</Code>
    <Justification>The code constructs a shell command using sprintf() with user-provided data from $_GET['userData'] without proper sanitization or escaping. Although there's an attempt to validate it as an email, the validated email is never assigned to the tainted variable. It means the userData is passed to the system() function. This allows an attacker to inject arbitrary shell commands by manipulating the input, leading to command injection vulnerability.</Justification>
  </Issue>
  <Issue>
    <Type>Security</Type>
    <Weakness>CWE-252</Weakness>
    <Description>Unchecked Return Value</Description>
    <Severity>Low</Severity>
    <File>File 1</File>
    <Code>$ret = system($query);</Code>
    <Justification>The return value of the `system()` function, which indicates the success or failure of the command execution, is not checked.  If the command fails to execute, the program will not be aware of it, and could lead to unexpected behavior.</Justification>
  </Issue>
  <Issue>
    <Type>Reliability</Type>
    <Weakness>CWE-252</Weakness>
    <Description>Unchecked Return Value</Description>
    <Severity>Low</Severity>
    <File>File 1</File>
    <Code>$ret = system($query);</Code>
    <Justification>The return value of the `system()` function, which indicates the success or failure of the command execution, is not checked.  If the command fails to execute, the program will not be aware of it, and could lead to unexpected behavior.</Justification>
  </Issue>
</Issues>
```"
CWE-91,src/CWE_91__system__func_FILTER-CLEANING-special_chars_filter__username_text-sprintf_%s_simple_quote.php,"<?php







$tainted = system('ls', $retval);

$sanitized = filter_var($tainted, FILTER_SANITIZE_SPECIAL_CHARS);
  $tainted = $sanitized ;
      

$query = sprintf(""


$xml = simplexml_load_file(""users.xml"");
echo ""query : "". $query .""<br /><br />"" ;

$res=$xml->xpath($query);
print_r($res);
echo ""<br />"" ;

?>","$xml = simplexml_load_file(""users.xml"");",True,True,"$query = sprintf(""


$xml = simplexml_load_file(""users.xml"");
echo ""query : "". $query .""<br /><br />"" ;

$res=$xml->xpath($query);","```xml
<Issues>
  <Issue>
    <Type>Security</Type>
    <Weakness>CWE-78</Weakness>
    <Description>Improper Neutralization of Special Elements used in a Command ('Command Injection')</Description>
    <Severity>High</Severity>
    <File>File 1</File>
    <Code>$tainted = system('ls', $retval);</Code>
    <Justification>The code uses the system() function with a hardcoded 'ls' command, but it does capture the output into the $tainted variable. This could potentially lead to command injection if the output of 'ls' is later used in a context where it is treated as a command or part of a command without proper sanitization.</Justification>
  </Issue>
  <Issue>
    <Type>Security</Type>
    <Weakness>CWE-643</Weakness>
    <Description>Improper Neutralization of Data within XPath Expressions ('XPath Injection')</Description>
    <Severity>High</Severity>
    <File>File 1</File>
    <Code>$sanitized = filter_var($tainted, FILTER_SANITIZE_SPECIAL_CHARS);
  $tainted = $sanitized ;
      

$query = sprintf(""</Code>
    <Justification>The code is vulnerable to XPath injection.  Even after sanitizing with FILTER_SANITIZE_SPECIAL_CHARS, there might still be special characters that affect the XPath query if not properly escaped for XPath. Also sprintf is not appropriate in this context as it doesn't seem to provide any sanitization and might introduce vulnerabilities.</Justification>
  </Issue>
  <Issue>
    <Type>Security</Type>
    <Weakness>CWE-91</Weakness>
    <Description>XML Injection (aka Blind XPath Injection)</Description>
    <Severity>High</Severity>
    <File>File 1</File>
    <Code>$query = sprintf(""


$xml = simplexml_load_file(""users.xml"");
echo ""query : "". $query .""<br /><br />"" ;

$res=$xml->xpath($query);</Code>
    <Justification>The code loads the 'users.xml' file and uses xpath to query, is vulnerable to XML injection because the xpath query is based on a tainted variable, which means that it can be modified and may affect the XML.</Justification>
  </Issue>
</Issues>
```"
CWE-91,src/CWE_91__array-GET__func_FILTER-CLEANING-email_filter__username-sprintf_%s_simple_quote.php,"<?php







$array = array();
$array[] = 'safe' ;
$array[] = $_GET['userData'] ;
$array[] = 'safe' ;
$tainted = $array[1] ;

$sanitized = filter_var($tainted, FILTER_SANITIZE_EMAIL);
if (filter_var($sanitized, FILTER_VALIDATE_EMAIL))
  $tainted = $sanitized ;
else
  $tainted = """" ;

$query = sprintf(""user[username='%s']"", $tainted);


$xml = simplexml_load_file(""users.xml"");
echo ""query : "". $query .""<br /><br />"" ;

$res=$xml->xpath($query);
print_r($res);
echo ""<br />"" ;

?>","$xml = simplexml_load_file(""users.xml"");",True,True,"$query = sprintf(""user[username='%s']"", $tainted);


$xml = simplexml_load_file(""users.xml"");
echo ""query : "". $query .""<br /><br />"" ;

$res=$xml->xpath($query);","```xml
<Issues>
  <Issue>
    <Type>Security</Type>
    <Weakness>CWE-91</Weakness>
    <Description>XML Injection (aka Blind XPath Injection)</Description>
    <Severity>High</Severity>
    <File>File 1</File>
    <Code>$query = sprintf(""user[username='%s']"", $tainted);


$xml = simplexml_load_file(""users.xml"");
echo ""query : "". $query .""&lt;br /&gt;&lt;br /&gt;"" ;

$res=$xml->xpath($query);</Code>
    <Justification>The code uses user-controlled data ($tainted) to construct an XPath query without proper neutralization. This allows an attacker to inject malicious XPath expressions, potentially reading sensitive data from the XML file or even modifying it if the XML database allows such operations.</Justification>
  </Issue>
</Issues>
```"
CWE-79,src/CWE_79__exec__func_htmlentities__Use_untrusted_data_propertyValue_CSS-span_Style_Property_Value.php,"<!-- 
Unsafe sample
input : use exec to execute the script /tmp/tainted.php and store the output in $tainted
sanitize : use of the function htmlentities. Sanitizes the query but has a high chance to produce unexpected results
File : unsafe, use of untrusted data in a property value in a span tag(CSS)
-->

<!--Copyright 2015 Bertrand STIVALET 

Permission is hereby granted, without written agreement or royalty fee, to

use, copy, modify, and distribute this software and its documentation for

any purpose, provided that the above copyright notice and the following

three paragraphs appear in all copies of this software.


IN NO EVENT SHALL AUTHORS BE LIABLE TO ANY PARTY FOR DIRECT,

INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES ARISING OUT OF THE 

USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF AUTHORS HAVE

BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.


AUTHORS SPECIFICALLY DISCLAIM ANY WARRANTIES INCLUDING, BUT NOT

LIMITED TO THE IMPLIED WARRANTIES OF MERCHANTABILITY, FITNESS FOR A

PARTICULAR PURPOSE, AND NON-INFRINGEMENT.


THE SOFTWARE IS PROVIDED ON AN ""AS-IS"" BASIS AND AUTHORS HAVE NO

OBLIGATION TO PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR

MODIFICATIONS.-->


<!DOCTYPE html>
<html>
<head/>
<body>
<?php
$script = ""/tmp/tainted.php"";
exec($script, $result, $return);

$tainted = $result[0];

$tainted = htmlentities($tainted, ENT_QUOTES);


echo ""<span style=\""color :"". checked_data .""\"">Hey</span>"" ;
?>
<h1>Hello World!</h1>
</body>
</html>","echo ""<span style=\""color :"". checked_data .""\"">Hey</span>"" ;",True,True,"$tainted = $result[0];

$tainted = htmlentities($tainted, ENT_QUOTES);


echo ""<span style=\""color :"". checked_data .""\"">Hey</span>"" ;","```xml
<Issues>
  <Issue>
    <Type>Security</Type>
    <Weakness>CWE-77</Weakness>
    <Description>Improper Neutralization of Special Elements used in a Command ('Command Injection')</Description>
    <Severity>High</Severity>
    <File>File 1</File>
    <Code>$script = ""/tmp/tainted.php"";
exec($script, $result, $return);

$tainted = $result[0];</Code>
    <Justification>The code uses exec() with a hardcoded path ""/tmp/tainted.php"". While the path is hardcoded, the script itself could be modified by an attacker, leading to command injection if the script contains malicious code.</Justification>
  </Issue>
  <Issue>
    <Type>Security</Type>
    <Weakness>CWE-79</Weakness>
    <Description>Improper Neutralization of Input During Web Page Generation ('Cross-site Scripting')</Description>
    <Severity>Medium</Severity>
    <File>File 1</File>
    <Code>$tainted = $result[0];

$tainted = htmlentities($tainted, ENT_QUOTES);


echo ""&lt;span style=\""color :"". checked_data .""\""&gt;Hey&lt;/span&gt;"" ;</Code>
    <Justification>The code attempts to sanitize the $tainted variable using htmlentities(). However, the sanitized data is not used. The checked_data variable is being used to set the CSS style, but it is undefined. If checked_data contained unsanitized user input, this would lead to a cross-site scripting vulnerability.</Justification>
  </Issue>
  <Issue>
    <Type>Reliability</Type>
    <Weakness>CWE-457</Weakness>
    <Description>Use of uninitialized variable</Description>
    <Severity>Medium</Severity>
    <File>File 1</File>
    <Code>

echo ""&lt;span style=\""color :"". checked_data .""\""&gt;Hey&lt;/span&gt;"" ;
?&gt;</Code>
    <Justification>The variable checked_data is used in the echo statement without being initialized. This could lead to unpredictable behavior.</Justification>
  </Issue>
</Issues>
```"
CWE-79,src/CWE_79__shell_exec__func_mysql_real_escape_string__Use_untrusted_data_script-doublequoted_Event_Handler.php,"<!-- 
Unsafe sample
input : use shell_exec to cat /tmp/tainted.txt
SANITIZE : use of mysql_real_escape string
File : use of untrusted data in a double quoted event handler in a script
-->

<!--Copyright 2015 Bertrand STIVALET 

Permission is hereby granted, without written agreement or royalty fee, to

use, copy, modify, and distribute this software and its documentation for

any purpose, provided that the above copyright notice and the following

three paragraphs appear in all copies of this software.


IN NO EVENT SHALL AUTHORS BE LIABLE TO ANY PARTY FOR DIRECT,

INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES ARISING OUT OF THE 

USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF AUTHORS HAVE

BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.


AUTHORS SPECIFICALLY DISCLAIM ANY WARRANTIES INCLUDING, BUT NOT

LIMITED TO THE IMPLIED WARRANTIES OF MERCHANTABILITY, FITNESS FOR A

PARTICULAR PURPOSE, AND NON-INFRINGEMENT.


THE SOFTWARE IS PROVIDED ON AN ""AS-IS"" BASIS AND AUTHORS HAVE NO

OBLIGATION TO PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR

MODIFICATIONS.-->


<!DOCTYPE html>
<html>
<head/>
<body>
<?php
$tainted = shell_exec('cat /tmp/tainted.txt');

$tainted = mysql_real_escape_string($tainted);


echo ""<div onmouseover=\""x=\"""". $tainted .""\""\>"";
?>
<h1>Hello World!</h1>
</div>
</body>
</html>","echo ""<div onmouseover=\""x=\"""". $tainted .""\""\>"";",True,True,"echo ""<div onmouseover=\""x=\"""". $tainted .""\""\>"";
?>","```xml
<Issues>
  <Issue>
    <Type>Security</Type>
    <Weakness>CWE-77</Weakness>
    <Description>Improper Neutralization of Special Elements used in a Command ('Command Injection')</Description>
    <Severity>High</Severity>
    <File>File 1</File>
    <Code>$tainted = shell_exec('cat /tmp/tainted.txt');</Code>
    <Justification>The code uses shell_exec to execute a command. If the file /tmp/tainted.txt contains malicious commands, they will be executed. This is a command injection vulnerability.</Justification>
  </Issue>
  <Issue>
    <Type>Security</Type>
    <Weakness>CWE-79</Weakness>
    <Description>Improper Neutralization of Input During Web Page Generation ('Cross-site Scripting')</Description>
    <Severity>Medium</Severity>
    <File>File 1</File>
    <Code>
echo ""&lt;div onmouseover=\""x=\"""". $tainted .""\""\>"";
?&gt;</Code>
    <Justification>The code echoes user-controlled input $tainted inside a double-quoted event handler attribute. Even though mysql_real_escape_string is used, it is intended for SQL, not XSS. An attacker can inject arbitrary JavaScript code into the onmouseover attribute.</Justification>
  </Issue>
  <Issue>
    <Type>Security</Type>
    <Weakness>CWE-477</Weakness>
    <Description>Use of Obsolete Function</Description>
    <Severity>Low</Severity>
    <File>File 1</File>
    <Code>$tainted = mysql_real_escape_string($tainted);</Code>
    <Justification>The code uses the mysql_real_escape_string function, which is deprecated. It is recommended to use MySQLi or PDO with prepared statements instead.</Justification>
  </Issue>
</Issues>
```"
CWE-91,src/CWE_91__system__func_preg_match-no_filtering__data-interpretation_simple_quote.php,"<?php







$tainted = system('ls', $retval);

$re = ""/^.*$/"";
if(preg_match($re, $tainted) == 1){
  $tainted = $tainted;
}
else{
  $tainted = """";
}

$query = ""' $tainted '"";


$xml = simplexml_load_file(""users.xml"");
echo ""query : "". $query .""<br /><br />"" ;

$res=$xml->xpath($query);
print_r($res);
echo ""<br />"" ;

?>","$xml = simplexml_load_file(""users.xml"");",False,False,,"```xml
<Issues>
  <Issue>
    <Type>Security</Type>
    <Weakness>CWE-78</Weakness>
    <Description>Improper Neutralization of Special Elements used in a Command ('Command Injection')</Description>
    <Severity>High</Severity>
    <File>File 1</File>
    <Code>$tainted = system('ls', $retval);</Code>
    <Justification>The code uses the system() function to execute the 'ls' command. While the command itself is not directly influenced by user input in this snippet, the use of system() can be risky. It is always better to use specific functions instead of system() where possible, to minimize attack surface and increase readability. Additionally, relying on the 'ls' output as input to a further process (XPATH query) can become an attack vector if the code base changes in the future.</Justification>
  </Issue>
  <Issue>
    <Type>Security</Type>
    <Weakness>CWE-643</Weakness>
    <Description>Improper Neutralization of Data within XPath Expressions ('XPath Injection')</Description>
    <Severity>High</Severity>
    <File>File 1</File>
    <Code>$res=$xml->xpath($query);</Code>
    <Justification>The code uses the xpath() function to execute an XPath query. The query is built using a variable, $query, that originates (indirectly) from the system() call and is incorporated into the query string. Even though the $tainted variable undergoes a preg_match filter, it is not sufficient to guarantee the absence of malicious XPath syntax, which could lead to XPath injection.  Since the system() call's output is used as input to the xpath expression, this is a critical vulnerability if the system call itself takes external input from the user.</Justification>
  </Issue>
</Issues>
```"
CWE-79,src/CWE_79__system__func_mysql_real_escape_string__Use_untrusted_data_script-doublequoted_Event_Handler.php,"<!-- 
Unsafe sample
input : execute a ls command using the function system, and put the last result in $tainted
SANITIZE : use of mysql_real_escape string
File : use of untrusted data in a double quoted event handler in a script
-->

<!--Copyright 2015 Bertrand STIVALET 

Permission is hereby granted, without written agreement or royalty fee, to

use, copy, modify, and distribute this software and its documentation for

any purpose, provided that the above copyright notice and the following

three paragraphs appear in all copies of this software.


IN NO EVENT SHALL AUTHORS BE LIABLE TO ANY PARTY FOR DIRECT,

INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES ARISING OUT OF THE 

USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF AUTHORS HAVE

BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.


AUTHORS SPECIFICALLY DISCLAIM ANY WARRANTIES INCLUDING, BUT NOT

LIMITED TO THE IMPLIED WARRANTIES OF MERCHANTABILITY, FITNESS FOR A

PARTICULAR PURPOSE, AND NON-INFRINGEMENT.


THE SOFTWARE IS PROVIDED ON AN ""AS-IS"" BASIS AND AUTHORS HAVE NO

OBLIGATION TO PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR

MODIFICATIONS.-->


<!DOCTYPE html>
<html>
<head/>
<body>
<?php
$tainted = system('ls', $retval);

$tainted = mysql_real_escape_string($tainted);


echo ""<div onmouseover=\""x=\"""". $tainted .""\""\>"";
?>
<h1>Hello World!</h1>
</div>
</body>
</html>","echo ""<div onmouseover=\""x=\"""". $tainted .""\""\>"";",True,True,"$tainted = system('ls', $retval);

$tainted = mysql_real_escape_string($tainted);


echo ""<div onmouseover=\""x=\"""". $tainted .""\""\>"";","```xml
<Issues>
  <Issue>
    <Type>Security</Type>
    <Weakness>CWE-78</Weakness>
    <Description>Improper Neutralization of Special Elements used in a Command ('Command Injection')</Description>
    <Severity>High</Severity>
    <File>File 1</File>
    <Code>$tainted = system('ls', $retval);</Code>
    <Justification>The code uses the `system()` function to execute an OS command. While the example uses 'ls', in a real-world scenario, this could execute arbitrary commands based on external input, leading to command injection if the argument to `system()` is not properly sanitized.</Justification>
  </Issue>
  <Issue>
    <Type>Security</Type>
    <Weakness>CWE-79</Weakness>
    <Description>Improper Neutralization of Input During Web Page Generation ('Cross-site Scripting')</Description>
    <Severity>Medium</Severity>
    <File>File 1</File>
    <Code>
$tainted = system('ls', $retval);

$tainted = mysql_real_escape_string($tainted);


echo ""&lt;div onmouseover=\""x=\"""". $tainted .""\""\>"";
</Code>
    <Justification>The code attempts to neutralize the output of the `system()` call using `mysql_real_escape_string()`. However, this function is designed to escape strings for use in MySQL queries and does not provide adequate protection against Cross-Site Scripting (XSS) vulnerabilities. The escaped string is then embedded within a double-quoted event handler attribute (`onmouseover`) within an HTML div element. This means that although special characters relevant to SQL are escaped, characters that could introduce JavaScript code (e.g., single quotes, semicolons, etc.) are not, making the application vulnerable to XSS attacks.</Justification>
  </Issue>
  <Issue>
    <Type>Security</Type>
    <Weakness>CWE-477</Weakness>
    <Description>Use of Obsolete Function</Description>
    <Severity>Low</Severity>
    <File>File 1</File>
    <Code>$tainted = mysql_real_escape_string($tainted);</Code>
    <Justification>The code uses the `mysql_real_escape_string()` function, which is deprecated. The use of deprecated functions can introduce security vulnerabilities and compatibility issues.</Justification>
  </Issue>
</Issues>
```"
CWE-79,src/CWE_79__backticks__func_FILTER-VALIDATION-email_filter__Unsafe_use_untrusted_data-tag_Name.php,"<!-- 
Unsafe sample
input : backticks interpretation, reading the file /tmp/tainted.txt
Flushes content of $sanitized if the filter email_filter is not applied
File : unsafe, use of untrusted data in an tag name
-->

<!--Copyright 2015 Bertrand STIVALET 

Permission is hereby granted, without written agreement or royalty fee, to

use, copy, modify, and distribute this software and its documentation for

any purpose, provided that the above copyright notice and the following

three paragraphs appear in all copies of this software.


IN NO EVENT SHALL AUTHORS BE LIABLE TO ANY PARTY FOR DIRECT,

INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES ARISING OUT OF THE 

USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF AUTHORS HAVE

BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.


AUTHORS SPECIFICALLY DISCLAIM ANY WARRANTIES INCLUDING, BUT NOT

LIMITED TO THE IMPLIED WARRANTIES OF MERCHANTABILITY, FITNESS FOR A

PARTICULAR PURPOSE, AND NON-INFRINGEMENT.


THE SOFTWARE IS PROVIDED ON AN ""AS-IS"" BASIS AND AUTHORS HAVE NO

OBLIGATION TO PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR

MODIFICATIONS.-->


<!DOCTYPE html>
<html>
<head/>
<body>
<?php
$tainted = `cat /tmp/tainted.txt`;

if (filter_var($sanitized, FILTER_VALIDATE_EMAIL))
  $tainted = $sanitized ;
else
  $tainted = """" ;


echo ""<"".  $tainted ."" href= \""/bob\"" />"" ;
?>
<h1>Hello World!</h1>
</body>
</html>","echo ""<"".  $tainted ."" href= \""/bob\"" />"" ;",True,True,"echo ""<"".  $tainted ."" href= \""/bob\"" />"" ;","```xml
<Issues>
  <Issue>
    <Type>Security</Type>
    <Weakness>CWE-79</Weakness>
    <Description>Improper Neutralization of Input During Web Page Generation ('Cross-site Scripting')</Description>
    <Severity>High</Severity>
    <File>File 1</File>
    <Code>echo ""&lt;"".  $tainted ."" href= \""/bob\"" /&gt;"" ;</Code>
    <Justification>The code uses unsanitized input `$tainted` within an HTML tag name, allowing potential injection of arbitrary HTML or JavaScript code. If `$tainted` contains malicious code, it will be executed in the user's browser, leading to Cross-Site Scripting (XSS).</Justification>
  </Issue>
  <Issue>
    <Type>Security</Type>
    <Weakness>CWE-78</Weakness>
    <Description>Improper Neutralization of Special Elements used in an OS Command ('OS Command Injection')</Description>
    <Severity>High</Severity>
    <File>File 1</File>
    <Code>$tainted = `cat /tmp/tainted.txt`;</Code>
    <Justification>The code uses backticks to execute the command `cat /tmp/tainted.txt`. This is vulnerable to OS command injection. An attacker can inject arbitrary OS commands into the `/tmp/tainted.txt` file, which will then be executed by the server.</Justification>
  </Issue>
  <Issue>
    <Type>Reliability</Type>
    <Weakness>CWE-252</Weakness>
    <Description>Unchecked Return Value</Description>
    <Severity>Medium</Severity>
    <File>File 1</File>
    <Code>$tainted = `cat /tmp/tainted.txt`;</Code>
    <Justification>The code uses backticks to execute the command `cat /tmp/tainted.txt` but does not check the return value of the command. If the command fails (e.g., file not found), `$tainted` may contain unexpected values, leading to unpredictable behavior.</Justification>
  </Issue>
  <Issue>
    <Type>Security</Type>
    <Weakness>CWE-252</Weakness>
    <Description>Unchecked Return Value</Description>
    <Severity>Medium</Severity>
    <File>File 1</File>
    <Code>if (filter_var($sanitized, FILTER_VALIDATE_EMAIL))</Code>
    <Justification>The code does not check return value for filter_var. if filter_var fails, the code continue executing, leading to security issues.</Justification>
  </Issue>
  <Issue>
    <Type>Reliability</Type>
    <Weakness>CWE-478</Weakness>
    <Description>Missing Default Case in Switch Statement</Description>
    <Severity>Low</Severity>
    <File>File 1</File>
    <Code>if (filter_var($sanitized, FILTER_VALIDATE_EMAIL))
  $tainted = $sanitized ;
else
  $tainted = """" ;</Code>
    <Justification>The code uses if/else but it can be interpreted as a switch statement. The switch statement is missing a default case.</Justification>
  </Issue>
</Issues>
```"
CWE-79,src/CWE_79__GET__whitelist_using_array__Use_untrusted_data_attribute-unquoted_Attr.php,"<!-- 
Unsafe sample
input : reads the field UserData from the variable $_GET
SANITIZE : use in_array to check if $tainted is in the white list
File : use of untrusted data in a unquoted attribute
-->

<!--Copyright 2015 Bertrand STIVALET 

Permission is hereby granted, without written agreement or royalty fee, to

use, copy, modify, and distribute this software and its documentation for

any purpose, provided that the above copyright notice and the following

three paragraphs appear in all copies of this software.


IN NO EVENT SHALL AUTHORS BE LIABLE TO ANY PARTY FOR DIRECT,

INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES ARISING OUT OF THE 

USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF AUTHORS HAVE

BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.


AUTHORS SPECIFICALLY DISCLAIM ANY WARRANTIES INCLUDING, BUT NOT

LIMITED TO THE IMPLIED WARRANTIES OF MERCHANTABILITY, FITNESS FOR A

PARTICULAR PURPOSE, AND NON-INFRINGEMENT.


THE SOFTWARE IS PROVIDED ON AN ""AS-IS"" BASIS AND AUTHORS HAVE NO

OBLIGATION TO PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR

MODIFICATIONS.-->


<!DOCTYPE html>
<html>
<head/>
<body>
<?php
$tainted = $_GET['UserData'];

$legal_table = array(""safe1"", ""safe2"");
if (in_array($tainted, $legal_table, true)) {
  $tainted = $tainted;
} else {
  $tainted = $legal_table[0];
}


echo ""<div id="". $tainted ."">content</div>"" ;
?>
<h1>Hello World!</h1>
</body>
</html>","echo ""<div id="". $tainted ."">content</div>"" ;",True,True,"echo ""<div id="". $tainted ."">content</div>"" ;","```xml
<Issues>
  <Issue>
    <Type>Security</Type>
    <Weakness>CWE-79</Weakness>
    <Description>Improper Neutralization of Input During Web Page Generation ('Cross-site Scripting')</Description>
    <Severity>Medium</Severity>
    <File>File 1</File>
    <Code>echo ""&lt;div id="". $tainted ."">content&lt;/div>"" ;</Code>
    <Justification>The code uses unsanitized user input `$tainted` directly within an HTML attribute (`id`). Although a whitelist is used, the sanitized output is still placed directly into the HTML without proper encoding. This could lead to XSS if the allowed values in the whitelist contain special characters that, when rendered by the browser, can execute malicious scripts. For example, a whitelisted value like `x"" onclick=""alert('XSS')` would cause an XSS vulnerability.</Justification>
  </Issue>
</Issues>
```"
CWE-79,src/CWE_79__popen__func_FILTER-CLEANING-number_int_filter__Use_untrusted_data_attribute-unquoted_Attr.php,"<!-- 
Unsafe sample
input : Uses popen to read the file /tmp/tainted.txt using cat command
Uses a number_int_filter via filter_var function
File : use of untrusted data in a unquoted attribute
-->

<!--Copyright 2015 Bertrand STIVALET 

Permission is hereby granted, without written agreement or royalty fee, to

use, copy, modify, and distribute this software and its documentation for

any purpose, provided that the above copyright notice and the following

three paragraphs appear in all copies of this software.


IN NO EVENT SHALL AUTHORS BE LIABLE TO ANY PARTY FOR DIRECT,

INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES ARISING OUT OF THE 

USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF AUTHORS HAVE

BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.


AUTHORS SPECIFICALLY DISCLAIM ANY WARRANTIES INCLUDING, BUT NOT

LIMITED TO THE IMPLIED WARRANTIES OF MERCHANTABILITY, FITNESS FOR A

PARTICULAR PURPOSE, AND NON-INFRINGEMENT.


THE SOFTWARE IS PROVIDED ON AN ""AS-IS"" BASIS AND AUTHORS HAVE NO

OBLIGATION TO PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR

MODIFICATIONS.-->


<!DOCTYPE html>
<html>
<head/>
<body>
<?php
$handle = popen('/bin/cat /tmp/tainted.txt', 'r');
$tainted = fread($handle, 4096);
pclose($handle);

$sanitized = filter_var($tainted, FILTER_SANITIZE_NUMBER_INT);
if (filter_var($sanitized, FILTER_VALIDATE_INT))
  $tainted = $sanitized ;
else
  $tainted = """" ;


echo ""<div id="". $tainted ."">content</div>"" ;
?>
<h1>Hello World!</h1>
</body>
</html>","echo ""<div id="". $tainted ."">content</div>"" ;",True,True,"echo ""<div id="". $tainted ."">content</div>"" ;","```xml
<Issues>
  <Issue>
    <Type>Security</Type>
    <Weakness>CWE-79</Weakness>
    <Description>Improper Neutralization of Input During Web Page Generation ('Cross-site Scripting')</Description>
    <Severity>Medium</Severity>
    <File>File 1</File>
    <Code>echo ""&lt;div id="". $tainted ."">content&lt;/div>"" ;</Code>
    <Justification>The code uses external input $tainted to construct an HTML attribute value without proper neutralization. Although the input is sanitized using FILTER_SANITIZE_NUMBER_INT and validated using FILTER_VALIDATE_INT, an attacker can still inject HTML attributes or break the HTML structure by crafting a numerical input that includes characters like a hyphen ""-"" that are valid in numerical input but can cause problems when used in an HTML attribute.</Justification>
  </Issue>
  <Issue>
    <Type>Security</Type>
    <Weakness>CWE-78</Weakness>
    <Description>Improper Neutralization of Special Elements used in an OS Command ('OS Command Injection')</Description>
    <Severity>High</Severity>
    <File>File 1</File>
    <Code>$handle = popen('/bin/cat /tmp/tainted.txt', 'r');
$tainted = fread($handle, 4096);
pclose($handle);</Code>
    <Justification>The code uses popen to execute the command '/bin/cat /tmp/tainted.txt'. Although the command itself is hardcoded and doesn't directly take user input, there's still a risk if the file `/tmp/tainted.txt` is modifiable by an attacker, because it allows an attacker to inject arbitrary commands into the system. If the attacker can control the content of `/tmp/tainted.txt`, they can insert shell metacharacters and commands that will be executed when the `cat` command processes the file. For instance, if `/tmp/tainted.txt` contains the string ""; rm -rf /"", this would result in the potentially disastrous command `cat /tmp/tainted.txt; rm -rf /` being executed.</Justification>
  </Issue>
</Issues>
```"
CWE-79,src/CWE_79__unserialize__func_FILTER-CLEANING-email_filter__Unsafe_use_untrusted_data-comment.php,"<!-- 
Unsafe sample
input : Get a serialize string in POST and unserialize it
Uses an email_filter via filter_var function
File : unsafe, use of untrusted data in a comment
-->

<!--Copyright 2015 Bertrand STIVALET 

Permission is hereby granted, without written agreement or royalty fee, to

use, copy, modify, and distribute this software and its documentation for

any purpose, provided that the above copyright notice and the following

three paragraphs appear in all copies of this software.


IN NO EVENT SHALL AUTHORS BE LIABLE TO ANY PARTY FOR DIRECT,

INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES ARISING OUT OF THE 

USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF AUTHORS HAVE

BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.


AUTHORS SPECIFICALLY DISCLAIM ANY WARRANTIES INCLUDING, BUT NOT

LIMITED TO THE IMPLIED WARRANTIES OF MERCHANTABILITY, FITNESS FOR A

PARTICULAR PURPOSE, AND NON-INFRINGEMENT.


THE SOFTWARE IS PROVIDED ON AN ""AS-IS"" BASIS AND AUTHORS HAVE NO

OBLIGATION TO PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR

MODIFICATIONS.-->


<!DOCTYPE html>
<html>
<head>
<!--
<?php
$string = $_POST['UserData'] ;
$tainted = unserialize($string);
    

$sanitized = filter_var($tainted, FILTER_SANITIZE_EMAIL);
if (filter_var($sanitized, FILTER_VALIDATE_EMAIL))
  $tainted = $sanitized ;
else
  $tainted = """" ;


echo $tainted ;
?>
-->
</head>
<body>
<h1>Hello World!</h1>
</body>
</html>",echo $tainted ;,True,True,echo $tainted ;,"```xml
<Issues>
  <Issue>
    <Type>Security</Type>
    <Weakness>CWE-502</Weakness>
    <Description>Deserialization of Untrusted Data</Description>
    <Severity>High</Severity>
    <File>File 1</File>
    <Code>$string = $_POST['UserData'] ;
$tainted = unserialize($string);</Code>
    <Justification>The code uses unserialize() on user-controlled data from $_POST['UserData']. This is highly dangerous as it allows arbitrary code execution if the serialized string is maliciously crafted.</Justification>
  </Issue>
  <Issue>
    <Type>Security</Type>
    <Weakness>CWE-79</Weakness>
    <Description>Improper Neutralization of Input During Web Page Generation ('Cross-site Scripting')</Description>
    <Severity>Medium</Severity>
    <File>File 1</File>
    <Code>echo $tainted ;</Code>
    <Justification>The code echoes the potentially tainted variable $tainted without proper escaping or sanitization into the HTML document.  Even after attempting to sanitize with FILTER_SANITIZE_EMAIL, the result is still outputted directly, which is vulnerable to Cross-Site Scripting (XSS) attacks because email addresses can contain characters that, when rendered in HTML, can be interpreted as code.</Justification>
  </Issue>
  <Issue>
    <Type>Reliability</Type>
    <Weakness>CWE-252</Weakness>
    <Description>Unchecked Return Value</Description>
    <Severity>Low</Severity>
    <File>File 1</File>
    <Code>filter_var($sanitized, FILTER_VALIDATE_EMAIL)</Code>
    <Justification>The return value of filter_var with FILTER_VALIDATE_EMAIL is not explicitly checked. Although the code proceeds based on whether the validation succeeds, it is better to explicitly check the boolean return value against true or false, or check the type for unexpected results.</Justification>
  </Issue>
</Issues>
```"
CWE-91,src/CWE_91__unserialize__func_preg_match-no_filtering__data-interpretation_simple_quote.php,"<?php







$string = $_POST['UserData'] ;
$tainted = unserialize($string);
    

$re = ""/^.*$/"";
if(preg_match($re, $tainted) == 1){
  $tainted = $tainted;
}
else{
  $tainted = """";
}

$query = ""' $tainted '"";


$xml = simplexml_load_file(""users.xml"");
echo ""query : "". $query .""<br /><br />"" ;

$res=$xml->xpath($query);
print_r($res);
echo ""<br />"" ;

?>","$xml = simplexml_load_file(""users.xml"");",True,True,"$string = $_POST['UserData'] ;
$tainted = unserialize($string);
    

$re = ""/^.*$/"";
if(preg_match($re, $tainted) == 1){
  $tainted = $tainted;
}
else{
...","```xml
<Issues>
  <Issue>
    <Type>Security</Type>
    <Weakness>CWE-91</Weakness>
    <Description>XML Injection (aka Blind XPath Injection)</Description>
    <Severity>High</Severity>
    <File>File 1</File>
    <Code>$string = $_POST['UserData'] ;
$tainted = unserialize($string);
    

$re = ""/^.*$/"";
if(preg_match($re, $tainted) == 1){
  $tainted = $tainted;
}
else{
...</Code>
    <Justification>The code takes user-supplied data via $_POST['UserData'], unserializes it, and then uses it to construct an XPath query. Even with the regex, this is still vulnerable to XML injection as the regex ""^.*$"" will match any string. An attacker could inject malicious XPath code, potentially allowing them to extract sensitive data from the users.xml file or even modify the file.</Justification>
  </Issue>
  <Issue>
    <Type>Security</Type>
    <Weakness>CWE-502</Weakness>
    <Description>Deserialization of Untrusted Data</Description>
    <Severity>Critical</Severity>
    <File>File 1</File>
    <Code>$string = $_POST['UserData'] ;
$tainted = unserialize($string);</Code>
    <Justification>The code deserializes user-provided data from $_POST['UserData'] using unserialize(). This is extremely dangerous as an attacker could craft a malicious serialized object that, when unserialized, could execute arbitrary code on the server. This can lead to complete system compromise.</Justification>
  </Issue>
</Issues>
```"
CWE-91,src/CWE_91__shell_exec__func_FILTER-CLEANING-special_chars_filter__data-concatenation_simple_quote.php,"<?php







$tainted = shell_exec('cat /tmp/tainted.txt');

$sanitized = filter_var($tainted, FILTER_SANITIZE_SPECIAL_CHARS);
  $tainted = $sanitized ;
      

$query = ""'"". $tainted . ""'"";


$xml = simplexml_load_file(""users.xml"");
echo ""query : "". $query .""<br /><br />"" ;

$res=$xml->xpath($query);
print_r($res);
echo ""<br />"" ;

?>","$xml = simplexml_load_file(""users.xml"");",True,True,"$query = ""'"". $tainted . ""'"";


$xml = simplexml_load_file(""users.xml"");
echo ""query : "". $query .""<br /><br />"" ;

$res=$xml->xpath($query);","```xml
<Issues>
  <Issue>
    <Type>Security</Type>
    <Weakness>CWE-91</Weakness>
    <Description>XML Injection (aka Blind XPath Injection)</Description>
    <Severity>High</Severity>
    <File>File 1</File>
    <Code>$query = ""'"". $tainted . ""'"";


$xml = simplexml_load_file(""users.xml"");
echo ""query : "". $query .""&lt;br /&gt;&lt;br /&gt;"" ;

$res=$xml->xpath($query);</Code>
    <Justification>The code constructs an XPath query by concatenating a tainted variable directly into the query string. This can lead to XML injection if the $tainted variable contains malicious XPath expressions. Although the input is sanitized using FILTER_SANITIZE_SPECIAL_CHARS, this is insufficient to prevent XPath injection attacks, as it only encodes special characters but does not prevent an attacker from injecting malicious XPath syntax.</Justification>
  </Issue>
  <Issue>
    <Type>Security</Type>
    <Weakness>CWE-78</Weakness>
    <Description>Improper Neutralization of Special Elements used in an OS Command ('OS Command Injection')</Description>
    <Severity>High</Severity>
    <File>File 1</File>
    <Code>$tainted = shell_exec('cat /tmp/tainted.txt');</Code>
    <Justification>The code uses shell_exec to execute a command. If the /tmp/tainted.txt file is controllable by an attacker, they could inject malicious commands that will be executed on the server. This leads to command injection.</Justification>
  </Issue>
  <Issue>
    <Type>Reliability</Type>
    <Weakness>CWE-252</Weakness>
    <Description>Unchecked Return Value</Description>
    <Severity>Medium</Severity>
    <File>File 1</File>
    <Code>$tainted = shell_exec('cat /tmp/tainted.txt');
...</Code>
    <Justification>The code does not check the return value of shell_exec. If the command fails, $tainted will be null and the program will continue execution. It is necessary to validate the return value to ensure the command executed successfully.</Justification>
  </Issue>
  <Issue>
    <Type>Reliability</Type>
    <Weakness>CWE-391</Weakness>
    <Description>Unchecked Error Condition</Description>
    <Severity>Medium</Severity>
    <File>File 1</File>
    <Code>$xml = simplexml_load_file(""users.xml"");</Code>
    <Justification>The code uses simplexml_load_file without checking if the file loading was successful. If the file doesn't exist or is malformed, simplexml_load_file will return false. The code should check for this condition to prevent potential errors.</Justification>
  </Issue>
  <Issue>
    <Type>Security</Type>
    <Weakness>CWE-434</Weakness>
    <Description>Unrestricted Upload of File with Dangerous Type</Description>
    <Severity>Critical</Severity>
    <File>File 1</File>
    <Code>$tainted = shell_exec('cat /tmp/tainted.txt');</Code>
    <Justification>The code reads data from a file /tmp/tainted.txt that is under the control of the operating system (through shell_exec). If an attacker can upload a file to /tmp/tainted.txt with malicious content, this content can be read and used to inject commands.</Justification>
  </Issue>
  <Issue>
    <Type>Maintainability</Type>
    <Weakness>CWE-1051</Weakness>
    <Description>Initialization with Hard-Coded Network Resource Configuration Data</Description>
    <Severity>Low</Severity>
    <File>File 1</File>
    <Code>$xml = simplexml_load_file(""users.xml"");</Code>
    <Justification>The code uses a hard-coded file name ""users.xml"". It would be more maintainable to externalize the file name as a configuration parameter.</Justification>
  </Issue>
</Issues>
```"
CWE-91,src/CWE_91__fopen__func_FILTER-CLEANING-full_special_chars_filter__username_at-interpretation_simple_quote.php,"<?php







$handle = @fopen(""/tmp/tainted.txt"", ""r"");

if ($handle) {
  if(($tainted = fgets($handle, 4096)) == false) {
    $tainted = """";
  }
  fclose($handle);
} else {
  $tainted = """";
}

$sanitized = filter_var($tainted, FILTER_SANITIZE_FULL_SPECIAL_CHARS);
  $tainted = $sanitized ;
     

$query = ""


$xml = simplexml_load_file(""users.xml"");
echo ""query : "". $query .""<br /><br />"" ;

$res=$xml->xpath($query);
print_r($res);
echo ""<br />"" ;

?>","$xml = simplexml_load_file(""users.xml"");",False,False,,"```xml
<Issues>
  <Issue>
    <Type>Security</Type>
    <Weakness>CWE-643</Weakness>
    <Description>Improper Neutralization of Data within XPath Expressions ('XPath Injection')</Description>
    <Severity>High</Severity>
    <File>File 1</File>
    <Code>$query = ""

$xml = simplexml_load_file(""users.xml"");
echo ""query : "". $query .""<br /><br />"" ;

$res=$xml->xpath($query);</Code>
    <Justification>The $query variable, derived from $tainted, is used in an XPath expression without proper neutralization. If $tainted contains malicious XPath syntax, it could lead to XPath injection, allowing an attacker to query or manipulate XML data.</Justification>
  </Issue>
  <Issue>
    <Type>Reliability</Type>
    <Weakness>CWE-252</Weakness>
    <Description>Unchecked Return Value</Description>
    <Severity>Medium</Severity>
    <File>File 1</File>
    <Code>  if(($tainted = fgets($handle, 4096)) == false) {
    $tainted = """";
  }
  fclose($handle);</Code>
    <Justification>The return value of fclose($handle) is not checked. If fclose fails (e.g., due to resource exhaustion), the program won't be aware of the failure, potentially leading to resource leaks or other unexpected behavior.</Justification>
  </Issue>
</Issues>
```"
CWE-79,src/CWE_79__proc_open__func_htmlentities__Unsafe_use_untrusted_data-tag_Name.php,"<!-- 
Unsafe sample
input : use proc_open to read /tmp/tainted.txt
sanitize : use of the function htmlentities. Sanitizes the query but has a high chance to produce unexpected results
File : unsafe, use of untrusted data in an tag name
-->

<!--Copyright 2015 Bertrand STIVALET 

Permission is hereby granted, without written agreement or royalty fee, to

use, copy, modify, and distribute this software and its documentation for

any purpose, provided that the above copyright notice and the following

three paragraphs appear in all copies of this software.


IN NO EVENT SHALL AUTHORS BE LIABLE TO ANY PARTY FOR DIRECT,

INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES ARISING OUT OF THE 

USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF AUTHORS HAVE

BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.


AUTHORS SPECIFICALLY DISCLAIM ANY WARRANTIES INCLUDING, BUT NOT

LIMITED TO THE IMPLIED WARRANTIES OF MERCHANTABILITY, FITNESS FOR A

PARTICULAR PURPOSE, AND NON-INFRINGEMENT.


THE SOFTWARE IS PROVIDED ON AN ""AS-IS"" BASIS AND AUTHORS HAVE NO

OBLIGATION TO PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR

MODIFICATIONS.-->


<!DOCTYPE html>
<html>
<head/>
<body>
<?php
$descriptorspec = array(
  0 => array(""pipe"", ""r""),
  1 => array(""pipe"", ""w""),
  2 => array(""file"", ""/tmp/error-output.txt"", ""a"")
  );
$cwd = '/tmp';
$process = proc_open('more /tmp/tainted.txt', $descriptorspec, $pipes, $cwd, NULL);
if (is_resource($process)) {
  fclose($pipes[0]);
  $tainted = stream_get_contents($pipes[1]);
  fclose($pipes[1]);
  $return_value = proc_close($process);
}

$tainted = htmlentities($tainted, ENT_QUOTES);


echo ""<"".  $tainted ."" href= \""/bob\"" />"" ;
?>
<h1>Hello World!</h1>
</body>
</html>","echo ""<"".  $tainted ."" href= \""/bob\"" />"" ;",True,True,"echo ""<"".  $tainted ."" href= \""/bob\"" />"" ;","```xml
<Issues>
  <Issue>
    <Type>Security</Type>
    <Weakness>CWE-79</Weakness>
    <Description>Improper Neutralization of Input During Web Page Generation ('Cross-site Scripting')</Description>
    <Severity>High</Severity>
    <File>File 1</File>
    <Code>
echo ""&lt;"".  $tainted ."" href= \""/bob\"" /&gt;"" ;</Code>
    <Justification>The code uses external input to construct part of an HTML tag. Even after using htmlentities, which attempts to sanitize the input, vulnerabilities can still arise because the sanitization may not be sufficient to prevent all forms of cross-site scripting, especially when used in tag names. Also, htmlentities has a high chance to produce unexpected results.</Justification>
  </Issue>
</Issues>
```"
CWE-79,src/CWE_79__proc_open__func_preg_replace__Use_untrusted_data_propertyValue_CSS-quoted_Property_Value.php,"<!-- 
Unsafe sample
input : use proc_open to read /tmp/tainted.txt
SANITIZE : use of preg_replace
File : unsafe, use of untrusted data in a quoted property value (CSS)
-->

<!--Copyright 2015 Bertrand STIVALET 

Permission is hereby granted, without written agreement or royalty fee, to

use, copy, modify, and distribute this software and its documentation for

any purpose, provided that the above copyright notice and the following

three paragraphs appear in all copies of this software.


IN NO EVENT SHALL AUTHORS BE LIABLE TO ANY PARTY FOR DIRECT,

INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES ARISING OUT OF THE 

USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF AUTHORS HAVE

BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.


AUTHORS SPECIFICALLY DISCLAIM ANY WARRANTIES INCLUDING, BUT NOT

LIMITED TO THE IMPLIED WARRANTIES OF MERCHANTABILITY, FITNESS FOR A

PARTICULAR PURPOSE, AND NON-INFRINGEMENT.


THE SOFTWARE IS PROVIDED ON AN ""AS-IS"" BASIS AND AUTHORS HAVE NO

OBLIGATION TO PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR

MODIFICATIONS.-->


<!DOCTYPE html>
<html>
<head>
<style>
<?php
$descriptorspec = array(
  0 => array(""pipe"", ""r""),
  1 => array(""pipe"", ""w""),
  2 => array(""file"", ""/tmp/error-output.txt"", ""a"")
  );
$cwd = '/tmp';
$process = proc_open('more /tmp/tainted.txt', $descriptorspec, $pipes, $cwd, NULL);
if (is_resource($process)) {
  fclose($pipes[0]);
  $tainted = stream_get_contents($pipes[1]);
  fclose($pipes[1]);
  $return_value = proc_close($process);
}

$tainted = preg_replace('/\'/', '', $tainted);


echo ""body { color :\'"". $tainted .""\' ; }"" ;
?>
</style> 
</head>
<body>
<h1>Hello World!</h1>
</body>
</html>","echo ""body { color :\'"". $tainted .""\' ; }"" ;",True,True,"echo ""body { color :\'"". $tainted .""\' ; }"" ;","```xml
<Issues>
  <Issue>
    <Type>Security</Type>
    <Weakness>CWE-79</Weakness>
    <Description>Improper Neutralization of Input During Web Page Generation ('Cross-site Scripting')</Description>
    <Severity>Medium</Severity>
    <File>File 1</File>
    <Code>echo ""body { color :\'"". $tainted .""\' ; }"" ;</Code>
    <Justification>The code uses unsanitized input from a file to construct a CSS style. Although single quotes are stripped with preg_replace, this does not prevent arbitrary CSS code from being injected.  An attacker could inject malicious CSS by crafting the /tmp/tainted.txt file.</Justification>
  </Issue>
  <Issue>
    <Type>Security</Type>
    <Weakness>CWE-22</Weakness>
    <Description>Improper Limitation of a Pathname to a Restricted Directory ('Path Traversal')</Description>
    <Severity>High</Severity>
    <File>File 1</File>
    <Code>  $process = proc_open('more /tmp/tainted.txt', $descriptorspec, $pipes, $cwd, NULL);</Code>
    <Justification>The code reads from /tmp/tainted.txt, but does not sanitize the path to ensure that it is legitimate. While this is not directly controlled by the user, it might be possible for an attacker to influence the contents of the /tmp/tainted.txt file, potentially leading to other vulnerabilities if the application relies on the integrity of that file.</Justification>
  </Issue>
  <Issue>
    <Type>Reliability</Type>
    <Weakness>CWE-252</Weakness>
    <Description>Unchecked Return Value</Description>
    <Severity>Low</Severity>
    <File>File 1</File>
    <Code>  fclose($pipes[0]);
  $tainted = stream_get_contents($pipes[1]);
  fclose($pipes[1]);
  $return_value = proc_close($process);</Code>
    <Justification>The code does not check the return values of fclose(), stream_get_contents() and proc_close() to ensure that the operations succeeded. If these functions fail, the program may continue with incorrect or missing data, leading to unexpected behavior.</Justification>
  </Issue>
</Issues>
```"
CWE-90,src/CWE_90__fopen__func_FILTER-CLEANING-email_filter__userByCN-concatenation_simple_quote.php,"<?php







$handle = @fopen(""/tmp/tainted.txt"", ""r"");

if ($handle) {
  if(($tainted = fgets($handle, 4096)) == false) {
    $tainted = """";
  }
  fclose($handle);
} else {
  $tainted = """";
}

$sanitized = filter_var($tainted, FILTER_SANITIZE_EMAIL);
if (filter_var($sanitized, FILTER_VALIDATE_EMAIL))
  $tainted = $sanitized ;
else
  $tainted = """" ;

$query = ""(&(objectCategory=person)(objectClass=user)(cn='"". $tainted . ""'))"";


$ds=ldap_connect(""localhost""); 
$r=ldap_bind($ds);
$sr=ldap_search($ds,""o=My Company, c=US"", $query);  
ldap_close($ds);

?>","$ds=ldap_connect(""localhost"");",True,False,"$query = ""(&(objectCategory=person)(objectClass=user)(cn='"". $tainted . ""'))"";","```xml
<Issues>
  <Issue>
    <Type>Security</Type>
    <Weakness>CWE-90</Weakness>
    <Description>Improper Neutralization of Special Elements used in an LDAP Query ('LDAP Injection')</Description>
    <Severity>High</Severity>
    <File>File 1</File>
    <Code>$query = ""(&(objectCategory=person)(objectClass=user)(cn='"". $tainted . ""'))"";</Code>
    <Justification>The code constructs an LDAP query by directly embedding the potentially tainted input $tainted. This allows an attacker to inject malicious LDAP syntax into the query, potentially bypassing authentication or accessing sensitive information.</Justification>
  </Issue>
  <Issue>
    <Type>Security</Type>
    <Weakness>CWE-252</Weakness>
    <Description>Unchecked Return Value</Description>
    <Severity>Medium</Severity>
    <File>File 1</File>
    <Code>$ds=ldap_connect(""localhost""); 
$r=ldap_bind($ds);
$sr=ldap_search($ds,""o=My Company, c=US"", $query);</Code>
    <Justification>The code does not check the return values of ldap_connect, ldap_bind, and ldap_search. Failure of any of these functions could lead to unexpected behavior or security vulnerabilities, such as using an invalid connection or search result.</Justification>
  </Issue>
  <Issue>
    <Type>Reliability</Type>
    <Weakness>CWE-252</Weakness>
    <Description>Unchecked Return Value</Description>
    <Severity>Medium</Severity>
    <File>File 1</File>
    <Code>$ds=ldap_connect(""localhost""); 
$r=ldap_bind($ds);
$sr=ldap_search($ds,""o=My Company, c=US"", $query);</Code>
    <Justification>The code does not check the return values of ldap_connect, ldap_bind, and ldap_search. If these functions return error values, the application may proceed in an unexpected or undefined state, leading to a failure or incorrect result.</Justification>
  </Issue>
  <Issue>
    <Type>Reliability</Type>
    <Weakness>CWE-703</Weakness>
    <Description>Improper Check or Handling of Exceptional Conditions</Description>
    <Severity>Medium</Severity>
    <File>File 1</File>
    <Code>$handle = @fopen(""/tmp/tainted.txt"", ""r"");

if ($handle) {
  if(($tainted = fgets($handle, 4096)) == false) {
    $tainted = """";
  }
  fclose($handle);
} else {
  $tainted = """";
}</Code>
    <Justification>The code uses the error suppression operator `@` when opening the file. This prevents error messages from being displayed, but it also means that the code does not properly handle the case where the file cannot be opened.  Although the `else` statement does account for the failure to open the file, valuable debug information is lost by suppressing the error in the first place.</Justification>
  </Issue>
  <Issue>
    <Type>Security</Type>
    <Weakness>CWE-424</Weakness>
    <Description>Improper Protection of Alternate Path</Description>
    <Severity>Low</Severity>
    <File>File 1</File>
    <Code>if (filter_var($sanitized, FILTER_VALIDATE_EMAIL))
  $tainted = $sanitized ;
else
  $tainted = """" ;</Code>
    <Justification>The code attempts to sanitize the email input, but if sanitization fails it empties the tainted string. While this does provide some protection against potentially malicious inputs, if the empty string """" is still passed into the LDAP Query, it can cause a default response that can leak data. A more secure alternate path would be to reject the request if validation fails.</Justification>
  </Issue>
</Issues>
```"
CWE-90,src/CWE_90__SESSION__func_preg_match-no_filtering__name-concatenation_simple_quote.php,"<?php







$tainted = $_SESSION['UserData'];

$re = ""/^.*$/"";
if(preg_match($re, $tainted) == 1){
  $tainted = $tainted;
}
else{
  $tainted = """";
}

$query = ""name='"". $tainted . ""'"";


$ds=ldap_connect(""localhost""); 
$r=ldap_bind($ds);
$sr=ldap_search($ds,""o=My Company, c=US"", $query);  
ldap_close($ds);

?>","$ds=ldap_connect(""localhost"");",True,True,"$tainted = $_SESSION['UserData'];

$re = ""/^.*$/"";
if(preg_match($re, $tainted) == 1){
  $tainted = $tainted;
}
else{
  $tainted = """";
}

$query = ""name='"". $tainted . ""'"";","```xml
<Issues>
  <Issue>
    <Type>Security</Type>
    <Weakness>CWE-90</Weakness>
    <Description>Improper Neutralization of Special Elements used in an LDAP Query ('LDAP Injection')</Description>
    <Severity>High</Severity>
    <File>File 1</File>
    <Code>$tainted = $_SESSION['UserData'];

$re = ""/^.*$/"";
if(preg_match($re, $tainted) == 1){
  $tainted = $tainted;
}
else{
  $tainted = """";
}

$query = ""name='"". $tainted . ""'"";</Code>
    <Justification>The code constructs an LDAP query by directly concatenating user-controlled data from $_SESSION['UserData'] without proper sanitization. Even with the regex check, it is still vulnerable as any character is allowed.  This could allow an attacker to inject arbitrary LDAP code, potentially leading to unauthorized access or modification of data.</Justification>
  </Issue>
</Issues>
```"
CWE-79,src/CWE_79__unserialize__func_FILTER-VALIDATION-email_filter__Unsafe_use_untrusted_data-comment.php,"<!-- 
Unsafe sample
input : Get a serialize string in POST and unserialize it
Flushes content of $sanitized if the filter email_filter is not applied
File : unsafe, use of untrusted data in a comment
-->

<!--Copyright 2015 Bertrand STIVALET 

Permission is hereby granted, without written agreement or royalty fee, to

use, copy, modify, and distribute this software and its documentation for

any purpose, provided that the above copyright notice and the following

three paragraphs appear in all copies of this software.


IN NO EVENT SHALL AUTHORS BE LIABLE TO ANY PARTY FOR DIRECT,

INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES ARISING OUT OF THE 

USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF AUTHORS HAVE

BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.


AUTHORS SPECIFICALLY DISCLAIM ANY WARRANTIES INCLUDING, BUT NOT

LIMITED TO THE IMPLIED WARRANTIES OF MERCHANTABILITY, FITNESS FOR A

PARTICULAR PURPOSE, AND NON-INFRINGEMENT.


THE SOFTWARE IS PROVIDED ON AN ""AS-IS"" BASIS AND AUTHORS HAVE NO

OBLIGATION TO PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR

MODIFICATIONS.-->


<!DOCTYPE html>
<html>
<head>
<!--
<?php
$string = $_POST['UserData'] ;
$tainted = unserialize($string);
    

if (filter_var($sanitized, FILTER_VALIDATE_EMAIL))
  $tainted = $sanitized ;
else
  $tainted = """" ;


echo $tainted ;
?>
-->
</head>
<body>
<h1>Hello World!</h1>
</body>
</html>",echo $tainted ;,True,True,"if (filter_var($sanitized, FILTER_VALIDATE_EMAIL))
  $tainted = $sanitized ;
else
  $tainted = """" ;


echo $tainted ;","```xml
<Issues>
  <Issue>
    <Type>Security</Type>
    <Weakness>CWE-502</Weakness>
    <Description>Deserialization of Untrusted Data</Description>
    <Severity>Critical</Severity>
    <File>File 1</File>
    <Code>$string = $_POST['UserData'] ;
$tainted = unserialize($string);</Code>
    <Justification>The code uses unserialize() on user-provided data from $_POST['UserData']. This is highly dangerous as it allows for arbitrary code execution if the serialized string is malicious. An attacker can craft a serialized object that, when unserialized, executes arbitrary PHP code, leading to a complete compromise of the application and potentially the server.</Justification>
  </Issue>
  <Issue>
    <Type>Security</Type>
    <Weakness>CWE-79</Weakness>
    <Description>Improper Neutralization of Input During Web Page Generation ('Cross-site Scripting')</Description>
    <Severity>Medium</Severity>
    <File>File 1</File>
    <Code>if (filter_var($sanitized, FILTER_VALIDATE_EMAIL))
  $tainted = $sanitized ;
else
  $tainted = """" ;


echo $tainted ;</Code>
    <Justification>The code echoes the $tainted variable directly into the HTML comment without proper sanitization. If $tainted contains HTML or JavaScript, it will be executed by the browser, leading to a Cross-Site Scripting (XSS) vulnerability. While the code includes a check using filter_var with FILTER_VALIDATE_EMAIL, it assigns the value to the potentially unsanitized `$sanitized` variable, and then copies that to `$tainted` if the email filter is not applied. This does not prevent XSS since `$sanitized` has not been initialized or sanitized initially.</Justification>
  </Issue>
  <Issue>
    <Type>Reliability</Type>
    <Weakness>CWE-457</Weakness>
    <Description>Use of Uninitialized Variable</Description>
    <Severity>Medium</Severity>
    <File>File 1</File>
    <Code>if (filter_var($sanitized, FILTER_VALIDATE_EMAIL))
  $tainted = $sanitized ;
else
  $tainted = """" ;</Code>
    <Justification>The code uses the `$sanitized` variable within the `filter_var` function and in the assignment `$tainted = $sanitized`, but `$sanitized` is never initialized prior to this use. This means `$sanitized` will contain a default value depending on PHP's configuration, or might trigger an error, leading to unpredictable behavior.</Justification>
  </Issue>
</Issues>
```"
CWE-79,src/CWE_79__unserialize__func_mysql_real_escape_string__Use_untrusted_data-body.php,"<!-- 
Unsafe sample
input : Get a serialize string in POST and unserialize it
SANITIZE : use of mysql_real_escape string
File : use of untrusted data in the body
-->

<!--Copyright 2015 Bertrand STIVALET 

Permission is hereby granted, without written agreement or royalty fee, to

use, copy, modify, and distribute this software and its documentation for

any purpose, provided that the above copyright notice and the following

three paragraphs appear in all copies of this software.


IN NO EVENT SHALL AUTHORS BE LIABLE TO ANY PARTY FOR DIRECT,

INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES ARISING OUT OF THE 

USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF AUTHORS HAVE

BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.


AUTHORS SPECIFICALLY DISCLAIM ANY WARRANTIES INCLUDING, BUT NOT

LIMITED TO THE IMPLIED WARRANTIES OF MERCHANTABILITY, FITNESS FOR A

PARTICULAR PURPOSE, AND NON-INFRINGEMENT.


THE SOFTWARE IS PROVIDED ON AN ""AS-IS"" BASIS AND AUTHORS HAVE NO

OBLIGATION TO PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR

MODIFICATIONS.-->


<!DOCTYPE html>
<html>
<head/>
<body>
<?php
$string = $_POST['UserData'] ;
$tainted = unserialize($string);
    

$tainted = mysql_real_escape_string($tainted);


echo $tainted ;
?>
<h1>Hello World!</h1>
</body>
</html>
",echo $tainted ;,False,False,,"```xml
<Issues>
  <Issue>
    <Type>Security</Type>
    <Weakness>CWE-502</Weakness>
    <Description>Deserialization of Untrusted Data</Description>
    <Severity>High</Severity>
    <File>File 1</File>
    <Code>$string = $_POST['UserData'] ;
$tainted = unserialize($string);</Code>
    <Justification>The code uses unserialize() on user-supplied data from $_POST['UserData'], which allows an attacker to inject arbitrary code or manipulate the application state. Deserialization of untrusted data is a critical security vulnerability.</Justification>
  </Issue>
  <Issue>
    <Type>Security</Type>
    <Weakness>CWE-477</Weakness>
    <Description>Use of Obsolete Function</Description>
    <Severity>Low</Severity>
    <File>File 1</File>
    <Code>$tainted = mysql_real_escape_string($tainted);</Code>
    <Justification>The code uses the mysql_real_escape_string() function, which is deprecated. The use of deprecated functions can lead to security vulnerabilities and compatibility issues.  It's recommended to use mysqli_real_escape_string() or PDO instead.</Justification>
  </Issue>
</Issues>
```"
